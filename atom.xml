<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long Luo&#39;s Life Notes</title>
  
  <subtitle>每一天都是奇迹</subtitle>
  <link href="https://www.longluo.me/atom.xml" rel="self"/>
  
  <link href="https://www.longluo.me/"/>
  <updated>2024-07-15T14:57:09.864Z</updated>
  <id>https://www.longluo.me/</id>
  
  <author>
    <name>Long Luo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数学之美：几何视角下的高斯积分(Gaussian Integral)</title>
    <link href="https://www.longluo.me/blog/2024/05/11/gaussian-integral/"/>
    <id>https://www.longluo.me/blog/2024/05/11/gaussian-integral/</id>
    <published>2024-05-11T07:34:38.000Z</published>
    <updated>2024-07-15T14:57:09.864Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>从之前的文章 <a href="https://www.longluo.me/blog/2024/04/27/normal-distribution/">正态分布(NormalDistribution)公式为什么长这样？</a> 和 <a href="https://www.longluo.me/blog/2024/05/02/least-squares-and-normal-distribution/">从最小二乘法到正态分布：高斯是如何找到失踪的谷神星的？</a>，我们使用了 <span class="math inline">\(2\)</span>种不同的方法最终得到了如下公式 <span class="math inline">\((1)\)</span>所示的误差的概率密度函数 ( <span class="math inline">\(\text{ProbabilityDensity Function}\)</span> ) ：</p><p><span class="math display">\[f(x) = \mathrm{e}^{-cx^2}, \, c &gt; 0                 \tag{1} \label{1}\]</span></p><p>其函数图像如下图 1 所示的钟形曲线 ( <span class="math inline">\(\text{Bell Curve}\)</span> ) ：</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/standard_deviation_diagram_micro.svg" alt="图1. 钟形曲曲线"><figcaption aria-hidden="true">图1. 钟形曲曲线</figcaption></figure><p>在概率论中，我们需要保证上图 1 中 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(x\)</span> 轴围成的面积是 <span class="math inline">\(1\)</span> , 即：</p><p><span class="math display">\[\int_{- \infty}^{+ \infty} f(x) \mathrm{d}x = 1              \tag{2}\label{2}\]</span></p><p>最终我们得到了正态分布 ( <span class="math inline">\(\text{NormalDistribution}\)</span> ) 的公式如下所示：</p><p><span class="math display">\[f(x) = {\frac {1}{\sigma {\sqrt {2 \pi }}}}\;e^{-{\frac {\left(x - \mu\right)^{2}}{2 \sigma ^{2}}}}                \tag{3} \label{3}\]</span></p><p>上式中有一个 <span class="math inline">\(\pi\)</span> ，用费曼( <span class="math inline">\(\text{Richard Feynman}\)</span>)的话来说，当我们看到一个公式中存在 <span class="math inline">\(\pi\)</span> 时，我们都要问自己“Where is thecycle?”。我们知道公式 <span class="math inline">\(\eqref{3}\)</span>中的归一化系数 <span class="math inline">\(\frac {1}{\sigma {\sqrt {2\pi }}}\)</span> 是为了保证 <span class="math inline">\(f(x)\)</span>下的面积为 <span class="math inline">\(1\)</span> ，出现 <span class="math inline">\(\pi\)</span> 是因为高斯积分 ( <span class="math inline">\(\text{Gaussian Integral}\)</span> ) 的结果为 <span class="math inline">\(\sqrt{\pi}\)</span> 。</p><p>那么什么是高斯积分呢？高斯积分和圆有什么关系呢？</p><span id="more"></span><h1 id="什么是高斯积分">什么是高斯积分？</h1><p>高斯积分是数学王子高斯 ( <span class="math inline">\(\text{CarlFriedrich Gauss}\)</span> ) 名字命名，和正态分布密切相关，对高斯函数 (<span class="math inline">\(\text{Gauss function}\)</span> )，也就是正态分布的概率密度函数在整个实数域进行积分，即 <span class="math inline">\(\int_{-\infty}^{+\infty} \mathrm{e} ^{-x^2}\,\mathrm{d}{x}\)</span> ，如下图 2 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_integral_dx.jpg" alt="图2. 高斯积分 ( \text{ Gaussian Integral} )"><figcaption aria-hidden="true">图2. 高斯积分 ( <span class="math inline">\(\text{ Gaussian Integral}\)</span> )</figcaption></figure><p>初看 <span class="math inline">\(\int e^{-x^2} \mathrm{d}{x}\)</span>，你可能会觉得用分部积分可以求解原函数吧！一顿操作猛如虎之后，发现根本就计算不出来。</p><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_antiderivative.jpg" alt="图3. 高斯积分的原函数"><figcaption aria-hidden="true">图3. 高斯积分的原函数</figcaption></figure><p>因为高斯积分在初等函数范围内是不可积的，其原函数无法用初等函数来表示，如下公式所示：</p><p><span class="math display">\[F(x) = \int_{0}^{x} e^{-t^2} \mathrm{d}t                    \tag{4}\label{4}\]</span></p><p>好在早有天才数学家用天才的解法得到了高斯积分的值为 <span class="math inline">\(\sqrt{\pi}\)</span> ，如下图 4 所示：</p><p><span class="math display">\[\int_{-\infty}^{+\infty} \mathrm{e} ^{-x^2} \,\mathrm{d}{x} =\sqrt{\pi}                \tag{5} \label{5}\]</span></p><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_integral.svg" alt="图4. 高斯积分的值"><figcaption aria-hidden="true">图4. 高斯积分的值</figcaption></figure><p>高斯积分看起来和<strong>圆</strong>没有任何关系，但结果中却出现了<span class="math inline">\(\pi\)</span> ，那圆在哪里呢？</p><p>求解高斯积分有很多种解法，均来自天才数学家的天才想法。这里我们将介绍<span class="math inline">\(3\)</span>种方法，第一种是常见的直角坐标系转为极坐标系法，另外 <span class="math inline">\(2\)</span> 种来自 <a href="https://3blue1brown.com/">3Blue1Brown</a> 的视频 <a href="https://www.youtube.com/watch?v=cy8r7WSuT1I">Why π is in thenormal distribution (beyond integral tricks)</a>，都非常<strong>优雅且直观</strong>，下面就让我们沉浸在数学的海洋里吧，感受数学的美！</p><h1 id="极坐标系法">极坐标系法</h1><p>我们设 <span class="math inline">\(I\)</span> 表示高斯积分的值：</p><p><span class="math display">\[I = \int_{-\infty}^{+\infty} \mathrm{e} ^{-x^2}\,\mathrm{d}{x}             \tag{6} \label{6}\]</span></p><p>因为定积分是一个数，与被积函数的自变量无关，简单换下元则有：</p><p><span class="math display">\[I = \int_{-\infty}^{+\infty} \mathrm{e} ^{-y^2}\,\mathrm{d}{y}             \tag{7} \label{7}\]</span></p><p>二者相乘，则对高斯积分进行了升维，得到 <span class="math inline">\(I^2\)</span> ：</p><p><span class="math display">\[\begin{aligned}I^2 &amp; = \int_{-\infty}^{+\infty} \mathrm{e} ^{-x^2} \,\mathrm{d}{x}\int_{-\infty}^{+\infty} \mathrm{e} ^{-y^2} \,\mathrm{d}{y} \\&amp; = \int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty} \mathrm{e}^{-(x^2 + y^2)} \,\mathrm{d}{x} \,\mathrm{d}{y}\end{aligned}\]</span></p><h2 id="转换坐标系">转换坐标系</h2><p>下面我们从直角坐标系 ( Cartesian coordinates ) 转换为极坐标系 ( Polarcoordinates ) ，则有：</p><p><span class="math display">\[\begin{cases}x = r \cos \theta \\y = r \sin \theta\end{cases}\]</span></p><p>在直角坐标系中，我们的积分区域是：</p><p><span class="math display">\[\begin{cases}-\infty &lt; x &lt; \infty \\-\infty &lt; y &lt; \infty\end{cases}\]</span></p><figure><img src="https://www.longluo.me/assets/blog/images/cartesian/cartesian_coordinates_2d.svg" alt="图5. 笛卡尔坐标系"><figcaption aria-hidden="true">图5. 笛卡尔坐标系</figcaption></figure><p>转换为极坐标系之后，积分区域变为：</p><figure><img src="https://www.longluo.me/assets/blog/images/polar_coordinate/polar_graph_paper.svg" alt="图6. 极坐标系"><figcaption aria-hidden="true">图6. 极坐标系</figcaption></figure><p><span class="math display">\[\begin{cases}0&lt; r &lt; \infty \\0&lt; \theta &lt; 2 \pi\end{cases}\]</span></p><h2 id="为什么-mathrmdx-mathrmdy-r-mathrmdrmathrmdtheta">为什么 <span class="math inline">\(\mathrm{d}x \mathrm{d}y = r\mathrm{d}r\mathrm{d}\theta\)</span> ？</h2><p>在直角坐标系中，面积微元 <span class="math inline">\(\mathrm{d}\sigma = \mathrm{d}x \mathrm{d}y\)</span>，而在极坐标系中，其面积微元如下图 7 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/polar_infinite_small.png" alt="图7. 极坐标系中的无穷小"><figcaption aria-hidden="true">图7. 极坐标系中的无穷小</figcaption></figure><p>计算其面积：</p><p><span class="math display">\[\begin{aligned}\mathrm{d} \sigma &amp; = \frac{1}{2}\left(r + \mathrm{d}r\right)^2\cdot \mathrm{d}\theta - \frac{1}{2}r^2\cdot \mathrm{d}\theta\\&amp; = \frac{1}{2}\left[r^2 + 2r \mathrm{d}r + \left(\mathrm{d}r\right)^2-r^2\right] \mathrm{d}\theta \\&amp; = \frac{1}{2}\left[2r \mathrm{d} r + \left(\mathrm{d} r \right)^2\right]  \cdot \mathrm{d}\theta\end{aligned}\]</span></p><p>因为 <span class="math inline">\((\mathrm{d}r)^2\)</span> 是 <span class="math inline">\(2r\mathrm{d}r\)</span> 的高阶无穷小，故有：</p><p><span class="math display">\[\mathrm{d} \sigma = \frac{1}{2}(2r \mathrm{d}r) \mathrm{d}\theta = r\mathrm{d}r \mathrm{d}\theta\]</span></p><p>所以：</p><p><span class="math display">\[\mathrm{d}x \mathrm{d}y = r \mathrm{d}r\mathrm{d}\theta\]</span></p><h2 id="求解积分">求解积分</h2><p>在极坐标系中， <span class="math inline">\(r^2 = x^2 + y^2\)</span>，则有：</p><p><span class="math display">\[\begin{aligned}I^2 &amp; = \int_0^{2\pi} \int_0^{+\infty} \mathrm{e} ^{-r^2} r\,\mathrm{d}{r} \,\mathrm{d}{\theta} \\&amp; = \int_{\theta = 0}^{2\pi} \mathrm{d}{\theta} \int_{r=0}^{\infty}\mathrm{e} ^{-r^2} r \,\mathrm{d}{r} \\&amp; = 2 \pi \int_0^{+\infty} r \mathrm{e} ^{-r^2} \,\mathrm{d}{r}\end{aligned}\]</span></p><p>令 <span class="math inline">\(u = r^2\)</span> ，则有：</p><p><span class="math display">\[\mathrm{d}u = 2r \mathrm{d}{r}\]</span></p><p><span class="math display">\[r \mathrm{d}r = \frac{1}{2}\mathrm{d}u\]</span></p><p>根据微积分基本定理易得：</p><p><span class="math display">\[\begin{aligned}I^2 &amp; = \pi \int_0^{+\infty} \mathrm{e} ^{-u} \,\mathrm{d}{u} \\&amp; = \pi \left (-\mathrm{e} ^{-u}) \right\rvert _0^{+\infty}  \\&amp; = \pi\end{aligned}\]</span></p><p>开方，最终我们求出了高斯积分的值：</p><p><span class="math display">\[I = \int_{-\infty}^{+\infty} \mathrm{e} ^{-x^2} \,\mathrm{d}{x} =\sqrt{\pi}\]</span></p><h1 id="d-钟形曲面下的体积">3D 钟形曲面下的体积</h1><p>转换为极坐标法是常用的求高斯积分的方法，尤其是对高斯积分<strong>升维</strong>是神来之笔，那么升维之后的高斯函数是什么样的呢？</p><p>一维的高斯函数为：</p><p><span class="math display">\[f_1(x, y) = \mathrm{e}^{-x^2}\]</span></p><p>那么二维的高斯函数则为：</p><p><span class="math display">\[f_2(x, y) = \mathrm{e}^{-x^2} \mathrm{e}^{-y^2} = \mathrm{e}^{- (x^2 +y^2)}\]</span></p><p>一维的高斯函数表现为钟形曲线，二维的高斯函数则是一维的高斯函数沿着<span class="math inline">\(z\)</span> 轴旋转，如下图 8 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_rotate.jpg" alt="图8. 钟形曲线沿 z 轴旋转"><figcaption aria-hidden="true">图8. 钟形曲线沿 <span class="math inline">\(z\)</span> 轴旋转</figcaption></figure><p>旋转一周形成 <span class="math inline">\(3\)</span>维的钟形曲面，如下图 9 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_3d_bell_surface.jpg" alt="图9. 3 维钟形曲面"><figcaption aria-hidden="true">图9. 3 维钟形曲面</figcaption></figure><p>对于钟形曲面上的任意点 <span class="math inline">\(P(x, y)\)</span>，其距离 z 轴的距离 <span class="math inline">\(r = x^2 + y^2\)</span>， 如下图 10 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_2d_radius.jpg" alt="图10. 钟形曲面上点 P(x, y)"><figcaption aria-hidden="true">图10. 钟形曲面上点 <span class="math inline">\(P(x, y)\)</span></figcaption></figure><p>很明显， <span class="math inline">\(3\)</span>维钟形曲面满足径向对称性，到了这里<strong>圆</strong>出现了！</p><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_circle_r.jpg" alt="图11. 3 维钟形曲面满足径向对称性"><figcaption aria-hidden="true">图11. 3维钟形曲面满足径向对称性</figcaption></figure><p>考虑如下图 12 所示的同心圆筒，其周长为 <span class="math inline">\(2\pi r\)</span> ，高为 <span class="math inline">\(\mathrm{e}^{-r^2}\)</span> ，厚度为 <span class="math inline">\(\mathrm{d}r\)</span> ，其体积为：</p><p><span class="math display">\[\mathrm{d}V = 2 \pi r \mathrm{e}^{-r^2}\mathrm{d}r\]</span></p><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_cylinders.jpg" alt="图12. 同心圆筒体积"><figcaption aria-hidden="true">图12. 同心圆筒体积</figcaption></figure><h1 id="section"></h1><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_slices_parallel.jpg" alt="图7. 极坐标系中的无穷小"><figcaption aria-hidden="true">图7. 极坐标系中的无穷小</figcaption></figure><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_slice_y.jpg" alt="图7. 极坐标系中的无穷小"><figcaption aria-hidden="true">图7. 极坐标系中的无穷小</figcaption></figure><figure><img src="https://www.longluo.me/assets/blog/images/gaussian/gaussian_slice_scale.jpg" alt="图7. 极坐标系中的无穷小"><figcaption aria-hidden="true">图7. 极坐标系中的无穷小</figcaption></figure><h1 id="总结">总结</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Gaussian_integral">高斯积分Gaussian Integral</a></li><li><a href="https://en.wikipedia.org/wiki/Pi">圆周率 Pi</a></li><li><a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system">笛卡尔坐标系</a></li><li><a href="https://en.wikipedia.org/wiki/Polar_coordinate_system">极坐标</a></li><li><a href="https://www.zhihu.com/question/368888687">直角坐标与极坐标的互化中，为什么dxdy=rdrdθ？</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从之前的文章 &lt;a href=&quot;https://www.longluo.me/blog/2024/04/27/normal-distribution/&quot;&gt;正态分布(Normal
Distribution)公式为什么长这样？&lt;/a&gt; 和 &lt;a href=&quot;https://www.longluo.me/blog/2024/05/02/least-squares-and-normal-distribution/&quot;&gt;从最小二乘法到正态分布：高斯是如何找到失踪的谷神星的？&lt;/a&gt;
，我们使用了 &lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt;
种不同的方法最终得到了如下公式 &lt;span class=&quot;math inline&quot;&gt;&#92;((1)&#92;)&lt;/span&gt;
所示的误差的概率密度函数 ( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Probability
Density Function}&#92;)&lt;/span&gt; ) ：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
f(x) = &#92;mathrm{e}^{-cx^2}, &#92;, c &amp;gt; 0                 &#92;tag{1} &#92;label{1}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其函数图像如下图 1 所示的钟形曲线 ( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Bell Curve}&#92;)&lt;/span&gt; ) ：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/normal_distribution/standard_deviation_diagram_micro.svg&quot; alt=&quot;图1. 钟形曲曲线&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图1. 钟形曲曲线&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;在概率论中，我们需要保证上图 1 中 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 轴围成的面积是 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; , 即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;int_{- &#92;infty}^{+ &#92;infty} f(x) &#92;mathrm{d}x = 1              &#92;tag{2}
&#92;label{2}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最终我们得到了正态分布 ( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Normal
Distribution}&#92;)&lt;/span&gt; ) 的公式如下所示：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
f(x) = {&#92;frac {1}{&#92;sigma {&#92;sqrt {2 &#92;pi }}}}&#92;;e^{-{&#92;frac {&#92;left(x - &#92;mu
&#92;right)^{2}}{2 &#92;sigma ^{2}}}}                &#92;tag{3} &#92;label{3}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上式中有一个 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;pi&#92;)&lt;/span&gt; ，用费曼( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Richard Feynman}&#92;)&lt;/span&gt;
)的话来说，当我们看到一个公式中存在 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;pi&#92;)&lt;/span&gt; 时，我们都要问自己“Where is the
cycle?”。我们知道公式 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;eqref{3}&#92;)&lt;/span&gt;
中的归一化系数 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac {1}{&#92;sigma {&#92;sqrt {2
&#92;pi }}}&#92;)&lt;/span&gt; 是为了保证 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt;
下的面积为 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; ，出现 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;pi&#92;)&lt;/span&gt; 是因为高斯积分 ( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Gaussian Integral}&#92;)&lt;/span&gt; ) 的结果为 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sqrt{&#92;pi}&#92;)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;那么什么是高斯积分呢？高斯积分和圆有什么关系呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Normal Distribution" scheme="https://www.longluo.me/tags/Normal-Distribution/"/>
    
    <category term="Gaussian Integral" scheme="https://www.longluo.me/tags/Gaussian-Integral/"/>
    
    <category term="Circle" scheme="https://www.longluo.me/tags/Circle/"/>
    
  </entry>
  
  <entry>
    <title>从最小二乘法到正态分布：高斯是如何找到失踪的谷神星的？</title>
    <link href="https://www.longluo.me/blog/2024/05/02/least-squares-and-normal-distribution/"/>
    <id>https://www.longluo.me/blog/2024/05/02/least-squares-and-normal-distribution/</id>
    <published>2024-05-02T02:35:08.000Z</published>
    <updated>2024-07-10T13:35:45.588Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>在上一篇文章 <a href="https://www.longluo.me/blog/2024/04/27/normal-distribution/">正态分布(NormalDistribution)公式为什么长这样？</a>中，我们使用了<strong>投掷飞镖</strong>的模型，推导出了正态分布( <span class="math inline">\(\text{Normal Distribution}\)</span>)的表达式。这种方法既优雅又直观，所以常被用于科普视频或者文章中。那么这个例子是怎么来的呢？我们知道这个方法是天文学家赫歇尔（<span class="math inline">\(\text{John Herschel}\)</span> ）在 1850年给出的，难道他在投掷飞镖时想到的吗？</p><p>答案是否定的，原因是因为赫歇尔作为一个天文学家，需要精确的测量天体的位置，而在观测星星时，必须要考虑误差的影响。星星在天球中的位置误差是<strong>二维</strong>的，考虑到误差大家不太好理解，所以用了投掷飞镖这个更通俗易懂的例子。</p><p>正如法国著名哲学家孔德( <span class="math inline">\(\text{AugusteComte}\)</span> ，1798-1857)所说“To understand a science, it isnecessary to know its history.”，只有了解这个学科的发展历史，了解这个学科的重要概念是如何建立起来的，才能真正理解这个学科。不同于我们在课本中学习顺序，科学是用来解决实际问题的，科学是由一个个问题所驱动发展的。正如仅次牛顿和爱因斯坦的伟大物理学家麦克斯韦(<span class="math inline">\(\text{James Clerk Maxwell}\)</span> )曾说过“It is of great advantage to the student of any subject to readthe original memoirs on that subject, for science is always mostcompletely assimilated when it is in the nascentstate…”，我们学习历史上科学家是如何解决这些问题，用了什么方法，才能获取某个概念的<strong>insight</strong> ，建立 <strong>intuition</strong> 。</p><p>正态分布，又被称为高斯分布（ <span class="math inline">\(\text{Gaussian Distribution}\)</span>），人们可能会以为正态分布是由高斯发现的，但事实并非如此！</p><p>正态分布最早是由法国数学家棣莫弗( <span class="math inline">\(\text{Abraham de Moivre}\)</span> , 1667-1754)在1718年左右发现的。他为了解决朋友提出的一个赌博问题，而去认真研究了二项分布。他发现当实验次数增大时，二项分布(<span class="math inline">\(p=0.5\)</span>)趋近于一个看起来呈钟形的曲线，如下图 1所示。后来著名法国数学家拉普拉斯( <span class="math inline">\(\text{Pierre-Simon Laplace}\)</span> ,1749-1827)对此作了更详细的研究，并证明了 <span class="math inline">\(p\ne 0.5\)</span>时二项分布的极限也是正态分布。之后人们便将此称为<strong>棣莫弗 -拉普拉斯中心极限定理</strong>（ <span class="math inline">\(\text{Central limit theorem}\)</span> ）。</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/de_moivre_laplace.gif" alt="图1. 二项分布趋近钟形曲线"><figcaption aria-hidden="true">图1. 二项分布趋近钟形曲线</figcaption></figure><h1 id="失踪的谷神星">失踪的谷神星</h1><p>16 和 17世纪是天文学发展的黄金时期，这一时期的科学革命彻底改变了人类对宇宙的理解。哥白尼(<span class="math inline">\(\text{Nicolaus Copernicus}\)</span>，1473-1543)的日心说、开普勒( <span class="math inline">\(\text{JohannesKepler}\)</span> ，1571-1630)的行星运动三定律、伽利略( <span class="math inline">\(\text{Galileo Galilei}\)</span>，1564-1642)的望远镜观测以及牛顿( <span class="math inline">\(\text{Isaac Newton}\)</span>，1643-1727)的万有引力定律共同构成了现代天文学的基础。这一时期的科学家们不仅改变了人类对宇宙的理解，还为后续的科学研究提供了重要的方法和工具。</p><span id="more"></span><p>1766 年德国物理学家提丢斯（ <span class="math inline">\(\text{JohannDaniel Titius}\)</span>）把已知太阳系中行星的数据列成如下一张表，如下表所示：</p><table><thead><tr class="header"><th>Planet</th><th>Actual</th><th>Formula</th></tr></thead><tbody><tr class="odd"><td>Mercury</td><td>0.387</td><td>0.4</td></tr><tr class="even"><td>Venus</td><td>0.723</td><td>0.7</td></tr><tr class="odd"><td>Earth</td><td>1.00</td><td>1.0</td></tr><tr class="even"><td>Mars</td><td>1.52</td><td>1.6</td></tr><tr class="odd"><td><strong>???</strong></td><td></td><td>2.8</td></tr><tr class="even"><td>Jupiter</td><td>5.20</td><td>5.2</td></tr><tr class="odd"><td>Saturn</td><td>9.55</td><td>10.0</td></tr><tr class="even"><td>Uranus</td><td>19.2</td><td>19.6</td></tr><tr class="odd"><td>Neptune</td><td>30.1</td><td>38.8</td></tr></tbody></table><p>他发现行星与太阳之间的距离大致满足以下经验公式：</p><p><span class="math display">\[a(n) = 0.3 \times 2^n + 0.4 \text{AU}, \, n = -\infty , 0, 1, 2, 3, 4,\dots\]</span></p><p>其中 <span class="math inline">\(a_n\)</span> 是第 <span class="math inline">\(n\)</span> 颗行星离太阳的平均距离（以天文单位 AU表示）， <span class="math inline">\(n\)</span>是行星的顺序编号，但水星的 <span class="math inline">\(n\)</span> 值为<span class="math inline">\(-\infty\)</span> 。</p><p>之后提丢斯写信联系了德国天文学家博得（<span class="math inline">\(\text{Johann ElertBode}\)</span>），告知博得自己这一发现。博得看到之后，于 1772年进一步推广和公开发表了这一公式。</p><p>从表格中我们也可以看到，火星和木星的轨道之间距离大得不正常。根据公式，在<span class="math inline">\(n = 5\)</span> ，距离太阳 <span class="math inline">\(2.8\)</span> AU处应该存在一颗行星，于是博得呼吁天文学家都来寻找这颗行星。</p><p>最终， 1801 年 1 月，意大利天文学家朱塞普·皮亚齐( <span class="math inline">\(\text{Giuseppe Piazzi}\)</span> ,1746-1826)发现了第一颗小行星谷神星( <span class="math inline">\(\text{Ceres}\)</span> ) ，其距离与公式预测的 <span class="math inline">\(a_5 = 2.8\)</span> 天文单位非常接近，其轨道如下图2 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/astronomy/ceres_orbit_circle.png" alt="图2. 谷神星的轨道"><figcaption aria-hidden="true">图2. 谷神星的轨道</figcaption></figure><p>皮亚齐发现谷神星之后，由于当时的观测技术和数据有限，皮亚齐只能观测到谷神星数周的运动轨迹。随后，谷神星就进入了太阳的光芒中，无法继续观测，导致其位置变得难以确定。天文学家们急需一种方法来预测谷神星的轨道，以便在其再次出现时能够重新观测到它。但是天文学家无法从收集到的少量数据中推断出它的位置，他们需要用不到总轨道<span class="math inline">\(1 \%\)</span>的数据求解开普勒的椭圆轨道复杂非线性方程，这是一项艰巨的数学挑战。</p><h1 id="天才高斯出场">天才高斯出场</h1><p>这时，天才高斯出场了，当时他只有 24岁，但他已经在数学领域展现出非凡的才华。高斯 17岁时发现了质数分布定理和最小二乘法，19岁时，证明了正十七边形可以用尺规作图，解决了这一流传 2000年的数学难题。在看到这个问题之后，高斯只用了开普勒的行星运动三定律，和他新发现的误差分布规律和最小二乘法(<span class="math inline">\(\text{Least Squares Method}\)</span> )，仅使用了下表中的 <span class="math inline">\(3\)</span>个数据就计算出了谷神星的轨道。</p><table><colgroup><col style="width: 30%"><col style="width: 17%"><col style="width: 17%"><col style="width: 34%"></colgroup><thead><tr class="header"><th></th><th>right ascension</th><th>declination</th><th>Time</th></tr></thead><tbody><tr class="odd"><td>Jan.&nbsp;2</td><td><span class="math inline">\(51^{\circ} 47^{\prime} 49^{\prime\prime}\)</span></td><td><span class="math inline">\(15^{\circ} 41^{\prime} 5^{\prime\prime}\)</span></td><td><span class="math inline">\(8 \mathrm{h} 39\mathrm{m}4.6\mathrm{s}\)</span></td></tr><tr class="even"><td>Jan.&nbsp;22</td><td><span class="math inline">\(51^{\circ} 42^{\prime} 21^{\prime\prime}\)</span></td><td><span class="math inline">\(17^{\circ} 3^{\prime} 18^{\prime\prime}\)</span></td><td><span class="math inline">\(7 \mathrm{h} 20 \mathrm{m} 21.7\mathrm{s}\)</span></td></tr><tr class="odd"><td>Feb.&nbsp;11</td><td><span class="math inline">\(54^{\circ} 10^{\prime} 23^{\prime\prime}\)</span></td><td><span class="math inline">\(18^{\circ} 47^{\prime} 59^{\prime\prime}\)</span></td><td><span class="math inline">\(6 \mathrm{h} 11 \mathrm{m} 58.2\mathrm{s}\)</span></td></tr></tbody></table><p>他的最终计算是指向了一个完全不同的天空区域，之前被其他科学家所忽视的区域。从上图2也可以看出谷神星并不在黄道平面上，而是和黄道平面有个较大的夹角，所以谷神星才不容易寻找。</p><p>1801 年 12 月 31 日夜，德国天文爱好者奥伯斯( <span class="math inline">\(\text{Heinrich Olbers}\)</span> ,1758-1840)，在高斯预言的时间里，用望远镜对准了这片天空。果然不出所料，谷神星出现了！</p><p>高斯计算谷神星轨道的方法比较复杂，可以写一篇几十页的论文，这里就不详细介绍了，大家可以去网上找找相关的论文阅读。</p><p>高斯使用的数据分析方法，就是以正态误差分布为基础的最小二乘法，那么高斯是如何推导出误差是正态分布的呢？我们将在下一节进行推导。</p><figure><img src="https://www.longluo.me/assets/blog/images/linear_regression/linear_least_squares_example2.svg" alt="图3. 最小二乘法"><figcaption aria-hidden="true">图3. 最小二乘法</figcaption></figure><h1 id="误差是怎么分布的">误差是怎么分布的？</h1><p>天文学是人类历史上最古老的科学之一，其起源可以追溯到史前时代。古代文明通过观察天空中的天体运动来制定历法、导航和进行农业活动。天文学家不光对天体进行了长期的系统观测，记录了大量的天文现象，而且试图预测不同行星和恒星的轨迹和位置。</p><p>由于观察者、仪器和许多其他因素，天文学家的测量数据存在误差。即使对于同一个物体，他们也有不同的观察结果。这里误差指的是观测值与实际值之间的差异。千百年以来，对于有误差的测量数据，多次测量取算术平均是比较好的处理方法。虽然这种方法缺乏理论上的论证，也不断的受到一些人的质疑，但取算术平均作为一种异常直观的方式，在多年积累的数据的处理经验中也得到相当程度的验证，被认为是一种良好的数据处理方法。</p><p>伽利略在 1632年的著作《关于托勒密和哥白尼两个主要世界体系的对话》中，非正式地讨论了他所谓的“观测误差”，也就是今天所谓的“随机误差分布”，对误差的分布做过一些定性的描述，主要是以下2 个假设：</p><ol type="1"><li>观测值围绕真实值对称分布，也就是说，误差对称分布在零左右；</li><li>小错误比大错误更频繁地发生。</li></ol><p>为了系统地分析误差，人们希望找到<strong>误差分布曲线</strong>来描述误差。因为误差显然是连续的，我们希望找到误差的概率密度函数(<span class="math inline">\(\text{Probability Density Function}\)</span>) 。那么误差的 PDF 是什么样的呢？</p><p>粗看这 2 个假设，看起来和赫歇尔（ <span class="math inline">\(\text{John Herschel}\)</span> ）的 2个假设差不了太多，那么仅凭这 2个假设，能推导出误差是<strong>正态分布</strong>吗？</p><p>答案是<strong>否定</strong>的！</p><p>因为满足上述假设的曲线有很多，满足上述 2 个条件的函数有很多个，如下图4 就展示了其中的几种可能函数形状：</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/error_curve.png" alt="图4. 不同的误差曲线"><figcaption aria-hidden="true">图4. 不同的误差曲线</figcaption></figure><p>历史上很多科学家尝试寻找误差分布曲线，比如辛普森( Thomas Simpson ,1710-1761)、拉普拉斯等，但他们找到的误差分布曲线都不是正态分布。而高斯最终找到了误差概率密度函数是正态分布，如下公式所示：</p><p><span class="math display">\[\varphi \Delta = \frac{h}{\sqrt {\pi}} \, e^{-hh \Delta \Delta}\]</span></p><p>其中 <span class="math inline">\(\Delta\)</span> 是误差，也就是 <span class="math inline">\(x - \mu\)</span> ， <span class="math inline">\(h\)</span> 是一个常量，也就是观测精度的度量。</p><p>下面就让我们跟上高斯的思路去推导下，看看高斯是如何推导出误差呈正态分布的呢？</p><h1 id="高斯是如何推导出误差正态分布的呢">高斯是如何推导出误差正态分布的呢？</h1><p>我们使用大写字母 <span class="math inline">\(X, Y, Z\)</span>表示<strong>随机变量</strong>，小写字母 <span class="math inline">\(x,y, z\)</span> 表示<strong>随机变量具体的值</strong>。</p><p>设观测对象的真实位置是 <span class="math inline">\(m\)</span>，进行多次重复测量之后，我们得到测量数据 <span class="math inline">\(X_1, X_2, \cdots, X_{n-1}, X_n\)</span>。这些测量值都存在误差，用希腊字母 <span class="math inline">\(\epsilon\)</span> 来表示误差， <span class="math inline">\(\epsilon_i = X_i - m\)</span>。我们认为这些误差满足一个未知的概率密度函数 PDF ，设为： <span class="math inline">\(f_{\epsilon}(\varepsilon)\)</span> 。</p><p>基于上面提到的 2 个假设，我们已经知道了 PDF 的一些属性。</p><p>假设 1 告诉我们 <span class="math inline">\(f_{\epsilon}\)</span>是偶函数，如下公式所示：</p><p><span class="math display">\[f_{\epsilon}(\varepsilon ) = f_{\epsilon }(-\varepsilon )\]</span></p><p>假设 2 则告诉我们，小误差比大误差更容易发生，则 <span class="math inline">\(\varepsilon\)</span> 越接近 <span class="math inline">\(0\)</span> , 发生的可能性就越大。</p><p>现在我们有了一系列重复的测量值 <span class="math inline">\(x_1, x_2,\cdots , x_{n-1}, x_n\)</span> ，同时也有对应的一系列误差值 <span class="math inline">\(\varepsilon_i = x_i - m\)</span>。我们可以使用这组数据构造<strong>似然函数</strong>( <span class="math inline">\(\text{Likelihood function}\)</span>)，如下所示：</p><p><span class="math display">\[\mathcal{L} = \prod_{i=1}^n f_{\epsilon}(\varepsilon_i)\]</span></p><p>由于对数函数是单调递增的，在极大化求解时更方便，所以上式的<strong>对数似然函数</strong>是：</p><p><span class="math display">\[\ell = \sum_{i=1}^{n} \ln f_{\epsilon}(\varepsilon_i)\]</span></p><p>我们上述对数似然函数 <span class="math inline">\(\ell\)</span>取最大值，则需要 <span class="math inline">\(\ell^{\prime} = 0\)</span>，则有：</p><p><span class="math display">\[\ell^{\prime} = \frac{\mathrm{d}\ell}{\mathrm{d} \varepsilon} = 0\]</span></p><p>使用链式法则，可得：</p><p><span class="math display">\[\left[\ln f(x)\right]^{\prime} = \cfrac{f^{\prime}(x)}{f(x)}\]</span></p><p>对对数似然函数求导可得：</p><p><span class="math display">\[\ell^{\prime} = \left[ \sum_{i=1}^n \ln f_{\epsilon}(\varepsilon_i)\right]^{\prime} =\sum_{i=1}^{n}\cfrac{f_{\epsilon}^{\prime}(\varepsilon_i)}{f_{\epsilon}(\varepsilon_i)}\]</span></p><p>为了方便后续计算，令 <span class="math inline">\(g_{\epsilon}(\varepsilon) =\cfrac{f_{\epsilon}^{\prime}(\varepsilon)}{f_{\epsilon}(\varepsilon)}\)</span>，则 <span class="math inline">\(\ell^{\prime}\)</span> 可以重写为：</p><p><span class="math display">\[\begin{aligned}\ell^\prime &amp; = \sum_{i=1}^{n}g_{\epsilon}(\varepsilon_i) \\&amp; = g_{\epsilon}(\varepsilon_1) + g_{\epsilon}(\varepsilon_2) +\cdots + g_{\epsilon}(\varepsilon_{n-1}) + g_{\epsilon}(\varepsilon_n)\\&amp; = g_{\epsilon}(x_1 - m) + g_{\epsilon}(x_2 - m) + \cdots +g_{\epsilon}(x_{n-1} - m) + g_{\epsilon}(x_n - m)  \end{aligned}\]</span></p><p>现在我们求<strong>极大似然估计</strong>( <span class="math inline">\(\text{Maximum Likelihood Estimation}\)</span> )，也就是需要求 <span class="math inline">\(\ell^\prime = 0\)</span>的解。这种情况下，要么我们知道 PDF ，要么知道 <span class="math inline">\(m\)</span> ，这样才可以求解 <span class="math inline">\(\ell^\prime = 0\)</span> 。但是目前我们既不知道PDF 也不知道 <span class="math inline">\(m\)</span>，该如何进行下一步工作呢？</p><p>到这里似乎已经陷入死胡同了，但是高斯假设极大似然估计 <span class="math inline">\(\ell^\prime = 0\)</span>的解就是<strong>算术平均</strong>，也就是说上述公式的解 <span class="math inline">\(m\)</span> 是：</p><p><span class="math display">\[\hat{m} = \cfrac{1}{n}\sum_{i=1}^n x_i\]</span></p><p>这里高斯把整个问题的思考模式倒过来：既然千百年来大家都认为<strong>算术平均</strong>是一个好的估计，那我就认为<strong>极大似然估计</strong>推导出的就应该是算术平均！</p><p>这确实只是一种猜测，并不是严谨的证明。但著名物理学家马赫说：“科学的功能是代替经验。这样，科学一方面必须依然停留在经验的范围之内，另一方面必须加速超越经验”。优秀的科学家往往能够通过敏锐的直觉从海量的可能性中找到正确的方向，再通过实验观测与数学推理进行验证，从而得到其中运行的规律。</p><p>令 <span class="math inline">\(\ell^\prime = 0\)</span>，用测量数据的算数平均值 <span class="math inline">\(\bar{x}\)</span>代入 <span class="math inline">\(m\)</span> ，可得：</p><p><span class="math display">\[g_{\epsilon}(x_1 - \bar{x}) + g_{\epsilon}(x_2 - \bar{x}) + \cdots +g_{\epsilon}(x_{n-1} - \bar{x}) + g_{\epsilon}(x_n - \bar{x}) =0   \tag{3}\]</span></p><p>上述公式显然对于任意 <span class="math inline">\(n\)</span>个测量数据都成立，因此不妨设 <span class="math inline">\(x_1 =m\)</span> ， <span class="math inline">\(x_2 = x_3 = x_4 = \cdots =x_{n-1} = x_n = m - nN\)</span> ，这里 <span class="math inline">\(N\)</span> 是一个常数，因此我们有：</p><p><span class="math display">\[\begin{aligned}\bar{x} &amp; = \cfrac{x_1 + x_2 + \cdots + x_{n-1} + x_n}{n}   \\&amp; = \cfrac{m + (m - nN) + (m - nN) + \cdots + (m - nN)}{n}   \\&amp; = \cfrac{m + (n-1) \cdot (m - nN) }{n}   \\&amp; = m - (n - 1)N\end{aligned}\]</span></p><p>将上述值代入公式 <span class="math inline">\((3)\)</span>中，则有：</p><p><span class="math display">\[\begin{aligned}g_{\epsilon}[m - (m-(n-1)N)] + g_{\epsilon}[(m - nN) - (m-(n-1)N)] +\cdots \\+ g_{\epsilon}[(m - nN) - (m-(n-1)N)] + g_{\epsilon}[(m - nN) -(m-(n-1)N)] = 0\end{aligned}\]</span></p><p>化简可得：</p><p><span class="math display">\[g_{\epsilon}[(n - 1)N] + g_{\epsilon}(-N) + \cdots + g_{\epsilon}(-N) +g_{\epsilon}(-N) =0\]</span></p><p>注意到 <span class="math inline">\(g_{\epsilon}(x_2 - \bar{x}) =g_{\epsilon}(x_3 - \bar{x}) = \cdots = g_{\epsilon}(x_n - \bar{x}) =g_{\epsilon}(-N)\)</span> ，共有 <span class="math inline">\(n-1\)</span> 个，进一步化简可得：</p><p><span class="math display">\[g_{\epsilon}[(n - 1)N] + (n - 1)g_{\epsilon}(-N) = 0     \tag{4}\]</span></p><p>根据假设 1 我们知道 <span class="math inline">\(f_{\epsilon}(\varepsilon) =f_{\epsilon}(-\varepsilon)\)</span> ，则有：</p><p><span class="math display">\[f_{\epsilon}^{\prime}(\varepsilon) =-f_{\epsilon}^{\prime}(-\varepsilon)\]</span></p><p>上式等号左边除以 <span class="math inline">\(f_{\epsilon}(\varepsilon)\)</span> ，等式右边除以<span class="math inline">\(f_{\epsilon}(-\varepsilon)\)</span>，易得：</p><p><span class="math display">\[\cfrac{f_{\epsilon}^{\prime}(\varepsilon)}{f_{\epsilon}(\varepsilon)} =-\cfrac{f_{\epsilon}^{\prime}(-\varepsilon)}{f_{\epsilon}(-\varepsilon)}\]</span></p><p>也就是说 <span class="math inline">\(g_{\epsilon}(\varepsilon) =-g_{\epsilon}(-\varepsilon)\)</span> ，即 <span class="math inline">\(g_{\epsilon}(-N) = -g_{\epsilon}(N)\)</span>，代入公式 <span class="math inline">\((4)\)</span> ，可得：</p><p><span class="math display">\[g_{\epsilon}[(n - 1)N] - (n - 1)g_{\epsilon}(N) = 0\]</span></p><p>上式移项可得：</p><p><span class="math display">\[g_{\epsilon}[(n - 1)N] = (n - 1)g_{\epsilon}(N)\]</span></p><p>上式是一个 <span class="math inline">\(f(k \cdot x) =k \cdotf(x)\)</span>形式的<strong>函数方程</strong>，要满足此函数方程，意味着：</p><p><span class="math display">\[\frac{\Delta f(x)}{\Delta x} = C\]</span></p><p>这里 <span class="math inline">\(C\)</span> 是一个常数。</p><p>故 <span class="math inline">\(g_{\epsilon}\)</span>是一个线性表达式：</p><p><span class="math display">\[g_{\epsilon}(\varepsilon) = k \cdot \varepsilon\]</span></p><p>这里 <span class="math inline">\(k\)</span> 是某个常数。</p><p>因为 <span class="math inline">\(g_{\epsilon}(\varepsilon) =\cfrac{f_{\epsilon}^{\prime}(\varepsilon)}{f_{\epsilon}(\varepsilon)}\)</span>，则有：</p><p><span class="math display">\[\cfrac{f_{\epsilon}^{\prime}(\varepsilon)}{f_{\epsilon}(\varepsilon)} =k \cdot \varepsilon   \tag{5}\]</span></p><p>对上式公式 <span class="math inline">\((5)\)</span> 两边对 <span class="math inline">\(\varepsilon\)</span> 进行积分，可得：</p><p><span class="math display">\[\int\cfrac{f_{\epsilon}^{\prime}(\varepsilon)}{f_{\epsilon}(\varepsilon)}\,\mathrm{d}\varepsilon = \int k \cdot \varepsilon \mathrm{d}\varepsilon\]</span></p><p>可得：</p><p><span class="math display">\[\ln f_{\epsilon}(\varepsilon) = \cfrac{k}{2} \, \varepsilon^2 + c\]</span></p><p>这里 <span class="math inline">\(k, c\)</span>均是常数，根据积分法则，最终我们得到了误差的 PDF 表达式：</p><p><span class="math display">\[f_{\epsilon}(\varepsilon) = e^{\frac{k}{2}\varepsilon^2 + c} = e^c \cdote^{\frac{k}{2}\varepsilon^2} = Ae^{\frac{k}{2}\varepsilon^2}\]</span></p><p>下一步就是求解 <span class="math inline">\(A, k\)</span> 这 2个常数。</p><p>根据假设 2 告诉我们 <span class="math inline">\(\varepsilon\)</span>越小，函数值越大，那么指数部分必然小于 0 。设 <span class="math inline">\(\cfrac{k}{2} = -h^2\)</span> ， <span class="math inline">\(h\)</span>是某个常数，则得到了误差的概率密度函数：</p><p><span class="math display">\[f_{\epsilon}(\varepsilon) = Ae^{-h^2 \varepsilon^2} \tag{6}\]</span></p><p>根据 PDF 满足积分为 1 ，则有：</p><p><span class="math display">\[\int_{-\infty}^{+\infty} f_{\epsilon}(\varepsilon) \mathrm{d}\varepsilon = 1\]</span></p><p>代入公式有：</p><p><span class="math display">\[A \int_{-\infty}^{+\infty} e^{-h^2 \varepsilon^2} \mathrm{d} \varepsilon= 1\]</span></p><p>上式中又出现了高斯积分，我们知道高斯积分结果为：</p><p><span class="math display">\[\int_{-\infty}^{+\infty} e^{-x^2} \mathrm{d}x = \sqrt{\pi}\]</span></p><p>非标准高斯积分结果为：</p><p><span class="math display">\[\int_{-\infty}^{+\infty} e^{-a^2x^2} \mathrm{d}x = \cfrac{\sqrt{\pi}}{a}\]</span></p><p>因此我们最终得到 <span class="math inline">\(A =\cfrac{h}{\sqrt{\pi}}\)</span>，于是我们也就推导出了误差分布曲线，也就是概率密度函数的形式为：</p><p><span class="math display">\[\varphi (\epsilon ) = \cfrac{h}{\sqrt{\pi}}\,e^{-h^2\varepsilon^2}\]</span></p><h1 id="总结">总结</h1><p>高斯通过对观测误差的分析，寻找误差的概率分布密度函数。大胆假设<strong>最大似然估计</strong>的结果是算数平均，而在所有的概率密度函数中，唯一满足这个性质的就是正态分布。</p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://math.stackexchange.com/questions/384893/how-was-the-normal-distribution-derived">StackExchange:How was the normal distribution derived?</a></li><li><a href="https://en.wikipedia.org/wiki/Auguste_Comte">哲学家孔德</a></li><li><a href="https://en.wikipedia.org/wiki/Abraham_de_Moivre">棣莫弗</a></li><li><a href="https://en.wikipedia.org/wiki/Pierre-Simon_Laplace">拉普拉斯</a></li><li><a href="https://www.spaceacademy.net.au/library/notes/bode.htm">博得法则：TheTitius-Bode Formula</a></li><li><a href="https://en.wikipedia.org/wiki/Asteroid_belt">小行星带</a></li><li><a href="https://en.wikipedia.org/wiki/Ceres_(dwarf_planet)">谷神星Ceres</a></li><li><a href="https://en.wikipedia.org/wiki/Giuseppe_Piazzi">天文学家朱塞普·皮亚齐</a></li><li><a href="https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss">高斯Carl Friedrich Gauss</a></li><li><a href="https://en.wikipedia.org/wiki/Gauss%27s_method">高斯计算小行星的方法</a></li><li><a href="https://www.actuaries.digital/2021/03/31/gauss-least-squares-and-the-missing-planet/">Gauss,Least Squares, and the Missing Planet</a></li><li><a href="https://en.wikipedia.org/wiki/Least_squares">最小二乘法</a></li><li><a href="https://zhuanlan.zhihu.com/p/128083562">最小二乘法 (LeastSquares)</a></li><li><a href="https://www.zhihu.com/question/37031188/answer/411760828">最小二乘法的本质是什么？</a></li><li><a href="https://en.wikipedia.org/wiki/Errors_and_residuals">误差</a></li><li><a href="https://en.wikipedia.org/wiki/Probability_density_function">概率密度函数Probability density function</a></li><li><a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation">最大似然估计</a></li><li><a href="https://www.matongxue.com/madocs/447">如何通俗地理解“最大似然估计法”?</a></li><li><a href="https://notarocketscientist.xyz/posts/2023-01-27-how-gauss-derived-the-normal-distribution/">HowDid Gauss Derive The Normal Distribution</a></li><li><a href="https://cosx.org/2013/01/story-of-normal-distribution-1/">靳志辉：正态分布的前世今生(上)</a></li><li><a href="https://cosx.org/2013/01/story-of-normal-distribution-2/">靳志辉：正态分布的前世今生(下)</a></li><li><a href="https://book.douban.com/subject/35193606/">米勒：《普林斯顿概率论读本》</a></li><li><a href="https://book.douban.com/subject/36874373/">杰恩斯：《概率论沉思录》</a></li><li><a href="https://book.douban.com/subject/35172355/">格林伯格：《普林斯顿数学分析读本》</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上一篇文章 &lt;a href=&quot;https://www.longluo.me/blog/2024/04/27/normal-distribution/&quot;&gt;正态分布(Normal
Distribution)公式为什么长这样？&lt;/a&gt;
中，我们使用了&lt;strong&gt;投掷飞镖&lt;/strong&gt;的模型，推导出了正态分布( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Normal Distribution}&#92;)&lt;/span&gt;
)的表达式。这种方法既优雅又直观，所以常被用于科普视频或者文章中。那么这个例子是怎么来的呢？我们知道这个方法是天文学家赫歇尔（
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{John Herschel}&#92;)&lt;/span&gt; ）在 1850
年给出的，难道他在投掷飞镖时想到的吗？&lt;/p&gt;
&lt;p&gt;答案是否定的，原因是因为赫歇尔作为一个天文学家，需要精确的测量天体的位置，而在观测星星时，必须要考虑误差的影响。星星在天球中的位置误差是&lt;strong&gt;二维&lt;/strong&gt;的，考虑到误差大家不太好理解，所以用了投掷飞镖这个更通俗易懂的例子。&lt;/p&gt;
&lt;p&gt;正如法国著名哲学家孔德( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Auguste
Comte}&#92;)&lt;/span&gt; ，1798-1857)所说“To understand a science, it is
necessary to know its history.
”，只有了解这个学科的发展历史，了解这个学科的重要概念是如何建立起来的，才能真正理解这个学科。不同于我们在课本中学习顺序，科学是用来解决实际问题的，科学是由一个个问题所驱动发展的。正如仅次牛顿和爱因斯坦的伟大物理学家麦克斯韦(
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{James Clerk Maxwell}&#92;)&lt;/span&gt; )
曾说过“It is of great advantage to the student of any subject to read
the original memoirs on that subject, for science is always most
completely assimilated when it is in the nascent
state…”，我们学习历史上科学家是如何解决这些问题，用了什么方法，才能获取某个概念的
&lt;strong&gt;insight&lt;/strong&gt; ，建立 &lt;strong&gt;intuition&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;正态分布，又被称为高斯分布（ &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Gaussian Distribution}&#92;)&lt;/span&gt;
），人们可能会以为正态分布是由高斯发现的，但事实并非如此！&lt;/p&gt;
&lt;p&gt;正态分布最早是由法国数学家棣莫弗( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Abraham de Moivre}&#92;)&lt;/span&gt; , 1667-1754)在
1718
年左右发现的。他为了解决朋友提出的一个赌博问题，而去认真研究了二项分布。他发现当实验次数增大时，二项分布(
&lt;span class=&quot;math inline&quot;&gt;&#92;(p=0.5&#92;)&lt;/span&gt;
)趋近于一个看起来呈钟形的曲线，如下图 1
所示。后来著名法国数学家拉普拉斯( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Pierre-Simon Laplace}&#92;)&lt;/span&gt; ,
1749-1827)对此作了更详细的研究，并证明了 &lt;span class=&quot;math inline&quot;&gt;&#92;(p
&#92;ne 0.5&#92;)&lt;/span&gt;
时二项分布的极限也是正态分布。之后人们便将此称为&lt;strong&gt;棣莫弗 -
拉普拉斯中心极限定理&lt;/strong&gt;（ &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Central limit theorem}&#92;)&lt;/span&gt; ）。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/probability/de_moivre_laplace.gif&quot; alt=&quot;图1. 二项分布趋近钟形曲线&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图1. 二项分布趋近钟形曲线&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h1 id=&quot;失踪的谷神星&quot;&gt;失踪的谷神星&lt;/h1&gt;
&lt;p&gt;16 和 17
世纪是天文学发展的黄金时期，这一时期的科学革命彻底改变了人类对宇宙的理解。哥白尼(
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Nicolaus Copernicus}&#92;)&lt;/span&gt;
，1473-1543)的日心说、开普勒( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Johannes
Kepler}&#92;)&lt;/span&gt; ，1571-1630)的行星运动三定律、伽利略( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Galileo Galilei}&#92;)&lt;/span&gt;
，1564-1642)的望远镜观测以及牛顿( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Isaac Newton}&#92;)&lt;/span&gt;
，1643-1727)的万有引力定律共同构成了现代天文学的基础。这一时期的科学家们不仅改变了人类对宇宙的理解，还为后续的科学研究提供了重要的方法和工具。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Normal Distribution" scheme="https://www.longluo.me/tags/Normal-Distribution/"/>
    
    <category term="Gauss" scheme="https://www.longluo.me/tags/Gauss/"/>
    
    <category term="Least Squares" scheme="https://www.longluo.me/tags/Least-Squares/"/>
    
  </entry>
  
  <entry>
    <title>正态分布(Normal Distribution)公式为什么长这样？</title>
    <link href="https://www.longluo.me/blog/2024/04/27/normal-distribution/"/>
    <id>https://www.longluo.me/blog/2024/04/27/normal-distribution/</id>
    <published>2024-04-27T05:16:57.000Z</published>
    <updated>2024-07-14T08:09:02.755Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>相信大家或多或少都听过六西格玛( <span class="math inline">\(\text{6Sigma}\)</span> ) <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 这个词，六西格玛是指生产的产品中，<span class="math inline">\(99.99966\%\)</span>的产品是没有质量问题的，即只有 <span class="math inline">\(3.4ppm\)</span> 的不良率。</p><p>假如一家工厂生产某型号零件，零件的长度要求是 <span class="math inline">\(100mm\)</span> ，允许的标准差是 <span class="math inline">\(0.1mm\)</span> 。根据 <span class="math inline">\(6 \sigma\)</span> 原则，零件规格允许的偏差范围是：<span class="math inline">\(100 \pm  6 \times 0.1 = 100 \pm 0.6\)</span>。</p><p>这意味着，零件长度超过 <span class="math inline">\(100.6mm\)</span>或低于 <span class="math inline">\(99.4mm\)</span>的概率是非常低的，约为 <span class="math inline">\(0.00034\%\)</span>。如果工厂每天生产 100 万个零件，只允许有 <span class="math inline">\(3.4\)</span> 个零件会超出 <span class="math inline">\(6 \sigma\)</span>的范围，几乎可以忽略不计。因此，生产过程是极其稳定和可靠的，达到了六西格玛水平。</p><p>那么 <span class="math inline">\(6 \sigma\)</span> 中 <span class="math inline">\(3.4ppm\)</span> 的不良率来自哪里呢？</p><p>学过中学数学都知道，在<strong>正态分布</strong>( <span class="math inline">\(\text{Normal Distribution}\)</span> ) <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 中， <span class="math inline">\(68.27\%\)</span> 的数据位于平均值的一个标准差内，<span class="math inline">\(95.45\%\)</span> 位于两个标准差内， <span class="math inline">\(99.73\%\)</span> 位于三个标准差内，这也是著名的68-95-99.7 Rule <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ，如下图 1 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/standard_deviation_diagram_micro.svg" alt="图1. 68-95-99.7 Rule"><figcaption aria-hidden="true">图1. 68-95-99.7 Rule</figcaption></figure><h1 id="什么是正态分布">什么是正态分布？</h1><p>数据可以用不同的方式“分布”，比如数据可以向左散布的多一些，也可以向右散布的多一些，或者分布的乱七八糟，如下图2 - 4 所示，</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/normal_distribution_skew_left.gif" alt="图2. 数据偏向左散布"><figcaption aria-hidden="true">图2. 数据偏向左散布</figcaption></figure><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/normal_distribution_skew_right.gif" alt="图3. 数据偏向右散布"><figcaption aria-hidden="true">图3. 数据偏向右散布</figcaption></figure><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/normal_distribution_random.gif" alt="图4. 数据随机分布"><figcaption aria-hidden="true">图4. 数据随机分布</figcaption></figure><p>但数据经常会集中在一个中心值的附近，而不向左或右偏斜，像一个<strong>钟形</strong>，如下图5 所示。</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/empirical_rule_histogram.svg" alt="图5. 数据正态分布"><figcaption aria-hidden="true">图5. 数据正态分布</figcaption></figure><p>正态分布，又称高斯分布（ <span class="math inline">\(\text{GaussianDistribution}\)</span> ），是一种重要的概率分布，数学王子高斯 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>在正态分布的研究和应用上做出了巨大贡献。有很多日常现象都符合这种分布，如人的身高、考试成绩等。正因为它几乎无处不在，所以叫<span class="math inline">\(\text{Normal Distribution}\)</span>。德国曾经发行的一款 10 马克的纸币上就印着高斯和正态分布曲线，如下图 6所示。</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/gauss_10_mark.jpg" alt="图6. 高斯和正态分布曲线"><figcaption aria-hidden="true">图6. 高斯和正态分布曲线</figcaption></figure><span id="more"></span><p>这个曲线的数学公式大家在中学里都早已见过，如下所示：</p><p><span class="math display">\[f(x; \mu ,\sigma ) = {\frac {1}{\sigma {\sqrt {2\pi }}}}\;e^{-{\frac{\left(x - \mu \right)^{2}}{2 \sigma ^{2}}}}    \tag{1} \label{1}\]</span></p><p><span class="math inline">\(\mu\)</span>是正态分布的数学期望值，可解释为位置参数，决定了分布的位置，表示<strong>曲线中心</strong>在哪里；方差<span class="math inline">\(\sigma ^{2}\)</span>为尺度参数，决定了分布的幅度，表示<strong>曲线的扁平情况</strong>。均值<span class="math inline">\(\mu\)</span> 和方差 <span class="math inline">\(\sigma ^{2}\)</span>不同，曲线形状也有所不同，如下图 7 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/normal_distribution_pdf.svg" alt="图7. 不同均值和方差的正态分布曲线"><figcaption aria-hidden="true">图7.不同均值和方差的正态分布曲线</figcaption></figure><p>正态分布的公式看起来非常复杂，里面有 <span class="math inline">\(\pi\)</span> 、 <span class="math inline">\(e\)</span> 、 <span class="math inline">\(\mu\)</span> 、 <span class="math inline">\(\sigma\)</span>，组合起来非常复杂。在学习时，课本介绍正态分布时就直接给出这个公式，却从来不说明这个概率密度函数是怎么推导来的，来龙去脉是什么。最近看了<a href="https://3blue1brown.com/">3Blue1Brown</a> 关于 <a href="https://www.3blue1brown.com/topics/probability">概率论的系列视频</a>，我知道了正态分布曲线公式为什么是这样，我们将在下一章节中推导出这个公式。</p><h1 id="正态分布公式怎么来的">正态分布公式怎么来的？</h1><p>有很多种方法都可以推导出正态分布公式，这里将介绍一种既优雅又直观的推导方式，由天文学家赫歇尔（<span class="math inline">\(\text{John Herschel}\)</span> ） <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> 在 1850 年给出的。<a href="https://3blue1brown.com/">3Blue1Brown</a> 的视频 <a href="https://www.youtube.com/watch?v=cy8r7WSuT1I">Why π is in thenormal distribution (beyond integral tricks)</a>中详细介绍了这种方式。不过视频中有一些不够严谨的地方，下面会先介绍视频中的推导方法，然后再介绍严谨的数学分析法。</p><p>考虑向一个镖盘投掷飞镖，过镖盘中心作 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span>轴。每次投掷飞镖都会受到随机因素而偏离目标，故每次飞镖在镖盘的落点 <span class="math inline">\((x, y)\)</span> 是 <span class="math inline">\(2\)</span> 维随机变量。</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/dartboard_unlabeled.svg" alt="图8. 飞镖镖盘"><figcaption aria-hidden="true">图8. 飞镖镖盘</figcaption></figure><p>假设满足以下 <span class="math inline">\(2\)</span> 个条件：</p><ol type="1"><li>落点的 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span> 轴坐标是相互独立的；</li><li>落点的概率密度函数仅与其到原点的距离有关，即分布在空间上具有旋转对称性。</li></ol><h2 id="blue1brown-herschel-推导方法">3Blue1Brown Herschel 推导方法</h2><p>如下图 9 所示，设箭头所示落点区域 <span class="math inline">\(P\)</span> 的概率密度函数为 <span class="math inline">\(f_2(x, y)\)</span> ， <span class="math inline">\(f_2\)</span> 表示有 <span class="math inline">\(2\)</span> 个输入参数，落点的坐标 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 。</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/normal_herschel_point.jpg" alt="图9. 落点概率密度函数"><figcaption aria-hidden="true">图9. 落点概率密度函数</figcaption></figure><p>由条件 <span class="math inline">\(1\)</span> 我们知道每个落点区域<span class="math inline">\(P\)</span> 的概率密度，可以表示为 <span class="math inline">\(x\)</span> 轴方向上概率密度函数与 <span class="math inline">\(y\)</span>轴方向上概率密度函数的<strong>乘积</strong>，每个方向上的概率密度函数只有对应方向上一个参数。</p><p>设 <span class="math inline">\(x\)</span> 轴方向上概率密度函数为<span class="math inline">\(g(x)\)</span> ， <span class="math inline">\(y\)</span> 轴方向上概率密度函数为 <span class="math inline">\(h(y)\)</span> ，则有以下公式：</p><p><span class="math display">\[f_2(x, y) = g(x) h(y)      \tag{2} \label{2}\]</span></p><p>又因为条件 <span class="math inline">\(2\)</span>我们知道可以通过旋转对称性，可知 <span class="math inline">\(x\)</span>轴和 <span class="math inline">\(y\)</span>轴方向上概率密度函数相同，所以 <span class="math inline">\(g(y) =h(y)\)</span> 。同时落点 <span class="math inline">\(P\)</span>距离原点的距离为 <span class="math inline">\(r = \sqrt{x^2 +y^2}\)</span> ，如下图 10 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/normal_herschel_distance_r.jpg" alt="图10. 落点概率密度函数只与半径有关"><figcaption aria-hidden="true">图10.落点概率密度函数只与半径有关</figcaption></figure><p>则 <span class="math inline">\(f_2(x, y)\)</span>概率密度函数表示为半径（距原点的距离）的单变量函数 <span class="math inline">\(f(r)\)</span> ，则有：</p><p><span class="math display">\[f_2(x, y) = f(r) = f(\sqrt {x^2 + y^2})            \tag{3} \label{3}\]</span></p><p>综合 <span class="math inline">\(\eqref{2}\)</span> 和 <span class="math inline">\(\eqref{3}\)</span> 可得：</p><p><span class="math display">\[f(\sqrt {x^2 + y^2}) = g(x) g(y)            \tag{4} \label{4}\]</span></p><p>假设 <span class="math inline">\(x\)</span> 轴上距离原点距离为 <span class="math inline">\(r\)</span> 的点 <span class="math inline">\(P\)</span> ，坐标为 <span class="math inline">\((r, 0)\)</span> ，如下图 11 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/normal_herschel_f_gr.jpg" alt="图11. 落点在 x 轴 (r, 0) 处"><figcaption aria-hidden="true">图11. 落点在 <span class="math inline">\(x\)</span> 轴 <span class="math inline">\((r,0)\)</span> 处</figcaption></figure><p>点 <span class="math inline">\(P(r, 0)\)</span>处的概率密度函数可以写成：</p><p><span class="math display">\[f_2(r, 0) = f(r) = g(r) g(0)             \tag{5} \label{5}\]</span></p><p>从上式 <span class="math inline">\(\eqref{5}\)</span> 可知 的 <span class="math inline">\(f(r)\)</span> 等于 <span class="math inline">\(g(r)\)</span> 乘以<strong>某个常数</strong> <span class="math inline">\(g(0)\)</span> ，所以 <span class="math inline">\(f(r) = C g(r)\)</span> ，其中 <span class="math inline">\(C\)</span> 为某个常数。</p><p>由于最终都需要进行归一化，这里不妨设 <span class="math inline">\(C =1\)</span> ，则公式 <span class="math inline">\(\eqref{4}\)</span>可以写成：</p><p><span class="math display">\[f(\sqrt {x^2 + y^2}) = f(x) f(y)             \tag{6} \label{6}\]</span></p><p>至此我们得到了<strong>最重要</strong>的关系式，问题转变为如何求解函数<span class="math inline">\(f\)</span> 。公式 <span class="math inline">\(\eqref{6}\)</span> 是一个函数方程 <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>，熟悉函数方程的同学可能一眼就知道满足公式 <span class="math inline">\(\eqref{6}\)</span>的函数解是<strong>指数函数</strong> <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> 。</p><p><span class="math display">\[f({r}) = e^{-{r}^2}               \tag{7} \label{7}\]</span></p><p>如果我们不知道这个函数方程的解怎么办呢？下面我们就来求解下。</p><p>设函数 <span class="math inline">\(h(x) = f(\sqrt {x})\)</span>，则有 <span class="math inline">\(h(x^2) = f(x)\)</span> ，那么公式<span class="math inline">\(\eqref{6}\)</span> 可以写成：</p><p><span class="math display">\[h(x^2 + y^2) = h(x^2) h(y^2)                  \tag{8} \label{8}\]</span></p><p>从公式 <span class="math inline">\(\eqref{8}\)</span> 我们知道任取<span class="math inline">\(2\)</span>个<strong>正整数</strong>，先相加再代入函数 <span class="math inline">\(h\)</span> ，结果等于先分别代入函数 <span class="math inline">\(h\)</span> 再相乘。这意味着，函数 <span class="math inline">\(h\)</span>把<strong>加法</strong>变成了<strong>乘法</strong>。</p><p>实际上到了这里，还记得中学时学过的<strong>指数函数</strong>吗？</p><p>对于以某个常数 <span class="math inline">\(c\)</span>为基数的指数函数 <span class="math inline">\(h(x) = c^x\)</span>，可以将加法变成乘法。</p><p>但这个只是我们的猜测，我们还需要<strong>严谨的证明</strong>我们的猜测。</p><p>如果这个性质适用于任意 <span class="math inline">\(2\)</span>个正整数，那么很容易扩展至任意 <span class="math inline">\(n\)</span>个正整数：</p><p><span class="math display">\[h(x_1 + x_2 + \cdots + x_n) = h(x_1)h(x_2) \cdotsh(x_n)                  \tag{9} \label{9}\]</span></p><p>不妨代入 <span class="math inline">\(x = 5\)</span> ，则有：</p><p><span class="math display">\[\begin{aligned}h(5) &amp; = h(1 + 1 + 1 + 1 + 1) \\&amp; = h(1)h(1)h(1)h(1)h(1) \\&amp; = h(1)^5\end{aligned}\]</span></p><p>这里 <span class="math inline">\(x\)</span> 可以为任意整数 <span class="math inline">\(n\)</span> ，则有：</p><p><span class="math display">\[h(n) = h(1 + \cdots + 1) = h(1) \cdots h(1) =h(1)^n                    \tag{10} \label{10}\]</span></p><p>由公式 <span class="math inline">\(\eqref{6}\)</span>，我们知道：</p><p><span class="math display">\[f(0) = f(0)f(0)\]</span></p><p>因为 <span class="math inline">\(f(0) \ne 0\)</span> ，因此 <span class="math inline">\(f(0) = 1\)</span> ，那么有：</p><p><span class="math display">\[h(0) = h(0)h(0) = h(0)^2\]</span></p><p>对于 <span class="math inline">\(p \in \mathbb{Z}^+\)</span>，有：</p><p><span class="math display">\[1 = h(0) = h(p - p) = h(p)h(-p) = h(1)^p h(-p)\]</span></p><p>易得对于任意<strong>负整数</strong> <span class="math inline">\(-p\)</span> ，有：</p><p><span class="math display">\[h(-p) = h(p)^{-1} = h(1)^{-p}\]</span></p><p>这样我们就将函数 <span class="math inline">\(h\)</span> 推广至整数域<span class="math inline">\(\mathbb{Z}\)</span> 。</p><p>同理，对于任意正整数 <span class="math inline">\(q \in\mathbb{Z}^+\)</span> ，可以得到以下表达式</p><p><span class="math display">\[h(q) = \prod_{k=1}^q h(1) = h(1)^q\]</span></p><p>对公式适当变形，可得：</p><p><span class="math display">\[h(1) = h(\frac {q}{q}) = h(\frac {1}{q})^q\]</span></p><p>可以得到：</p><p><span class="math display">\[h(\frac {1}{q}) = h(1)^{\frac{1}{q}}\]</span></p><p>综合上述可得，对于任意<strong>有理数</strong> <span class="math inline">\(\dfrac{p}{q} \in \mathbb{Q}\)</span>，都满足：</p><p><span class="math display">\[h(\frac{p}{q}) = h(1)^\frac{p}{q}\]</span></p><p>同时由于概率密度函数<strong>连续</strong>，那么对于无理数也成立。则根据上述推导我们知道公式<span class="math inline">\(\eqref{10}\)</span> 在实数域 <span class="math inline">\(\mathbb{R}\)</span> 都成立。</p><p>不妨令 <span class="math inline">\(a = h(1)\)</span>，则我们得到了最终表达式：</p><p><span class="math display">\[h(x) = a^x                    \tag{11} \label{11}\]</span></p><p>为了方便和统一，任意指数函数都可以写成以 <span class="math inline">\(e\)</span> 为底的指数函数：</p><p><span class="math display">\[h(x) = e^{\ln a x} = e^{c x}                    \tag{12} \label{12}\]</span></p><p>至此我们就求出了满足函数方程 <span class="math inline">\(\eqref{6}\)</span> 函数 <span class="math inline">\(f\)</span> 为：</p><p><span class="math display">\[f(x) = e^{cx^2}                                 \tag{13} \label{13}\]</span></p><p>那么常数 <span class="math inline">\(c\)</span>是多少呢？根据概率论我们知道：</p><p><span class="math display">\[\int f(x) \mathrm{d}x = \int e^{cx^2} \mathrm{d}x =1                                 \tag{14} \label{14}\]</span></p><p>上式就是大名鼎鼎的高斯积分（ <span class="math inline">\(\text{Gaussian Integral}\)</span> ） <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>，如何求解高斯积分网上有很多教程，这里不再赘述。</p><p>最终我们得出了 <span class="math inline">\(2\)</span>维情况下的未归一化的概率密度函数：</p><p><span class="math display">\[f_2(x, y) = f_1(x)f_1(y) = e^{-x^2} e^{-y^2} = e^{-(x^2 +y^2)}                                  \tag{15} \label{15}\]</span></p><h2 id="更严谨的数学分析法">更严谨的数学分析法</h2><p>上一节我们使用了不那么严谨的方法得到了正态分布的概率密度函数，下面我们使用另外一种方法求出正态分布的概率密度函数。</p><p>由落点分布分布在空间上具有旋转对称性，我们可知 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span>轴具有<strong>相同且连续</strong>的概率密度函数。</p><p>设落点 <span class="math inline">\(P\)</span> 的概率密度函数为 <span class="math inline">\(\rho (x, y)\)</span> ， <span class="math inline">\(x\)</span> 轴方向上概率密度函数为 <span class="math inline">\(f(x)\)</span> ，则 <span class="math inline">\(y\)</span> 轴方向上的概率密度函数为 <span class="math inline">\(f(y)\)</span> ，那么考虑如下图 12所示的一个<strong>充分小</strong>的<strong>黄色区域</strong> <span class="math inline">\(\Box ABCD\)</span> ：</p><figure><img src="https://www.longluo.me/assets/blog/images/normal_distribution/normal_distribution_proof.png" alt="图12. 落点概率密度函数"><figcaption aria-hidden="true">图12. 落点概率密度函数</figcaption></figure><p>飞镖落在黄色区域 <span class="math inline">\(\Box ABCD\)</span>的概率为：</p><p><span class="math display">\[\rho (x, y) \mathrm{d}x \mathrm{d}y = f(x) \mathrm{d}x \cdot f(y)\mathrm{d}y                    \tag{16} \label{16}\]</span></p><p>将等式左边转换为极坐标形式，</p><p><span class="math display">\[\begin{cases}x = r \cos \theta  \\y = r \sin \theta\end{cases}\]</span></p><p>在极坐标下的概率密度函数设为 <span class="math inline">\(g(r, \theta)\)</span> , 则有：</p><p><span class="math display">\[\rho (x, y) = \rho (r \cos \theta , r \sin \theta) = g(r, \theta)                    \]</span></p><p>由条件 <span class="math inline">\(2\)</span> , <span class="math inline">\(g(r, \theta )\)</span> 具有旋转对称性，也就是和<span class="math inline">\(\theta\)</span> 无关，所以</p><p><span class="math display">\[\frac{\mathrm{d} g(r, \theta)}{\mathrm{d} \theta} =0                     \]</span></p><p>对公式 <span class="math inline">\(\eqref{16}\)</span> 两边对 <span class="math inline">\(\theta\)</span> 求导，可得：</p><p><span class="math display">\[\frac{\mathrm{d} f(x)}{\mathrm{d} \theta } f(y) + f(x) \frac{\mathrm{d}f(y)}{\mathrm{d} \theta } = 0                    \]</span></p><p>利用链式法则，有：</p><p><span class="math display">\[-r \sin \theta f'(x)f(y) + f(x) f'(y) r \cos \theta =0                          \]</span></p><p>上式移项可得：</p><p><span class="math display">\[\frac{f'(x)}{f(x) x} = \frac{f'(y)}{f(y) y} =C                          \]</span></p><p>我们则有：</p><p><span class="math display">\[\frac{f'(x)}{f(x)} = C x                          \]</span></p><p>对上式进行积分，可得：</p><p><span class="math display">\[\int \frac{f'(x)}{f(x)} \mathrm{d}x = \int C x\mathrm{d}x                           \]</span></p><p>求解上式可得：</p><p><span class="math display">\[\ln f(x) = \frac{C}{2}x^2 + C'                           \]</span></p><p>则求得函数 <span class="math inline">\(f(x)\)</span> 为：</p><p><span class="math display">\[f(x) = A e^{\frac{1}{2}Cx^2}                           \tag{17}\label{17}\]</span></p><p>同理 <span class="math inline">\(f(y)\)</span> 为：</p><p><span class="math display">\[f(y) = A e^{\frac{1}{2}Cy^2}                           \tag{18}\label{18}\]</span></p><p>由概率论我们知道 <span class="math inline">\(C &lt; 0\)</span> ，同时<span class="math inline">\(\int_{0}^{\infty }  f(x) \mathrm{d}x =\frac{1}{2}\)</span> ，则：</p><p><span class="math display">\[\int_{0}^{\infty }  e^{\frac{C}{2} x^2} \mathrm{d}x =\frac{1}{2A}                        \]</span></p><p>考虑 <span class="math inline">\(2\)</span>维正态分布，并使用极坐标，则有：</p><p><span class="math display">\[\begin{aligned}\int_{0}^{\infty} \int_{0}^{\infty} e^{\frac{C}{2}(x^2 + y^2)}\mathrm{d}x \mathrm{d}y  &amp; = \int_{0}^{\infty} \int_{0}^{\infty}e^{\frac{C}{2}r^2} r \mathrm{d}r \mathrm{d}\theta \\&amp; = \int_{0}^{\frac{\pi }{2}} \int_{0}^{\infty} e^{\frac{C}{2}r^2} r\mathrm{d}r \mathrm{d}\theta  \\&amp; = \frac{1}{4A^2}\end{aligned}\]</span></p><p>令 <span class="math inline">\(u = r^2\)</span> ，则有：</p><p><span class="math display">\[\int_{0}^{\infty} e^{\frac{C}{2}r^2} r \mathrm{d}r = \int_{0}^{\infty}e^{\frac{C}{2}u} \frac{\mathrm{d}u}{2} = \frac{1}{2} \left [ \frac{2}{C}e^{\frac{C}{2} u} \right ]_{0}^{\infty } =-\frac{1}{C}                        \]</span></p><p>可得：</p><p><span class="math display">\[-\frac{1}{C} \int_{0}^{\frac{\pi }{2}} \mathrm{d}\theta = -\frac{1}{C}\frac{\pi}{2} = \frac{1}{4A^2}                           \]</span></p><p>所以可求得：</p><p><span class="math display">\[A = \sqrt{\frac {-C}{2 \pi}}                          \]</span></p><p>至此，我们只剩下一个<strong>未知参数</strong> <span class="math inline">\(C\)</span> 就得到所求公式 <span class="math inline">\(\eqref{17}\)</span> 。</p><p>考虑方差 <span class="math inline">\(\sigma^2\)</span> 定义，对于期望<span class="math inline">\(\mu = 0\)</span> ，则有：</p><p><span class="math display">\[\sigma ^2 = \int_{-\infty }^{\infty }x^2 f(x) \mathrm{d}x = 2\sqrt{\frac {-C}{2 \pi}} \int_{0}^{\infty }x^2 e^{\frac{C}{2} x^2}\mathrm{d}x                                                               \tag{19}\label{19}\]</span></p><p>令 <span class="math inline">\(u = x\)</span> ， <span class="math inline">\(v = \frac{1}{C} e^{\frac{C}{2} x^2}\)</span>，则有：</p><p><span class="math display">\[\mathrm{d}v = x e^{\frac{C}{2} x^2}\]</span></p><p>根据分部积分公式：</p><p><span class="math display">\[\int u \frac{\mathrm{d}v}{\mathrm{d}x}\,\mathrm{d}x = uv - \int\frac{\mathrm{d}u}{\mathrm{d}x}v\,\mathrm{d}x\]</span></p><p>则对公式 <span class="math inline">\(\eqref{19}\)</span>进行分部积分求解可得：</p><p><span class="math display">\[\begin{aligned}\int_{0}^{\infty } u \frac{\mathrm{d}v}{\mathrm{d}x}\,\mathrm{d}x &amp;= \lim_{x \to \infty} \frac{x}{C} e^{\frac{C}{2} x^2} - \frac{0}{C}e^{\frac{C}{2} 0} - \frac{1}{C} \int_{0}^{\infty } e^{\frac{C}{2} x^2}\mathrm{d}x \\&amp; = 0 - 0 - \frac{1}{C} \frac{\sqrt {2 \pi }}{2 \sqrt {-C}} \\&amp; = - \frac{1}{C} \frac{\sqrt {2 \pi }}{2 \sqrt {-C}}\end{aligned}  \]</span></p><p>所以我们求得 <span class="math inline">\(\sigma^2\)</span> 为：</p><p><span class="math display">\[\sigma^2 = 2 \sqrt{\frac {-C}{2 \pi}} \frac{-1}{C} \frac{\sqrt {2 \pi}}{2 \sqrt {-C}} = -\frac{1}{C}  \]</span></p><p>即：</p><p><span class="math display">\[C = -\frac{1}{\sigma^2}  \]</span></p><p>将求得 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(C\)</span> 代入公式 <span class="math inline">\(\eqref{17}\)</span>，最终我们求得概率密度函数为：</p><p><span class="math display">\[f(x) = {\frac {1}{\sigma {\sqrt {2\pi }}}}\;e^{-{\frac {x^{2}}{2\sigma^{2}}}}                                                      \tag{20}\label{20}\]</span></p><p>公式 <span class="math inline">\(\eqref{20}\)</span> 是期望 <span class="math inline">\(\mu = 0\)</span> 的特殊情况，当期望 <span class="math inline">\(\mu \ne 0\)</span> 时，更一般的公式为：</p><p><span class="math display">\[f(x) = {\frac {1}{\sigma {\sqrt {2\pi }}}}\;e^{-{\frac {\left(x-\mu\right)^{2}}{2\sigma^{2}}}}                                                    \tag{21}\label{21}\]</span></p><p>特别地，当 <span class="math inline">\(\mu = 0\)</span> 且 <span class="math inline">\(\sigma = 1\)</span>，这个分布被称为<strong>标准正态分布</strong>：</p><p><span class="math display">\[f(x)={\frac {1}{\sqrt {2\pi }}}\, e^{-{\frac{x^{2}}{2}}}                                                 \tag{22}\label{22}\]</span></p><h1 id="正态分布公式的几何意义">正态分布公式的几何意义</h1><p>通过 <span class="math inline">\(\text{Herschel}\)</span>给出的优雅直观方法，仅仅依靠那 <span class="math inline">\(2\)</span>个假设条件，我们居然最终求出了正态分布的公式。有没有感觉到数学的美感？</p><p>最初看到 3Blue1Brown的这个视频，感觉非常美，正态分布那么复杂的公式居然有这么优雅直观的方式自然而然的出来了！</p><p>分析正态分布公式，公式中的 <span class="math inline">\(\pi\)</span>意味着<strong>空间上的对称性</strong>，即点分布距离中心是对称的。而<span class="math inline">\(e\)</span>的出现意味着取了<strong>时间上的极限</strong>，而这和中心极限定理（<span class="math inline">\(\text{Central limit theorem}\)</span> ） <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>有关，我会在下一篇文章详细解释，敬请期待！</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Six_Sigma">六西格玛</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://en.wikipedia.org/wiki/Normal_distribution">正态分布 Normaldistribution</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule">68-95-99.7法则</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss">高斯Gauss</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/John_Herschel">天文学家赫歇尔 JohnHerschel</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://en.wikipedia.org/wiki/Functional_equation">函数方程</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://en.wikipedia.org/wiki/Exponential_function">指数函数Exponential function</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p><a href="https://en.wikipedia.org/wiki/Gaussian_integral">高斯积分 Gaussianintegral</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn9"><p><a href="https://en.wikipedia.org/wiki/Central_limit_theorem">中心极限定理Central limit theorem</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相信大家或多或少都听过六西格玛( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{6
Sigma}&#92;)&lt;/span&gt; ) &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 这个词，六西格玛是指生产的产品中，
&lt;span class=&quot;math inline&quot;&gt;&#92;(99.99966&#92;%&#92;)&lt;/span&gt;
的产品是没有质量问题的，即只有 &lt;span class=&quot;math inline&quot;&gt;&#92;(3.4ppm&#92;)&lt;/span&gt; 的不良率。&lt;/p&gt;
&lt;p&gt;假如一家工厂生产某型号零件，零件的长度要求是 &lt;span class=&quot;math inline&quot;&gt;&#92;(100mm&#92;)&lt;/span&gt; ，允许的标准差是 &lt;span class=&quot;math inline&quot;&gt;&#92;(0.1mm&#92;)&lt;/span&gt; 。根据 &lt;span class=&quot;math inline&quot;&gt;&#92;(6 &#92;sigma&#92;)&lt;/span&gt; 原则，零件规格允许的偏差范围是：
&lt;span class=&quot;math inline&quot;&gt;&#92;(100 &#92;pm  6 &#92;times 0.1 = 100 &#92;pm 0.6&#92;)&lt;/span&gt;
。&lt;/p&gt;
&lt;p&gt;这意味着，零件长度超过 &lt;span class=&quot;math inline&quot;&gt;&#92;(100.6mm&#92;)&lt;/span&gt;
或低于 &lt;span class=&quot;math inline&quot;&gt;&#92;(99.4mm&#92;)&lt;/span&gt;
的概率是非常低的，约为 &lt;span class=&quot;math inline&quot;&gt;&#92;(0.00034&#92;%&#92;)&lt;/span&gt;
。如果工厂每天生产 100 万个零件，只允许有 &lt;span class=&quot;math inline&quot;&gt;&#92;(3.4&#92;)&lt;/span&gt; 个零件会超出 &lt;span class=&quot;math inline&quot;&gt;&#92;(6 &#92;sigma&#92;)&lt;/span&gt;
的范围，几乎可以忽略不计。因此，生产过程是极其稳定和可靠的，达到了六西格玛水平。&lt;/p&gt;
&lt;p&gt;那么 &lt;span class=&quot;math inline&quot;&gt;&#92;(6 &#92;sigma&#92;)&lt;/span&gt; 中 &lt;span class=&quot;math inline&quot;&gt;&#92;(3.4ppm&#92;)&lt;/span&gt; 的不良率来自哪里呢？&lt;/p&gt;
&lt;p&gt;学过中学数学都知道，在&lt;strong&gt;正态分布&lt;/strong&gt;( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Normal Distribution}&#92;)&lt;/span&gt; ) &lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; 中， &lt;span class=&quot;math inline&quot;&gt;&#92;(68.27&#92;%&#92;)&lt;/span&gt; 的数据位于平均值的一个标准差内，
&lt;span class=&quot;math inline&quot;&gt;&#92;(95.45&#92;%&#92;)&lt;/span&gt; 位于两个标准差内， &lt;span class=&quot;math inline&quot;&gt;&#92;(99.73&#92;%&#92;)&lt;/span&gt; 位于三个标准差内，这也是著名的
68-95-99.7 Rule &lt;a href=&quot;#fn3&quot; class=&quot;footnote-ref&quot; id=&quot;fnref3&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; ，如下图 1 所示：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/normal_distribution/standard_deviation_diagram_micro.svg&quot; alt=&quot;图1. 68-95-99.7 Rule&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图1. 68-95-99.7 Rule&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h1 id=&quot;什么是正态分布&quot;&gt;什么是正态分布？&lt;/h1&gt;
&lt;p&gt;数据可以用不同的方式“分布”，比如数据可以向左散布的多一些，也可以向右散布的多一些，或者分布的乱七八糟，如下图
2 - 4 所示，&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/normal_distribution/normal_distribution_skew_left.gif&quot; alt=&quot;图2. 数据偏向左散布&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图2. 数据偏向左散布&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/normal_distribution/normal_distribution_skew_right.gif&quot; alt=&quot;图3. 数据偏向右散布&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图3. 数据偏向右散布&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/normal_distribution/normal_distribution_random.gif&quot; alt=&quot;图4. 数据随机分布&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图4. 数据随机分布&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;但数据经常会集中在一个中心值的附近，而不向左或右偏斜，像一个&lt;strong&gt;钟形&lt;/strong&gt;，如下图
5 所示。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/normal_distribution/empirical_rule_histogram.svg&quot; alt=&quot;图5. 数据正态分布&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图5. 数据正态分布&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;正态分布，又称高斯分布（ &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Gaussian
Distribution}&#92;)&lt;/span&gt; ），是一种重要的概率分布，数学王子高斯 &lt;a href=&quot;#fn4&quot; class=&quot;footnote-ref&quot; id=&quot;fnref4&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;
在正态分布的研究和应用上做出了巨大贡献。有很多日常现象都符合这种分布，如人的身高、考试成绩等。正因为它几乎无处不在，所以叫
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Normal Distribution}&#92;)&lt;/span&gt;
。德国曾经发行的一款 10 马克的纸币上就印着高斯和正态分布曲线，如下图 6
所示。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/normal_distribution/gauss_10_mark.jpg&quot; alt=&quot;图6. 高斯和正态分布曲线&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图6. 高斯和正态分布曲线&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Probability" scheme="https://www.longluo.me/tags/Probability/"/>
    
    <category term="Normal Distribution" scheme="https://www.longluo.me/tags/Normal-Distribution/"/>
    
    <category term="Gauss" scheme="https://www.longluo.me/tags/Gauss/"/>
    
  </entry>
  
  <entry>
    <title>高速公路编号背后的数学密码</title>
    <link href="https://www.longluo.me/blog/2024/04/21/decode-the-highway-system-numbers/"/>
    <id>https://www.longluo.me/blog/2024/04/21/decode-the-highway-system-numbers/</id>
    <published>2024-04-21T00:08:32.000Z</published>
    <updated>2024-06-05T11:42:12.635Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>世界那么大，我想去看看！随着科技的发展，我们早已做到无需离开家就能领略世界各地的风景和文化。通过高清视频、高清直播、社交媒体、VR技术、各种图片或者视频分享平台，我们不仅可以体验世界名胜古迹、自然美景和各地的风土人情，还能与当地居民互动，了解他们的日常生活和传统文化。互联网丰富了人们的生活，缩小了地域的界限，真正实现了让世界触手可及，足不出户便可周游世界的梦想。但正所谓“百闻不如一见”，“读万卷书，不如行万里路！”，尽管互联网让我们可以虚拟游览世界，但亲自出行的体验无可替代。自由行不仅提供了前所未有的自由和灵活性，还能让我们亲身感受到大自然的美妙、城市的活力。这种身临其境的体验，远非屏幕前的感受可比。</p><p>当你打开地图软件时，你会看到如图 1 所示的道路标志，</p><figure><img src="https://www.longluo.me/assets/blog/images/road/highway_mark.png" alt="图1. 道路编号"><figcaption aria-hidden="true">图1. 道路编号</figcaption></figure><p>当你在道路出行时，你也会看到看到如下图 2所示的路牌，但你可能并未真正留意过这些标志。因为现在我们只需要有一部联网的智能手机，在地图类软件里，设定出发地和目的地，自然有导航会指引我们到达目的地。</p><figure><img src="https://www.longluo.me/assets/blog/images/road/china_expwy_g35_sign_with_name_in_luogang_tollgate.jpg" alt="图2. G35 高速萝岗路段"><figcaption aria-hidden="true">图2. G35 高速萝岗路段</figcaption></figure><p>这些编号肯定不是随机的，那么这些道路编号到底有什么用呢？出于好奇心你可能会去寻找答案，你很容易轻松找到中国国家高速的编号密码 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 和 高速公路是怎样命名和编号 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>这样的文章。但这些文章只是告诉我们是什么，并没有告诉我们为什么。</p><p>国内现行的高速公路命名是由交通部从 2005 年启动的 <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>，之前道路都以起始地和终点地命名。你可能会想，之前那种命名方式不是更合理吗？用了数字不是更加不清晰易懂吗？如果图1 不是路牌上写了济广高速，谁知道 G35 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> 是哪里到哪里呢？</p><p>如果你更进一步的话，如果你去了解世界其他国家的高速公路命名的话，你会惊讶的地发现为什么居然全世界各主要大国都选择了类似的编号系统，这背后的原因是什么呢？</p><p>要回答这个问题，我们需要把时钟拨回几十年前，回到高速公路诞生的时期，那个没有GPS，没有手机，只有纸质地图的时代，我们才能知道这种编号系统的<strong>重要意义</strong>和<strong>实用性</strong>，以及背后的<strong>数学密码</strong>。</p><h1 id="世界各国如何对高速公路进行编号">世界各国如何对高速公路进行编号？</h1><p>我们已经了解了国内高速公路编号 <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>，让我们看看其他国家的高速公路系统编号是什么样的。这些国家需要国土面积足够大，高速公路系统足够发达，国土疆域长宽比例没有太夸张，人口分布比较均匀。</p><span id="more"></span><h2 id="德国-germany">德国 （Germany）</h2><p>首先我们把目光投向德国 <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>，因为世界上第一条被广泛认可的现代意义上的高速公路就是德国的“Autobahn”<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> ，于 1932年建成，连接科隆与波恩，完全是为高速行驶的机动车辆设计和建造的。</p><p>在纳粹上台之后，高速公路建设被视为国家的重要工程，是当时德国最具标志性的基础设施项目之一，以展示德国的工程实力和国家威严<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>。高速公路建提高了交通运输效率和便利性，同时也为了支持军事行动和纳粹的宣传活动。这些公路被设计成宽敞平坦、直线且无障碍的道路，可以实现高速行驶。</p><p>这些高速公路被称为“Autobahn”，德语的意思就是“<strong>汽车道</strong>”，命名方式则采用了简单的字母和数字组合，例如<span class="math inline">\(A1, A2, \cdots , A9\)</span> 等 <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>。这种命名方式简洁明了，便于驾驶员识别和导航。</p><p>德国现在高速公路 (Bundesautobahn，BAB) 的编号系统是在 1974年开始使用的，所有的高速公路都以 <span class="math inline">\(A\)</span>开头后接一个空白与数字编号，如 <span class="math inline">\(A8\)</span>。穿越德国全国的<strong>东西向</strong>主要高速公路以<strong>偶数</strong>编号，<strong>南北向</strong>的道路则以<strong>单数</strong>编号。用来连接区域性重点城市的较短高速公路则以两位数字来编号，具体如下图3 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/deutschland_autobahnen_nummerierung.svg" alt="图3. 德国高速公路"><figcaption aria-hidden="true">图3. 德国高速公路</figcaption></figure><ul><li><span class="math inline">\(A1 - A9\)</span> :主要南北向高速公路，数字越小越西。</li><li><span class="math inline">\(A10 - A99\)</span> :主要东西向高速公路，数字越小越北。</li><li><span class="math inline">\(A100 - A999\)</span> :环路、支线和次要高速公路。两位数和三位数的编号通常用于城市环线和连接支线。</li></ul><p>当然德国也接入了欧盟标准的“E”编号系统与其他欧洲国家的公路系统协调，如下图 4 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/european_highways_de.png" alt="图4. 德国高速公路"><figcaption aria-hidden="true">图4. 德国高速公路</figcaption></figure><h2 id="法国-france">法国 （France）</h2><p>法国的高速公路系统 <a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>被称为“Autoroute”，通常以字母“A”开头，后跟一个数字。编号体系如下：</p><ul><li><span class="math inline">\(A1 - A16\)</span>沿着首都巴黎的放射性高速公路；</li><li><span class="math inline">\(A100 - A999\)</span> :区域性或次要高速公路。</li></ul><p>由于巴黎长期是法国的中心 <a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>，所以法国的高速系统沿巴黎放射性分布，如下图 5所示。当然法国是欧洲国家，所以也使用了欧盟标准的“E”编号系统与其他欧洲国家的公路系统协调。</p><figure><img src="https://www.longluo.me/assets/blog/images/road/france_autoroutes_map.png" alt="图5. 法国高速公路"><figcaption aria-hidden="true">图5. 法国高速公路</figcaption></figure><h2 id="俄罗斯-russia">俄罗斯 （Russia）</h2><p>俄罗斯的高速公路系统 <a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> 被称为 Avtomagistral，俄语里就是高速公路的意思，编号使用字母“M”、“A”或“P”开头，后跟数字：</p><ul><li><span class="math inline">\(M\)</span> 系列:连接首都莫斯科与其他重要城市和边界。</li><li><span class="math inline">\(A\)</span> 系列:连接各主要城市，通常为区域性主干道。</li><li><span class="math inline">\(P\)</span> 系列:其他重要的区域性公路。</li></ul><p>俄罗斯和法国类似，精华都在莫斯科圣彼得堡的东欧平原区，西伯利亚和远东地区人口稀少，高速分布如下图6 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/russian_federal_highways.png" alt="图6. 俄罗斯高速公路"><figcaption aria-hidden="true">图6. 俄罗斯高速公路</figcaption></figure><h2 id="欧洲-europe">欧洲 （Europe）</h2><p>欧洲的高速公路系统 <a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>使用“E”字母（Europe）作为前缀，后接一个数字，代表着欧洲主要道路网。</p><p>欧洲路线编号的决定是由 1975 年的欧洲经济委员会作出的，并在 1992年进行了修正。作为干线的A级道路编号是<strong>两位数</strong>，而作为地方线的B 级的道路编号则是三位数，主要规则如下所示：</p><ul><li>南北方向的道路按两位数编号，从西向东依次递增，以 <span class="math inline">\(5\)</span> 结尾。</li><li>东西方向的道路按两位数编号，从北向南依次递增，以 <span class="math inline">\(0\)</span> 结尾。</li></ul><p>当然还有其他一些规则，欧洲高速公路分布如下图 7 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/international_e_road_network_green.png" alt="图7. 欧洲 E 高速公路系统"><figcaption aria-hidden="true">图7. 欧洲 E 高速公路系统</figcaption></figure><p>由于加拿大 <a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> 和 巴西 <a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>人口分布不均匀，没有什么借鉴价值。当然有同学看到这会问，欧洲高速公路系统和国内编号规则几乎一致，那么国内是借鉴了欧洲的公路编号系统吗？</p><p>其实世界各大国的高速公路编号体系在设计上几乎一致，这种统一编码方案可以追溯到美国的州际高速公路<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>系统，这个我们会在下面的章节里进行详细讲解。</p><p>我们可以先问下自己几个问题：</p><ol type="1"><li>欧洲这种编号规则有什么好处？为什么要这么编号？</li><li>如果让你来对公路进行编号，你会怎么编号呢？</li><li>2个城市之间可能有多条线路，又该如何编号呢？</li></ol><h1 id="如何给道路进行编码">如何给道路进行编码？</h1><p>假设我们在下图 8 所示的纽约曼哈顿的 <span class="math inline">\(A\)</span>点，我们要去古根海姆博物馆。此时我们位于 东区第 87 大街和 第 3大道的十字路口，我们要去的目标在 东区第 88 大街和 第 5大道交汇处十字路口。很显然，我们有很多条路线可以到达目的地。</p><figure><img src="https://www.longluo.me/assets/blog/images/road/manhattan_road.png" alt="图8. 曼哈顿街区"><figcaption aria-hidden="true">图8. 曼哈顿街区</figcaption></figure><p>即使你是个路痴，当你沿着东区第 87大街走的时候，如果你走着走着发现走到了第 4大道，你就知道至少在东西方向上你的方向对了，而当你发现走到了第 2大道，你就知道你方向走反了。同理，对于南北方向上也是如此。这样，即使你绕了很多路，但你只要知道目的地所在街区的编号，你就调整方向，多走点路多花点时间也一定能走到目的地。</p><p>当然我在写这篇文章时，想找个浅显易懂的例子，结果发现曼哈顿街区完美的符合我想找的例子。因为道路规划太好了，呈棋盘状。实际中大部分城市街区命名不一定使用数字，也不一定如此横平竖直。但是曼哈顿街区因为都使用数字编号，我们想找具体地点太容易了，这还没用上二分查找呢！</p><p>由于现实中由于不同地区地理条件不一样，城市的分布往往在地图上是随机的，比如下图9 就是我随手绘制的一个道路分布图。</p><figure><img src="https://www.longluo.me/assets/blog/images/road/road_graph.png" alt="图9. 城市之间道路图"><figcaption aria-hidden="true">图9. 城市之间道路图</figcaption></figure><p>如何对这些道路进行命名？你可能会说，那就以出发地和目的地命名好了，比如<span class="math inline">\(AB\)</span> , <span class="math inline">\(BC\)</span>等。当然这样命名也可以，但是我们可以更进一步，让命名和曼哈顿街区命名一样，让名字就<strong>自带导航</strong>功能。</p><p>那比如有 100 条道路，如何给每条道路编上正确的号码呢？从 1开始递增当然也可以，但就没有任何信息了。</p><p>让我们回顾现实中的高速公路，我们知道一条高速公路有哪些属性呢？</p><ol type="1"><li>是东西走向？南北？还是东北、东南、西南、西北？</li><li>是国家级主干道还是省级，市级？</li><li>连接哪些城市？在哪个位置？</li></ol><p>还记得地球仪上的经线和纬线吗？<a href="https://www.longluo.me/blog/2023/05/20/the-mercator-projection/">墨卡托投影</a>制作的地图帮助无数航海家顺利抵达目的地，航海家只要知道测量出当前所在地经纬度，沿着连接目的地的方向就不会迷失方向。</p><p>想一想，如何数字也有很多属性，比如奇偶性、大小、位数等，参考之前的编号系统，我们可以用<strong>数字属性</strong>和<strong>高速公路属性</strong>一一对应<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> ，比如：</p><ol type="1"><li>奇偶 <span class="math inline">\(\leftrightarrow\)</span>公路走向</li><li>大小 <span class="math inline">\(\leftrightarrow\)</span>公路位置</li><li>数字位数 <span class="math inline">\(\leftrightarrow\)</span>主干道和次要干道</li><li><span class="math inline">\(5\)</span> 的倍数 <span class="math inline">\(\leftrightarrow\)</span> 重要道路</li></ol><p>不得不说，这种设计比曼哈顿的纯数字编号要好很多，绝对是天才般的设计 <a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>！下面我们就来介绍这种编号系统的诞生地：美国州际高速公路系统。</p><h1 id="州际公路interstate-highway-system的天才设计">州际公路（InterstateHighway System）的天才设计</h1><p>也许是艾森豪威尔总统 <a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>二战时担任盟军统帅，战后又担任美国驻德国占领军总司令的缘故，我想当时德国领先世界的高速公路系统肯定给他留下了深刻印象。在他1953 - 1961年担任总统期间，提出了州际高速公路系统的构想，并在1956年签署了《国家公路与交通法案》，旨在建立一套横贯美国的高速公路网络，以提升国家交通运输效率和安全性。这个宏伟的工程由联邦政府主导，并联合各州政府共同筹资和建设。经过数十年的不懈努力，美国州际高速公路系统于1992年正式完成，涵盖了数万英里的公路，连接了各个州份和城市，成为美国国家交通运输体系的重要组成部分，也促进了经济的发展和人口的流动。</p><p>州际公路系统每条线路和编号，可以参考这个在线网站：<a href="https://interstate-map.com/">Interstate Highway Map</a></p><p>下面我们来介绍下州际高速公路的编号规则 <a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>：</p><h2 id="位数字">2 位数字</h2><ol type="1"><li><strong>偶数</strong>且为 <span class="math inline">\(5\)</span>的倍数的 <span class="math inline">\(2\)</span>位数字表示东西向主干道，从南到北依次递增，如下图 10 所示：</li></ol><figure><img src="https://www.longluo.me/assets/blog/images/road/interstate_even.jpg" alt="图10. 偶数表示东西向主干道"><figcaption aria-hidden="true">图10. 偶数表示东西向主干道</figcaption></figure><p>其实也很好记， <span class="math inline">\(\text{Even}\)</span> 对应<span class="math inline">\(\text{East}\)</span> ，而且 <span class="math inline">\(0\)</span>不偏不倚，表示<strong>水平</strong>方向，很容易记吧！</p><ol start="2" type="1"><li><strong>奇数</strong>且为 <span class="math inline">\(5\)</span>的倍数的 <span class="math inline">\(2\)</span>位数字表示南北向主干道，从西到东依次递增，如下图 11 所示：</li></ol><figure><img src="https://www.longluo.me/assets/blog/images/road/interstate_odd.jpg" alt="图11. 奇数表示南北向主干道"><figcaption aria-hidden="true">图11. 奇数表示南北向主干道</figcaption></figure><p>其实也很好记，偶数表示东西向，那奇数就是南北向了，这是主要干道，肯定不能依次递增，所以每次递增<span class="math inline">\(5\)</span> 。注意西海岸的 <span class="math inline">\(5\)</span> 要当成 <span class="math inline">\(05\)</span> 。</p><p>如何理解数字增加方向呢？</p><p>由于美国本土大致呈矩形，如果我们在地图左下角作为坐标原点，建立一个笛卡尔坐标系，如下图12 所示，想必你忘不了：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/us_interstates_coord.jpg" alt="图12. 高速公路坐标"><figcaption aria-hidden="true">图12. 高速公路坐标</figcaption></figure><p>由于中国的国土疆域并不像美国接近一个矩形，所以坐标点实际是放在靠近北京的右上角，如下图13 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/china_national_expressway_network_coord.png" alt="图13. 国内高速公路坐标"><figcaption aria-hidden="true">图13. 国内高速公路坐标</figcaption></figure><p>如果你掌握了这个规则，那么下面这个路标，你能猜出大概在美国哪里吗？可以先猜测然后自寻答案验证下你的猜测。</p><figure><img src="https://www.longluo.me/assets/blog/images/road/us_road_sign.jpg" alt="图14. 美国某处路标"><figcaption aria-hidden="true">图14. 美国某处路标</figcaption></figure><h2 id="位数字-1">3 位数字</h2><p>相比 <span class="math inline">\(2\)</span>位数字高速公路是跨州线路(注：不完全如此)， <span class="math inline">\(3\)</span>位数的州际公路是服务于各个都会区的较短路线，它们连接到更长的两位数路线，并且充当环城公路、支线或连接线路。</p><p><span class="math inline">\(3\)</span> 位数编号规则如下：</p><ul><li>第 <span class="math inline">\(1\)</span> 位数字反映了道路的用途，后<span class="math inline">\(2\)</span>位数字反映路线连接到的任何两位数的州际公路。例如，I-395 连接到I-95，I-270 连接到 I-70 ；</li><li>第 <span class="math inline">\(1\)</span>位数字如果是<strong>偶数</strong>，说明和州际公路会有 <span class="math inline">\(2\)</span> 个交点，奇数则仅相交一次；</li><li>对于 <span class="math inline">\(3\)</span>位数的州际公路，只要同一数字不在同一州内重复，就可以根据需要重复相同的数字。</li></ul><figure><img src="https://www.longluo.me/assets/blog/images/road/interstate_auxiliary.png" alt="图15. 州际公路支线"><figcaption aria-hidden="true">图15. 州际公路支线</figcaption></figure><p>国内公路编号系统则大致相同，可以参考 主干道 <a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>和 辅道 <a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> ，具体可参考 <a href="http://www.chinahighway.org/">中国高速公路网</a> 。</p><p>上面就是美国州际高速公路的大致规则，当然也会有一些例外。</p><p>这套编号系统不仅方便导航，有效帮助驾驶员辨别方向，还提供了关于道路走向和地理位置的信息，提高了道路网络的整体效率和安全性，它是如此的成功，以致于后来陆续被其他国家所采用。</p><h1 id="总结">总结</h1><p>生活处处皆学问，正如王建硕老师写的系列文章：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5NzI0Mjg0MA==&amp;action=getalbum&amp;album_id=1501981971495911427&amp;scene=173&amp;subscene=&amp;sessionid=svr_17f196d2f28&amp;enterid=1717510695&amp;from_msgid=2652377029&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect">无用的冷知识</a>。如果我们对日常事务多一点好奇心，我们可以发现后面更多的原理！</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://www.thepaper.cn/newsDetail_forward_3357040">高速公路是怎样命名和编号的？</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://mp.weixin.qq.com/s/w1BO7tGNsSDFfzbwZshiUQ">5分钟看懂中国国家高速的编号密码</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://www.gov.cn/gzdt/2007-07/24/content_694440.htm">交通部通知开展国家高速公路网路线命名编号调整</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://en.wikipedia.org/wiki/G35_Jinan%E2%80%93Guangzhou_Expressway">G35</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/China_National_Highways">中华人民共和国高速公路</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://en.wikipedia.org/wiki/Autobahn">德国高速公路</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://www.historydefined.net/history-of-the-autobahn/">TheAutobahn: Unraveling the Story of the World’s First Superhighway</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p><a href="https://edition.cnn.com/travel/article/autobahn-germany-history/index.html">HowGerman Autobahns changed the world</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn9"><p><a href="https://www.britannica.com/place/Germany/Highways">Highways ofGermany</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn10"><p><a href="https://en.wikipedia.org/wiki/Autoroutes_of_France">Autoroutes ofFrance</a><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn11"><p><a href="https://www.zhihu.com/question/52288622">法国为什么首都一家独大？</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn12"><p><a href="https://en.wikipedia.org/wiki/Russian_federal_highways">俄罗斯联邦高速公路</a><a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn13"><p><a href="https://en.wikipedia.org/wiki/International_E-road_network">欧洲高速公路</a><a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn14"><p><a href="https://en.wikipedia.org/wiki/Trans-Canada_Highway">跨加拿大高速公路</a><a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn15"><p><a href="https://en.wikipedia.org/wiki/Brazilian_Highway_System">巴西高速公路</a><a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn16"><p><a href="https://en.wikipedia.org/wiki/Interstate_Highway_System">州际高速系统</a><a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn17"><p><a href="https://www.youtube.com/watch?v=8Fn_30AD7Pk">The Interstate’sForgotten Code</a><a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn18"><p><a href="https://ggwash.org/view/73804/decode-the-interstates-what-highway-numbers-actually-mean">Whathighway numbers actually mean</a><a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn19"><p><a href="https://en.wikipedia.org/wiki/Dwight_D._Eisenhower">Dwight D.Eisenhower</a><a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn20"><p><a href="https://99percentinvisible.org/article/american-highways-101-visual-guide-to-u-s-road-sign-designs-numbering-systems/">AmericanHighways 101</a><a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn21"><p><a href="https://en.wikipedia.org/wiki/List_of_primary_NTHS_Expressways">Listof primary NTHS Expressways</a><a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn22"><p><a href="https://en.wikipedia.org/wiki/List_of_auxiliary_NTHS_Expressways">Listof auxiliary NTHS Expressways</a><a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;世界那么大，我想去看看！随着科技的发展，我们早已做到无需离开家就能领略世界各地的风景和文化。通过高清视频、高清直播、社交媒体、
VR
技术、各种图片或者视频分享平台，我们不仅可以体验世界名胜古迹、自然美景和各地的风土人情，还能与当地居民互动，了解他们的日常生活和传统文化。互联网丰富了人们的生活，缩小了地域的界限，真正实现了让世界触手可及，足不出户便可周游世界的梦想。但正所谓“百闻不如一见”，“读万卷书，不如行万里路！”，尽管互联网让我们可以虚拟游览世界，但亲自出行的体验无可替代。自由行不仅提供了前所未有的自由和灵活性，还能让我们亲身感受到大自然的美妙、城市的活力。这种身临其境的体验，远非屏幕前的感受可比。&lt;/p&gt;
&lt;p&gt;当你打开地图软件时，你会看到如图 1 所示的道路标志，&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/road/highway_mark.png&quot; alt=&quot;图1. 道路编号&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图1. 道路编号&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;当你在道路出行时，你也会看到看到如下图 2
所示的路牌，但你可能并未真正留意过这些标志。因为现在我们只需要有一部联网的智能手机，在地图类软件里，设定出发地和目的地，自然有导航会指引我们到达目的地。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/road/china_expwy_g35_sign_with_name_in_luogang_tollgate.jpg&quot; alt=&quot;图2. G35 高速萝岗路段&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图2. G35 高速萝岗路段&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;这些编号肯定不是随机的，那么这些道路编号到底有什么用呢？出于好奇心你可能会去寻找答案，你很容易轻松找到
中国国家高速的编号密码 &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 和 高速公路是怎样命名和编号 &lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;
这样的文章。但这些文章只是告诉我们是什么，并没有告诉我们为什么。&lt;/p&gt;
&lt;p&gt;国内现行的高速公路命名是由交通部从 2005 年启动的 &lt;a href=&quot;#fn3&quot; class=&quot;footnote-ref&quot; id=&quot;fnref3&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;
，之前道路都以起始地和终点地命名。你可能会想，之前那种命名方式不是更合理吗？用了数字不是更加不清晰易懂吗？如果图
1 不是路牌上写了济广高速，谁知道 G35 &lt;a href=&quot;#fn4&quot; class=&quot;footnote-ref&quot; id=&quot;fnref4&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; 是哪里到哪里呢？&lt;/p&gt;
&lt;p&gt;如果你更进一步的话，如果你去了解世界其他国家的高速公路命名的话，你会惊讶的地发现为什么居然全世界各主要大国都选择了类似的编号系统，这背后的原因是什么呢？&lt;/p&gt;
&lt;p&gt;要回答这个问题，我们需要把时钟拨回几十年前，回到高速公路诞生的时期，那个没有
GPS
，没有手机，只有纸质地图的时代，我们才能知道这种编号系统的&lt;strong&gt;重要意义&lt;/strong&gt;和&lt;strong&gt;实用性&lt;/strong&gt;，以及背后的&lt;strong&gt;数学密码&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;世界各国如何对高速公路进行编号&quot;&gt;世界各国如何对高速公路进行编号？&lt;/h1&gt;
&lt;p&gt;我们已经了解了国内高速公路编号 &lt;a href=&quot;#fn5&quot; class=&quot;footnote-ref&quot; id=&quot;fnref5&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;
，让我们看看其他国家的高速公路系统编号是什么样的。这些国家需要国土面积足够大，高速公路系统足够发达，国土疆域长宽比例没有太夸张，人口分布比较均匀。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Code" scheme="https://www.longluo.me/tags/Code/"/>
    
    <category term="Navigation" scheme="https://www.longluo.me/tags/Navigation/"/>
    
    <category term="Highway" scheme="https://www.longluo.me/tags/Highway/"/>
    
  </entry>
  
  <entry>
    <title>2024 阿里巴巴全球数学竞赛预选赛 试题解答</title>
    <link href="https://www.longluo.me/blog/2024/04/16/2024-alibaba-global-mathematics-competition-qualifying-round/"/>
    <id>https://www.longluo.me/blog/2024/04/16/2024-alibaba-global-mathematics-competition-qualifying-round/</id>
    <published>2024-04-16T03:13:48.000Z</published>
    <updated>2024-06-16T10:40:11.360Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p><a href="https://damo.alibaba.com/?language=zh">阿里巴巴达摩院</a> 从2018年开始每年都会举办一届全球数学竞赛，之前一方面自己数学水平比较弱，另外一方面也没有报名，但一直很仰慕那些数学大神的风采。今年是第一次报名参加<a href="https://damo.alibaba.com/alibaba-global-mathematics-competition?language=zh">2024阿里巴巴全球数学竞赛</a>，上周末参加了预选赛，但遗憾的是，全部 <span class="math inline">\(7\)</span> 道题中只有第 <span class="math inline">\(1, 2, 6\)</span> 题会做，这里分享下我的解答：</p><h1 id="problem-1">Problem 1</h1><p>几位同学假期组成一个小组去某市旅游. 该市有 <span class="math inline">\(6\)</span> 座塔，它们的位置分别为 <span class="math inline">\(A, B, C, D, E, F\)</span>。同学们自由行动一段时间后，每位同学都发现，自己在所在的位置只能看到位于<span class="math inline">\(A, B, C, D\)</span> 处的四座塔，而看不到位于<span class="math inline">\(E\)</span> 和 <span class="math inline">\(F\)</span> 的塔。已知：</p><ol type="1"><li>同学们的位置和塔的位置均视为同一平面上的点，且这些点彼此不重合；</li><li>塔中任意 <span class="math inline">\(3\)</span> 点不共线；</li><li>看不到塔的唯一可能就是视线被其它的塔所阻挡，例如，如果某位同学所在的位置<span class="math inline">\(P\)</span> 和 <span class="math inline">\(A, B\)</span> 共线，且 <span class="math inline">\(A\)</span> 在线段<span class="math inline">\(PB\)</span> 上，那么该同学就看不到位于 <span class="math inline">\(B\)</span> 处的塔。</li></ol><p><strong>（5 分）</strong> 请问 这个旅游小组最多可能有多少名同学？</p><p><span class="math inline">\(A. 3\)</span><br><span class="math inline">\(B. 4\)</span> <span class="math inline">\(C.6\)</span> <span class="math inline">\(D. 12\)</span></p><h2 id="solution">Solution</h2><p>这道题选 <span class="math inline">\(C\)</span> ，最多只能有 <span class="math inline">\(6\)</span> 名同学。</p><blockquote><p>[!TIP] 这道题的解题思路是，从假设只有 <span class="math inline">\(1\)</span> 座塔开始，一直到 <span class="math inline">\(6\)</span> 座塔，找到思路。</p></blockquote><ol type="1"><li><p>假设有 <span class="math inline">\(1\)</span> 座塔 <span class="math inline">\(A\)</span> ，那么很显然有无数多同学可以看到塔<span class="math inline">\(A\)</span> ，也可以有无数多同学看不到塔<span class="math inline">\(A\)</span>​ ；</p></li><li><p>假设有 <span class="math inline">\(2\)</span> 座塔 <span class="math inline">\(A, B\)</span> ，那么只有以 <span class="math inline">\(A\)</span> 为起点的射线 <span class="math inline">\(AB\)</span> 且位于 <span class="math inline">\(B\)</span> 之后的同学无法看到塔 <span class="math inline">\(A\)</span> ；</p></li><li><p>假设有 <span class="math inline">\(3\)</span> 座塔 <span class="math inline">\(A, B, C\)</span>，同理可知存在无数位同学至少可以看见 <span class="math inline">\(2\)</span> 座塔；</p></li><li><p>假设有 <span class="math inline">\(4\)</span> 座塔 <span class="math inline">\(A, B, C, D\)</span>，同理可知存在无数位同学至少可以看见 <span class="math inline">\(2\)</span> 座塔；</p></li><li><p>假设有 <span class="math inline">\(6\)</span> 座塔 <span class="math inline">\(A, B, C, D, E, F\)</span> ，如果每位同学都无法看见<span class="math inline">\(E, F\)</span> 塔，如下图1 所示：</p></li></ol><figure><img src="https://www.longluo.me/assets/blog/images/math/2024-alibaba-math-contest-problem1-solution.png" alt="图1. Solution of Problem 1"><figcaption aria-hidden="true">图1. Solution of Problem 1</figcaption></figure><p>所以至多有 <span class="math inline">\(6\)</span> 位同学位于 <span class="math inline">\(M, N, O, P, R, Q\)</span> 处，无法看到塔 <span class="math inline">\(E, F\)</span> 。</p><span id="more"></span><h1 id="problem-2">Problem 2</h1><p>小明玩战机游戏。初始积分为 <span class="math inline">\(2\)</span>。在游戏进行中，积分会随着时间线性地连续减少 (速率为每单位时间段扣除<span class="math inline">\(1\)</span> )。游戏开始后，每隔一个随机时间段(时长为互相独立的参数为 <span class="math inline">\(1\)</span>的指数分布)，就会有一架敌机出现在屏幕上。当敌机出现时，小明立即进行操作，可以瞬间击落对方，或者瞬间被对方击落。如被敌机击落，则游戏结束。如小明击落敌机，则会获得<span class="math inline">\(1.5\)</span>个积分，并且可以选择在击落该次敌机后立即退出游戏，或者继续游戏。如选择继续游戏，则须等待到下一架敌机出现，中途不能主动退出。游戏的难度不断递增：出现的第<span class="math inline">\(n\)</span> 架敌机，小明击落对方的概率为<span class="math inline">\((0.85)^n\)</span> ，被击落的概率为 <span class="math inline">\(1 - (0.85)^n\)</span>，且与之前的事件独立。在任何时刻，如果积分降到 <span class="math inline">\(0\)</span> ，则游戏自动结束。</p><h2 id="第-1-问">第 1 问</h2><p><strong>小问 1 (5分)</strong>如果游戏中，小明被击落后，其之前的积分保持。那么为了游戏结束时的累积积分的数学期望最大化，小明应该在其击落第几架敌机后主动结束游戏？</p><p><span class="math inline">\(A. 1\)</span> <span class="math inline">\(B. 2\)</span> <span class="math inline">\(C.3\)</span> <span class="math inline">\(D. 4\)</span></p><h3 id="solution-1">Solution</h3><blockquote><p>[!TIP] 这道题考察的就是泊松过程<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，数学好的同学推出其表达式，然后计算可得。需要注意的是泊松分布<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Python 代码可以直接调用 API <a href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.exponential.html"><code>numpy.random.exponential</code></a>。虽然是 <a href="https://en.wikipedia.org/wiki/Exponential_distribution">指数分布</a>，但在 Java 中 需要使用 <code>-Math.log(1 - random.nextDouble())</code>而不是 <code>Math.exp(double a)</code> 。模拟代码如下所示：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarPlaneGame</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getExpectScore</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; planes; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">waitTime</span> <span class="operator">=</span> -Math.log(<span class="number">1</span> - random.nextDouble());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt;= score) {</span><br><span class="line">                score = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            score -= waitTime;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">possonPr</span> <span class="operator">=</span> random.nextDouble();</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">shootDownPr</span> <span class="operator">=</span> Math.pow(<span class="number">0.85</span>, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (possonPr &lt; shootDownPr) {</span><br><span class="line">                score += <span class="number">1.5</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">simulate</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">simulateTimes</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">scoreSum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; simulateTimes; i++) {</span><br><span class="line">            scoreSum += getExpectScore(planes);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> scoreSum / simulateTimes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> simulate(i);</span><br><span class="line">            System.out.println(<span class="string">"Shoot down "</span> + i + <span class="string">" planes, Expect Score: "</span> + result);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shoot down 1 planes, Expect Score: 2.2344824425425442</span><br><span class="line">Shoot down 2 planes, Expect Score: 2.290207012168609</span><br><span class="line">Shoot down 3 planes, Expect Score: 2.2653361024420042</span><br><span class="line">Shoot down 4 planes, Expect Score: 2.187342196221392</span><br></pre></td></tr></tbody></table></figure><p>可以看出击落第 <span class="math inline">\(2\)</span>架敌机后主动结束游戏，期望积分最大，所以答案选 <span class="math inline">\(B\)</span> 。</p><h2 id="第-2-问">第 2 问</h2><p><strong>小问 2 (5分)</strong>如果游戏中，小明被击落后，其之前积累的的积分会清零。那么为了游戏结束时的期望积分最大化，小明也会选择一个最优的时间主动结束游戏。请问在游戏结束时（小明主动结束游戏、或积分减到<span class="math inline">\(0\)</span>），下列哪一个选项最接近游戏结束时小明的期望积分？</p><p><span class="math inline">\(A. 2\)</span><br><span class="math inline">\(B. 4\)</span> <span class="math inline">\(C.6\)</span> <span class="math inline">\(D. 8\)</span></p><h3 id="solution-2">Solution</h3><blockquote><p>[!TIP] 通过第一问，我们知道期望积分是随着次数逐渐递减的。</p></blockquote><p>继续写代码模拟其过程，如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarPlaneGame</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getExpectScore2</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; planes; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">waitTime</span> <span class="operator">=</span> -Math.log(<span class="number">1</span> - random.nextDouble());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt;= score / <span class="number">2</span>) {</span><br><span class="line">                score /= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            score -= waitTime;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">possonPr</span> <span class="operator">=</span> random.nextDouble();</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">shootDownPr</span> <span class="operator">=</span> Math.pow(<span class="number">0.85</span>, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (possonPr &lt; shootDownPr) {</span><br><span class="line">                score += <span class="number">1.5</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                score = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">simulate</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">simulateTimes</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">scoreSum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; simulateTimes; i++) {</span><br><span class="line">            scoreSum += getExpectScore2(planes);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> scoreSum / simulateTimes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> simulate(i);</span><br><span class="line">            System.out.println(<span class="string">"Shoot down "</span> + i + <span class="string">" planes, Expect Score: "</span> + result);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shoot down 1 planes, Expect Score: 2.0230245088842116</span><br><span class="line">Shoot down 2 planes, Expect Score: 1.7658505471404586</span><br><span class="line">Shoot down 3 planes, Expect Score: 1.42047193787333</span><br><span class="line">Shoot down 4 planes, Expect Score: 1.0837167796697962</span><br><span class="line">Shoot down 5 planes, Expect Score: 0.8877915996251725</span><br><span class="line">Shoot down 6 planes, Expect Score: 0.7556905685107955</span><br><span class="line">Shoot down 7 planes, Expect Score: 0.7055539105268976</span><br><span class="line">Shoot down 8 planes, Expect Score: 0.6896372679317954</span><br></pre></td></tr></tbody></table></figure><p>可以看出最大期望积分是 <span class="math inline">\(2.023\)</span>左右，所以答案选 <span class="math inline">\(A\)</span> 。</p><h1 id="problem-3">Problem 3</h1><p>对于实数 <span class="math inline">\(T &gt; 0\)</span> ，称欧式平面<span class="math inline">\(\mathbb{R}^2\)</span> 的子集 <span class="math inline">\(\Gamma\)</span> 为 <span class="math inline">\(T\)</span> -稠密的，如果对任意 <span class="math inline">\(v \in \mathbb{R}^{2}\)</span> ，存在 <span class="math inline">\(w \in \Gamma\)</span> 满足 <span class="math inline">\(\|v-w\| \leqslant T\)</span> . 设 <span class="math inline">\(2\)</span> 阶整方阵 <span class="math inline">\(A\in \mathrm{M}_{2}(\mathbb{Z})\)</span> 满足 <span class="math inline">\(\operatorname{det}(A) \neq 0\)</span> .</p><ol type="1"><li><strong>证明题(10分)</strong> 假设 <span class="math inline">\(\operatorname{tr}(A)=0\)</span> . 证明存在 <span class="math inline">\(C &gt; 0\)</span> ，使得对任意正整数 <span class="math inline">\(n\)</span>​ ，集合</li></ol><p><span class="math display">\[A^{n} \mathbb{Z}^{2}:=\left\{A^{n} v: v \in \mathbb{Z}^{2}\right\}\]</span></p><p>是 <span class="math inline">\(C|\operatorname{det}(A)|^{n /2}\)</span> -稠密的.</p><ol start="2" type="1"><li><strong>证明题 (10分)</strong> 假设 <span class="math inline">\(A\)</span> 的特征多项式在有理数域上不可约.证明与(1)相同的结论.</li></ol><p>注: 这里 <span class="math inline">\(\mathbb{R}^{2}\)</span> 和 <span class="math inline">\(\mathbb{Z}^{2}\)</span> 中的向量约定为列向量,<span class="math inline">\(\mathbb{R}^{2}\)</span> 中的内积为标准内积,即 <span class="math inline">\(\langle v, w\rangle=v^{t} w\)</span> .(提示: 在对(2)的证明中, 可使用如下 <span class="math inline">\(\text{Minkowski}\)</span> 凸体定理的特殊情形：<span class="math inline">\(\mathbb{R}^{2}\)</span>中以原点为中心且面积为 <span class="math inline">\(4\)</span>的任意闭平行四边形中总包含 <span class="math inline">\(\mathbb{Z}^{2}\)</span>​ 中的非零向量.)</p><h2 id="solution-3">Solution</h2><blockquote><p>[!TIP] 先挖坑，等我看懂了大神的解答再来填坑！</p></blockquote><h1 id="problem-4">Problem 4</h1><p>设 <span class="math inline">\(d \geq 0\)</span> 是整数， <span class="math inline">\(V\)</span> 是 <span class="math inline">\(2d+1\)</span> 维复线性空间，有一组基</p><p><span class="math display">\[\left\{v_1, v_2, \cdots, v_{2 d+1}\right\} \text {. }\]</span></p><p>对任一整数 <span class="math inline">\(j\left(0 \leq j \leq\frac{d}{2}\right)\)</span> ，记 <span class="math inline">\(U_j\)</span> 是</p><p><span class="math display">\[v_{2 j+1}, v_{2 j+3}, \cdots, v_{2 d-2 j+1}\]</span></p><p>生成的子空间. 定义线性变换 <span class="math inline">\(f: V\rightarrow V\)</span> 为</p><p><span class="math display">\[f\left(v_i\right)=\frac{(i-1)(2 d+2-i)}{2} v_{i-1}+\frac{1}{2} v_{i+1},1 \leq i \leq 2 d+1 .\]</span></p><p>这里我们约定 <span class="math inline">\(v_0=v_{2d+2}=0\)</span>.</p><ol type="1"><li><p><strong>证明题 (10分)</strong> 证明: <span class="math inline">\(f\)</span> 的全部特征值为 <span class="math inline">\(-d,-d+1, \cdots, d\)</span>.</p></li><li><p><strong>问答题 (5分)</strong> 记 <span class="math inline">\(W\)</span> 是从属于特征值 <span class="math inline">\(-d+2 k(0 \leq k \leq d)\)</span> 的 <span class="math inline">\(f\)</span> 的特征子空间的和. 求 <span class="math inline">\(W \cap U_0\)</span> 的维数.</p></li><li><p><strong>问答题 (5分)</strong> 对任一整数 <span class="math inline">\(j\left(1 \leq j \leq \frac{d}{2}\right)\)</span>，求 <span class="math inline">\(W \cap U_j\)</span>​​​​ 的维数.</p></li></ol><h2 id="solution-4">Solution</h2><blockquote><p>[!TIP] 先挖坑，等我看懂了大神的解答再来填坑！</p></blockquote><h1 id="problem-5">Problem 5</h1><p><strong>证明题 (20分)</strong> 对于 <span class="math inline">\(\mathbb{R}^3\)</span> 中的任何中心对称的凸多面体<span class="math inline">\(V\)</span> ，证明可以找到一个椭球面 <span class="math inline">\(E\)</span> ，把凸多面体包在内部，且 <span class="math inline">\(E\)</span> 的表面积不超过 <span class="math inline">\(V\)</span> 的表面积的 <span class="math inline">\(3\)</span> 倍。</p><h2 id="solution-5">Solution</h2><blockquote><p>[!TIP] 先挖坑，等我看懂了大神的解答再来填坑！</p></blockquote><h1 id="problem-6">Problem 6</h1><h2 id="第-1-问-1">第 1 问</h2><p>假设有一枚硬币，投掷得到正面的概率为 <span class="math inline">\(\frac{1}{3}\)</span> 。独立地投掷该硬币 <span class="math inline">\(n\)</span> 次，记 <span class="math inline">\(X_n\)</span> 为其中得到正面的次数。试求 <span class="math inline">\(X_n\)</span> 为偶数的概率在 <span class="math inline">\(n\)</span> 趋于正无穷时的极限。</p><h3 id="solution-6">Solution</h3><blockquote><p>[!TIP] 当 <span class="math inline">\(n \to \infty\)</span>，直觉告诉我们，偶数次正面出现的概率和奇数次正面出现的概率是一样的，而<strong>奇数</strong>和<strong>偶数</strong>是均匀分布的，答案应该是<span class="math inline">\(\frac{1}{2}\)</span>。但这道题不是选择题也不是填空题，我们需要严谨证明这个结论！</p></blockquote><p>由题意可知，设随机变量 <span class="math inline">\(X_n\)</span>表示在 <span class="math inline">\(n\)</span>次独立投掷中正面出现的次数，每次出现正面的概率为 <span class="math inline">\(p = \frac{1}{3}\)</span> ，则 <span class="math inline">\(X_n\)</span> 服从参数为 <span class="math inline">\(\operatorname{B}(n, p)\)</span> 的二项分布<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ，那么 <span class="math inline">\(n\)</span> 次独立投掷中正面出现 <span class="math inline">\(k\)</span> 次的概率是：</p><p><span class="math display">\[\begin{equation}\operatorname{Pr}(X_n = k) = \binom{n}{k} p^k (1−p)^{n−k}    \tag{6.1.1}\label{6.1.1}\end{equation}\]</span></p><p>要求 <span class="math inline">\(X_n\)</span> 为偶数的概率，即：</p><p><span class="math display">\[\begin{aligned}\operatorname{Pr}(X_n \text { is even}) &amp; = \operatorname{Pr}(X_n =0) + \operatorname{Pr}(X_n = 2) + \cdots + \operatorname{Pr}(X_n = 2k, k= \left \lfloor \frac{n}{2} \right \rfloor ) \\&amp; = \sum_{k=0}^{\left \lfloor \frac{n}{2} \right \rfloor}\binom{n}{2k} p^{2k} (1 − p)^{n − 2k}\end{aligned}\]</span></p><p>带入 <span class="math inline">\(p = \frac{1}{3}\)</span>，可得：</p><p><span class="math display">\[\begin{equation}\operatorname{Pr}(X_n \text { is even}) = \sum_{k=0}^{\left \lfloor\frac{n}{2} \right \rfloor} \binom{n}{2k} (\frac{1}{3})^{2k}(\frac{2}{3})^{n−2k}    \tag{6.1.2} \label{6.1.2}\end{equation}\]</span></p><p>由 二项式定理<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> 可知：</p><p><span class="math display">\[\begin{equation}(x + y)^n = \sum_{k=0}^{n} \binom{n}{k} x^k y^{n−k}    \tag{6.1.3}\label{6.1.3}\end{equation}\]</span></p><p>那么易得共轭表达式：</p><p><span class="math display">\[\begin{align}(x + y)^n + (x − y)^n &amp; = 2 \sum_{k=0}^{\left \lfloor \frac{n}{2}\right \rfloor} x^{2k}y^{n - 2k}   \tag{6.1.4} \label{6.1.4} \\(x + y)^n - (x − y)^n &amp; = 2 \sum_{k=0}^{\left \lfloor \frac{n}{2}\right \rfloor} x^{2k + 1}y^{n - 2k - 1}   \tag{6.1.5} \label{6.1.5}\end{align}\]</span></p><p>可得：</p><p><span class="math display">\[\begin{aligned}\operatorname{Pr}(X_n \text { is even}) &amp; = \sum_{k=0}^{\left\lfloor \frac{n}{2} \right \rfloor} \binom{n}{2k} (\frac{1}{3})^{2k}(\frac{2}{3})^{n−2k} \\&amp; = \frac{1}{2} \left [ \left (\frac{1}{3} + \frac{2}{3} \right )^n+ \left (\frac{1}{3} - \frac{2}{3} \right )^n \right ]  \\&amp; = \frac{1}{2} \left [1 + \frac{1}{3^n} \right ]\end{aligned}\]</span></p><p>故答案为：</p><p><span class="math display">\[\lim_{n \to \infty} \operatorname{Pr}(X_n \text { is even}) = \lim_{n\to \infty} \frac{1}{2} \left (1 + \frac{1}{3^n} \right ) = \frac{1}{2}\]</span></p><blockquote><p>[!TIP] 这道题也可以用 <a href="https://en.wikipedia.org/wiki/Markov_chain">马尔可夫链</a>来做，构建递推关系式，感兴趣的同学可以试试！</p></blockquote><h2 id="第-2-问-1">第 2 问</h2><p>某人在过年期间参加了集五福活动，在这项活动中此人每扫描一次福字，可以随机地得到五张福卡中的一张。假设其每次扫福得到五福之一的概率固定，分别为<span class="math inline">\(p_i \in (0, 1) , i = 1, 2, \cdots ,5\)</span> 且 <span class="math inline">\(\sum_{i = 1}^{5} p_i =1\)</span> ，并假设其每次扫描得到的结果相互独立。在进行了 <span class="math inline">\(n\)</span> 次扫福之后，记 <span class="math inline">\(X^{i}_n, i =1, 2, \cdots, 5\)</span>为其得到每种福卡的张数。那么求极限 <span class="math inline">\(\lim _{n\to \infty} \operatorname{P} \left ( X^{(i)}_{2n}, i = 1, 2, \cdots, 5\text { 全部为偶数} \right )\)</span> 。</p><h3 id="solution-7">Solution</h3><blockquote><p>[!TIP] 直觉告诉我们，当 <span class="math inline">\(n \to\infty\)</span>时，五种福卡每种都是偶数的事件是<strong>相互独立</strong>的。通过第一问，我们已经知道答案是<span class="math inline">\(\frac{1}{2}\)</span>，那么五种福卡每种福卡的张数都是偶数的概率就是 <span class="math inline">\(\frac{1}{2^5} = \frac{1}{32}\)</span> ，而 <span class="math inline">\(2n\)</span> 次扫福卡的概率就是 <span class="math inline">\(\frac{1}{16}\)</span>。这个猜测对不对呢？下面我们就来证明下。</p></blockquote><p>由多项式定理<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> ：</p><p><span class="math display">\[\left (x_{1} + x_{2} + \cdots + x_{m} \right)^{n} = \sum_{\begin{array}{c} \alpha _{1} + \alpha _{2} + \cdots + \alpha _{m} = n\\ \alpha _{1},\alpha _{2},\cdots ,\alpha _{m} \geq 0 \end {array}}{\frac {n!}{\alpha _{1}! \dots \alpha _{m}!}}x_{1}^{\alpha _{1}} \dotsx_{m}^{\alpha _{m}}    \tag{6.2.1} \label{6.2.1}\]</span></p><p>设 <span class="math inline">\(k_i, i = 1,2, \cdots ,5\)</span>表示是 <span class="math inline">\(n\)</span> 次独立扫描福卡中得到第<span class="math inline">\(i\)</span> 种福卡的张数，则其概率为：</p><p><span class="math display">\[\begin{align}\operatorname{Pr} \left (X_{n}^{(i)} = k_i, i=1,2, \cdots ,5 \right)&amp;= \binom {n}{k_1, k_2, \cdots, k_5} p_1^{k_1} p_2^{k_2} \cdotsp_5^{k_5}   \nonumber  \\&amp; = \frac {n!}{k_1!k_2! \cdots k_5!} p_1^{k_1} p_2^{k_2} \cdotsp_5^{k_5}     \tag{6.2.2} \label{6.2.2}\end{align}\]</span></p><p>观察上式可知，所求概率为多项式 <span class="math inline">\(\left (p_1+ p_2 + p_3 + p_4 + p_5 \right )^{n}\)</span> 的 <span class="math inline">\(p_1^{k_1} p_2^{k_2} \cdots p_5^{k_5}\)</span>​项，<span class="math inline">\(\binom {n}{k_1, k_2, \cdots ,k_5}\)</span> 为其系数。</p><p>和问题 <span class="math inline">\(1\)</span>的共轭表达式类似，我们给不同福卡添加符号位，考虑如下求和表达式：</p><p><span class="math display">\[S_{2n} = \frac{1}{2^{5}} \sum_{\beta_{i} = \pm 1} \left (\beta_{1} p_{1}+ \beta_{2} p_{2} +\cdots + \beta_{5} p_{5}\right)^{2n}       \tag{6.2.3} \label{6.2.3}\]</span></p><p>对上式进行多项式展开，可得：</p><p><span class="math display">\[\begin{aligned}S_{2n} &amp; = \frac{1}{2^{5}} \sum_{\substack {\beta_{i} = \pm 1 \\x_{1} + x_{2} + \cdots + x_{5} = 2n}} \frac{(2n)!}{x_{1}!x_{2}! \cdotsx_{5}!} \beta{1}^{x_{1}} \beta_{2}^{x_{2}} \cdots \beta_{5}^{x_{5}}p_{1}^{x_{1}} p_{2}^{x_{2}} \cdots p_{5}^{x_{5}} \\&amp; = \frac{1}{2^{5}} \sum_{x_{1} + x_{2} + \cdots + x_{5} = 2n}\frac{(2n)!}{x_{1}!x_{2}! \cdots x_{5}!} p_{1}^{x_{1}} p_{2}^{x_{2}}\cdots p_{5}^{x_{5}} \sum_{\beta_{i} = \pm 1} \beta_{1}^{x_{1}}\beta_{2}^{x_{2}} \cdots \beta_{5}^{x_{5}}\end{aligned}\]</span></p><p>考虑 <span class="math inline">\(\sum _{\substack {\beta_{i} = \pm 1\\x_{1} + x_{2} + \cdots + x_{5} = 2n}} \beta_{1}^{x_{1}}\beta_{2}^{x_{2}} \cdots \beta_{5}^{x_{5}}\)</span> ，如果存在 $k $ 使得<span class="math inline">\(x_{k}\)</span>为<strong>奇数</strong>的话，那么：</p><p><span class="math display">\[\sum_{\beta_{i} = \pm 1} \beta_{1}^{x_{1}} \beta_{2}^{x_{2}} \cdots\beta_{5}^{x_{5}} = \sum_{\substack {\beta_{i}= \pm 1 \\ i \neq k}}\left[\left (1^{x_{k}} + (-1)^{x_{k}} \right) \prod_ {i \neq k}\beta_{i}^{x_{i}} \right ]=0\]</span></p><p>由于<strong>奇数项</strong>最终都会消去，只有偶数项 <span class="math inline">\(x_{i}\)</span> 才会留下来，故有：</p><p><span class="math display">\[\sum_{\beta_{i} = \pm 1} \beta_{1}^{x_{1}} \beta_{2}^{x_{2}} \cdots\beta_{k}^{x_{k}} = 2^{k}\]</span></p><p>那么求和表达式为：</p><p><span class="math display">\[\begin{aligned}S_{2n} &amp; = \sum_{\substack{x_{1} + x_{2} + \cdots + x_{k} = 2 n \\x_{i} \text { is even }}} \frac{(2 n)!}{x_{1}!x_{2}! \cdots x_{k}!}p_{1}^{x_{1}} p_{2}^{x_{2}} \cdots p_{k}^{x_{k}} \\&amp; = \operatorname{Pr} \left \{ X_{2 n}^{(i)} \text { is all even }\right\}\end{aligned}\]</span></p><p>因此，所求问题转化为在 <span class="math inline">\(X_{2n}^{(i)}\)</span> 均为偶数情况下，当 $n $ 时，其极限为：</p><p><span class="math display">\[\lim _{n \to \infty} \operatorname{Pr}\left \{X_{2 n}^{(i)} \text { isall even } \right\} = \lim _{n \to \infty} S_{2 n}\]</span></p><p>因为 <span class="math inline">\(\left | \beta_{1} p_{1} + \beta_{2}p_{2} + \cdots + \beta_{5} p_{5} \right | \leq 1\)</span> , 所以当 <span class="math inline">\(n \to \infty\)</span> 时，只有 <span class="math inline">\(\beta_i\)</span> 全为 <span class="math inline">\(1\)</span> 或者 <span class="math inline">\(-1\)</span> 情况下，</p><p><span class="math display">\[\left | \sum_{i=1}^{5} \beta_{i} p_{i} \right | = 1\]</span></p><p>因此，我们可以得到答案：</p><p><span class="math display">\[\lim _{n \to \infty} \operatorname{Pr} \left \{X_{2n}^{(i)} \text { isall even } \right \} = \frac{1}{2^{5}} \left [ (+1)^{2n} + (-1)^{2n}\right ] = \frac{1}{16}\]</span></p><h1 id="problem-7">Problem 7</h1><p>有这么一个音乐盒，它上面有一个圆形的轨道，轨道上的一点处还有一棵开花的树。当音乐盒处于开启模式时，音乐盒会发出音乐，轨道会按照顺时针匀速转动。</p><p>你可以在轨道上放置象征恋人的两颗棋子，我们不妨称它们为小红和小绿。当小红和小绿没有到达树下时，它们就会在轨道上各自移动。当某一颗棋子到达树下时，它就会在树下原地等待一段时间。此段时间内，如果另外一颗棋子也达到了树下，那么两颗棋子就会相遇，之后在它们将随即一起顺着轨道移动，不再分开；否则，等待时间结束，两颗棋子将各自顺着轨道继续移动。</p><p>考虑这个音乐盒的数学模型。我们把这个圆形轨道参数化成一个周长为 <span class="math inline">\(1\)</span>的圆环，我们认为棋子和树都可以用圆环上点表示。具体来说，我们用 <span class="math inline">\(X(t) \in [0, 1]\)</span> 和 <span class="math inline">\(Y(t) \in [0, 1]\)</span> 分别表示 <span class="math inline">\(t\)</span>时刻小红和小绿的在轨道上的位置坐标，而树的坐标是 <span class="math inline">\(\phi = 1\)</span> ，或者，等价地， <span class="math inline">\(\phi = 0\)</span> 。</p><p>当他们都没有抵达树下时 (见左图) ，他们的位置变化规律满足</p><p><span class="math display">\[\frac{\mathrm{d}}{\mathrm{d} t} X(t)=1, \quad\frac{\mathrm{d}}{\mathrm{d} t} Y(t) = 1\]</span></p><p>假设在 <span class="math inline">\(t_0\)</span>时刻，小绿到达了树下（见中图），即 <span class="math inline">\(Y \left(t_0 \right) = 1\)</span> ，它就会至多等待</p><p><span class="math display">\[\tau = K \left (X \left( t_0 \right ) \right)\]</span></p><p>的时间，换句话说，最长等待时间依赖于小红的当时的位置。</p><p>在等待期间，小绿不动，小红继续移动。如果等待期间的某时刻 <span class="math inline">\(t^\ast \in \left(t_0, t_0+\tau\right]\)</span>，小红也达到了树下，即 <span class="math inline">\(X\left (t^\ast\right) = 1\)</span>，那么两棋子相遇。如果等待时间结束时（见右图），小红仍没有到达树下，那么它们俩继续移动，此时他们的位置分别是</p><p><span class="math display">\[X \left(t_0 + \tau \right) = X \left(t_0 \right) + \tau, \quad Y\left(t_0 + \tau \right) = 0 .\]</span></p><p>注意，虽然小绿的坐标被重置了，但是它在圆环上的位置并没有变。</p><p>如果在某时刻小红到达树下，它也会按照相同的规则等待，最长等待时间取决于此时小绿的位置。显然，小红小绿的命运取决于最长等待时间函数<span class="math inline">\(K(\phi)\)</span> 的形式。</p><figure><img src="https://www.longluo.me/assets/blog/images/math/2024-alibaba-math-contest-problem7.png" alt="图2. Problem 7"><figcaption aria-hidden="true">图2. Problem 7</figcaption></figure><ol type="1"><li><strong>证明题 (10分)</strong> 我们设 <span class="math inline">\(f:\mathbb{R} \to \mathbb{R}\)</span> 是一个光滑函数， 满足</li></ol><p><span class="math display">\[f^{\prime} &gt; 0, \quad f^{\prime \prime} &lt; 0, \quad f(0)=0, \quadf(1) = 1 .\]</span></p><p>并设 <span class="math inline">\(\varepsilon\)</span>是一个充分小的正的常数。我们定义等待时间函数</p><p><span class="math display">\[K(\phi ) = f^{-1}(f(\phi ) + \epsilon ) - \phi .\]</span></p><p>证明除了唯一的例外（特定的初始距离）之外，无论小红和小绿的初始距离如何，他们最终会相遇的。</p><ol start="2" type="1"><li><strong>问答题 (10分)</strong> 我们考虑一个如下形式的 <span class="math inline">\(f\)</span> 函数</li></ol><p><span class="math display">\[f(\phi ) = \frac {1}{b} \ln \left (1 + \left (e^b - 1 \right ) \phi\right )\]</span></p><p>这里 <span class="math inline">\(b&gt;0\)</span> 是一个常数。当 <span class="math inline">\(b \ll 1, \varepsilon \ll 1\)</span>时，请估算出相遇之前小红小绿走过的圈数的数量级。</p><h2 id="solution-8">Solution</h2><blockquote><p>[!TIP] 这道题考试的时候没做出来，最近几天看了知乎上关于这次考试的讨论<a href="https://www.zhihu.com/question/652949289">如何评价2024阿里巴巴数学竞赛预选赛试题?</a>，看了大神们的解答，发现这道题不难，不要以为它是压轴题就觉得很难。这道题的关键在于找到小红和小绿的距离递推关系式，然后对这个关系式进行分析。下面的解法参考了知乎Fiddie 的解答<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> ，<a href="https://www.zhihu.com/people/s7gp3x">喵喵</a> 的解答<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>，我综合他们的解题思路自己推了一遍。</p></blockquote><p>由题设条件，我们知道当小红和小绿都没有在树下时，都随着圆形轨道顺时针匀速转动，也因此小红和小绿<strong>只可能</strong>在树下相遇。</p><p>不妨设<strong>最初条件</strong>为小红在小绿的前方，两者的距离为 <span class="math inline">\(d_0, \ d_0 \in (0, 1)\)</span> ， <span class="math inline">\(d_0 \le 0\)</span> 或 <span class="math inline">\(d_0 \ge 1\)</span> 两者相遇无需讨论。</p><p>当小红来到树下，此时小绿距离树下还有一段距离，小红将在树下等待一段时间。假设在小红等待时间结束之前，小绿都没能赶到树下，那么在等待时间结束时，记为<span class="math inline">\(t_{k}\)</span> 时刻。在 <span class="math inline">\(t_{k}\)</span> 时小绿距离树下还有 <span class="math inline">\(d_k\)</span> 的距离，即 <span class="math inline">\(X(t_k) = 0, \ Y(t_k) = 1 - d_k\)</span> 。</p><p>小红继续出发，在 <span class="math inline">\(d_k\)</span> 时之后，即<span class="math inline">\(t_k + d_k\)</span>时小绿将到达树下。此时小红已经出发了 <span class="math inline">\(d_k\)</span> 的距离，即 <span class="math inline">\(X(t_k) = d_k, \ Y(t_k) = 1\)</span> 。</p><p>小绿将在树下等待小红 <span class="math inline">\(\tau = K \left (X\left (d_{k} \right ) \right )\)</span> 的时间，即：</p><p><span class="math display">\[\begin{equation}\tau = K \left (X \left (d_{k} \right ) \right ) = f^{-1}(f(d_k) +\varepsilon) - d_k   \tag{7.1.1} \label{7.1.1}\end{equation}\]</span></p><p>分析 <span class="math inline">\(\eqref{7.1.1}\)</span> 可知：</p><ol type="1"><li><p>如果 <span class="math inline">\(f^{-1}(f(d_k) + \varepsilon) \ge1\)</span>，则小红将在等待时间结束之前到达树下，小红和小绿相遇，结束分析。</p></li><li><p>如果 <span class="math inline">\(f^{-1}(f(d_k) + \varepsilon)&lt; 1\)</span>，那么在小绿等待时间结束之前，小红没能赶到树下。</p></li></ol><p>在小绿等待时间结束那一刻，我们记为 <span class="math inline">\(t_{k+1}\)</span> 时刻，此时 <span class="math inline">\(X(t_{k+1}) = f^{-1}(f(d_k) + \varepsilon), \Y(t_{k+1}) = 0\)</span> ，两者距离为：</p><p><span class="math display">\[\begin{equation}d_{k+1} = 1 - f^{-1}(f(d_k) + \varepsilon)    \tag{7.1.2} \label{7.1.2}\end{equation}\]</span></p><p>至此我们找到了小红与小绿之间的<strong>距离递推关系式</strong>。</p><p>设两者之间<strong>距离数列</strong> ${ d_n } $表示一个人刚要从树下出发，另外一个距离树下的距离，那么问题转化为：对于任意初值<span class="math inline">\(d_0 \in (0, 1)\)</span>，除了某个特定的初始距离值之外，都存在某个 <span class="math inline">\(k\in \mathrm{Z^+}\)</span> ，使得数列 <span class="math inline">\(d_k \le0\)</span> 或者 <span class="math inline">\(d_k \ge 1\)</span> 。</p><p>这里我们需要证明 <span class="math inline">\(2\)</span> 种情况：</p><ol type="1"><li>存在某个特定的初始距离，使得小红和小绿永远不相遇；</li><li>除了某个特定的初始距离之外，小红和小绿总会相遇。</li></ol><p>考虑函数 <span class="math inline">\(g(x)\)</span>表示两者之间距离，函数 <span class="math inline">\(h(x)\)</span>表示前后时刻（ <span class="math inline">\(t_{k}\)</span> 和 <span class="math inline">\(t_{k+1}\)</span>）两者之间的<strong>距离变化</strong>，即 <span class="math inline">\(\Delta d = d_{k+1} - d_k = 1 - f^{-1}(f(d_k) +\varepsilon) - d_k\)</span> 。</p><p>则有：</p><p><span class="math display">\[\begin{equation}g(x) = 1 - f^{-1}(f(x) + \varepsilon) , \ x \in (0, 1)     \tag{7.1.3}\label{7.1.3}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}h(x) = g(x) - x = 1 - f^{-1}(f(x) + \varepsilon) - x     \tag{7.1.4}\label{7.1.4}\end{equation}\]</span></p><p>对 <span class="math inline">\(g(x) , \ h(x)\)</span> 求导可得：</p><p><span class="math display">\[\begin{equation}g^{\prime}(x) = \frac{\mathrm{d} g(x)}{\mathrm{d} x} = -\frac{f^{\prime}(x)} {f^{\prime}\left(f^{-1}(f(x) +\varepsilon)\right)}  \tag{7.1.5} \label{7.1.5}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}h^{\prime}(x) = \frac{\mathrm{d} h(x)}{\mathrm{d} x} = -1 -\frac{f^{\prime}(x)} {f^{\prime}\left(f^{-1}(f(x) +\varepsilon)\right)}  \tag{7.1.6} \label{7.1.6}\end{equation}\]</span></p><p>因为 <span class="math inline">\(f^{\prime}&gt;0 , f^{\prime \prime}&lt; 0\)</span> ，所以 <span class="math inline">\((f^{-1})^{\prime}&gt;0\)</span> , <span class="math inline">\(\left(f^{-1}\right)^{\prime \prime}&gt;0\)</span>，</p><p>又 <span class="math inline">\(h(0) = 1 - f^{-1}(\varepsilon) &gt;0\)</span> ， <span class="math inline">\(h(1) = - f^{-1}(f(1) +\varepsilon) &lt; 0\)</span> ，所以 <span class="math inline">\(h(x)\)</span> 在</p><p>针对第 <span class="math inline">\(1\)</span>种情况，需要证明：<strong>存在性</strong>和<strong>唯一性</strong>。</p><p>设距离数列 ${ d_n } $ 存在某个初值 <span class="math inline">\(d_0 =d^\ast\)</span> 满足公式 <span class="math inline">\(\eqref{7.1.2}\)</span> 使得 <span class="math inline">\(d_k = d^\ast , k = 0, 1, \cdots , n\)</span>，所以：</p><p><span class="math display">\[\begin{equation}d_{k+1} = d_k \Leftrightarrow d^\ast = 1 - f^{-1} \left (f(d^\ast) +\varepsilon \right )  \end{equation}\]</span></p><p>进一步化简可得：</p><p><span class="math display">\[\begin{equation}f(1 - d^\ast) = f(d^\ast) + \varepsilon         \end{equation}\]</span></p><p>设 <span class="math inline">\(x_1 = d^\ast, \ x_2 = 1 -d^\ast\)</span> ，那么 <span class="math inline">\(x_1, \ x_2\)</span>关于 <span class="math inline">\(\frac{1}{2}\)</span> 对称，那么存在<span class="math inline">\(x_1 = \frac{1}{2} - \varepsilon^\ast ，x_2 =\frac{1}{2} + \varepsilon^\ast, \ \varepsilon^\ast &gt; 0\)</span>。</p><p>根据题设条件 <span class="math inline">\(f^{\prime} &gt; 0\)</span>， <span class="math inline">\(f(0) = 0, \ f(1) = 1\)</span> ， <span class="math inline">\(f\)</span> 在 <span class="math inline">\([0,1]\)</span> 是<strong>单调递增</strong>的光滑函数，那么 <span class="math inline">\(f(x_2) &gt; f(x_1) &gt; 0\)</span>，故<strong>存在性</strong>得证。</p><p>下面来证明<strong>唯一性</strong>，由公式 <span class="math inline">\(\eqref{7.1.5}\)</span> ，可得： <span class="math inline">\(f(1 - d^\ast) - f(d^\ast) = \varepsilon\)</span>。</p><p>令函数 <span class="math inline">\(g(x) = f(1 - x) - f(x), \ x \in(0,1)\)</span> ，对 <span class="math inline">\(g(x)\)</span> 求导：</p><p><span class="math display">\[\begin{equation}g^{\prime}(x) = - f^{\prime}(1 - x) - f^{\prime}(x) &lt; 0 , \ x \in(0,1)      \end{equation}\]</span></p><p><span class="math inline">\(g(x)\)</span> 单调递减， <span class="math inline">\(g(0) = 1, \ g(\frac{1}{2}) = 0\)</span> ，<span class="math inline">\(g(x)\)</span>连续，故<strong>有且仅存在一个</strong> <span class="math inline">\(x\in (0, \frac{1}{2})\)</span> ，使得 <span class="math inline">\(g(x) =\varepsilon\)</span> ，所以<strong>唯一性</strong>得证。</p><p>故存在某个特定的初始距离 <span class="math inline">\(d_0 =d^\ast\)</span> ，使得小红和小绿永远不相遇。</p><p>下面来证明 <span class="math inline">\(d_0 \ne d^\ast\)</span>的情况，这里也可以分为 <span class="math inline">\(2\)</span>种情况讨论，<span class="math inline">\(0 &lt; d_0 &lt; d^\ast\)</span>和 <span class="math inline">\(d^\ast &lt; d_0 &lt; 1\)</span> 。</p><p><span class="math display">\[\phi_{n+1}=g\left(g\left(\phi_n\right)\right)=1-\left(g\left(\phi_n\right)+K\left(g\left(\phi_n\right)\right)\right)=\phi_n+K\left(\phi_n\right)-K\left(g\left(\phi_n\right)\right)&lt;\phi_n\]</span> , also <span class="math inline">\(g\left(\phi_{n+1}\right)&gt;g\left(\phi_n\right)\)</span>.Then</p><p><span class="math display">\[\phi_{n+1}-\phi_{n+2}=K\left(g\left(\phi_{n+1}\right)\right)-K\left(\phi_{n+1}\right)&gt;K\left(g\left(\phi_n\right)\right)-K\left(\phi_n\right)=\phi_n-\phi_{n+1}\]</span></p><p>, showing that</p><p><span class="math display">\[d_k = d_0 - (d_0 - d_1) - (d_1 - d_2) - \cdots - (d_{k-1} - d_k) \leqd_0 - k(d_0 - d_1)\]</span></p><p>故所求上界 <span class="math inline">\(k = \left \lceil\frac{d_0}{d_0 - d_1} \right \rceil\)</span> ，使得 <span class="math inline">\(d_k \leq 0\)</span> ，小红和小绿终将相遇。</p><p><span class="math display">\[d_k = d_0 + (d_0 - d_1) + (d_1 - d_2) + \cdots + (d_{k-1} - d_k) \ge d_0+ k(d_0 - d_1)\]</span></p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Poisson_point_process">泊松过程</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://en.wikipedia.org/wiki/Poisson_distribution">泊松分布</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Binomial_distribution">二项分布</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Binomial_theorem">二项式定理</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Multinomial_theorem">多项式定理</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://www.zhihu.com/question/652949289/answer/3466235067">Fiddie的试题解答</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://zhuanlan.zhihu.com/p/692476253">喵喵的试题解答</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://damo.alibaba.com/?language=zh&quot;&gt;阿里巴巴达摩院&lt;/a&gt; 从
2018
年开始每年都会举办一届全球数学竞赛，之前一方面自己数学水平比较弱，另外一方面也没有报名，但一直很仰慕那些数学大神的风采。今年是第一次报名参加
&lt;a href=&quot;https://damo.alibaba.com/alibaba-global-mathematics-competition?language=zh&quot;&gt;2024阿里巴巴全球数学竞赛&lt;/a&gt;
，上周末参加了预选赛，但遗憾的是，全部 &lt;span class=&quot;math inline&quot;&gt;&#92;(7&#92;)&lt;/span&gt; 道题中只有第 &lt;span class=&quot;math inline&quot;&gt;&#92;(1, 2, 6&#92;)&lt;/span&gt; 题会做，这里分享下我的解答：&lt;/p&gt;
&lt;h1 id=&quot;problem-1&quot;&gt;Problem 1&lt;/h1&gt;
&lt;p&gt;几位同学假期组成一个小组去某市旅游. 该市有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 座塔，它们的位置分别为 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D, E, F&#92;)&lt;/span&gt;
。同学们自由行动一段时间后，每位同学都发现，自己在所在的位置只能看到位于
&lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D&#92;)&lt;/span&gt; 处的四座塔，而看不到位于
&lt;span class=&quot;math inline&quot;&gt;&#92;(E&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; 的塔。已知：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;同学们的位置和塔的位置均视为同一平面上的点，且这些点彼此不重合；&lt;/li&gt;
&lt;li&gt;塔中任意 &lt;span class=&quot;math inline&quot;&gt;&#92;(3&#92;)&lt;/span&gt; 点不共线；&lt;/li&gt;
&lt;li&gt;看不到塔的唯一可能就是视线被其它的塔所阻挡，例如，如果某位同学所在的位置
&lt;span class=&quot;math inline&quot;&gt;&#92;(P&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;(A
, B&#92;)&lt;/span&gt; 共线，且 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; 在线段
&lt;span class=&quot;math inline&quot;&gt;&#92;(PB&#92;)&lt;/span&gt; 上，那么该同学就看不到位于 &lt;span class=&quot;math inline&quot;&gt;&#92;(B&#92;)&lt;/span&gt; 处的塔。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;（5 分）&lt;/strong&gt; 请问 这个旅游小组最多可能有多少名同学？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(A. 3&#92;)&lt;/span&gt;&lt;br&gt;
&lt;span class=&quot;math inline&quot;&gt;&#92;(B. 4&#92;)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;&#92;(C.
6&#92;)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;&#92;(D. 12&#92;)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;这道题选 &lt;span class=&quot;math inline&quot;&gt;&#92;(C&#92;)&lt;/span&gt; ，最多只能有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 名同学。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP] 这道题的解题思路是，从假设只有 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 座塔开始，一直到 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 座塔，找到思路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; ，那么很显然有无数多同学可以看到塔
&lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; ，也可以有无数多同学看不到塔
&lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt;​ ；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B&#92;)&lt;/span&gt; ，那么只有以 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; 为起点的射线 &lt;span class=&quot;math inline&quot;&gt;&#92;(AB&#92;)&lt;/span&gt; 且位于 &lt;span class=&quot;math inline&quot;&gt;&#92;(B&#92;)&lt;/span&gt; 之后的同学无法看到塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; ；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(3&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C&#92;)&lt;/span&gt;
，同理可知存在无数位同学至少可以看见 &lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 座塔；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(4&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D&#92;)&lt;/span&gt;
，同理可知存在无数位同学至少可以看见 &lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 座塔；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D, E, F&#92;)&lt;/span&gt; ，如果每位同学都无法看见
&lt;span class=&quot;math inline&quot;&gt;&#92;(E, F&#92;)&lt;/span&gt; 塔，如下图1 所示：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/math/2024-alibaba-math-contest-problem1-solution.png&quot; alt=&quot;图1. Solution of Problem 1&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图1. Solution of Problem 1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;所以至多有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 位同学位于 &lt;span class=&quot;math inline&quot;&gt;&#92;(M, N, O, P, R, Q&#92;)&lt;/span&gt; 处，无法看到塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(E, F&#92;)&lt;/span&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Geometry" scheme="https://www.longluo.me/tags/Geometry/"/>
    
    <category term="Algebra" scheme="https://www.longluo.me/tags/Algebra/"/>
    
    <category term="Probability" scheme="https://www.longluo.me/tags/Probability/"/>
    
    <category term="Analysis" scheme="https://www.longluo.me/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>库函数 (libm) 是如何计算三角函数值的？</title>
    <link href="https://www.longluo.me/blog/2024/02/16/sine/"/>
    <id>https://www.longluo.me/blog/2024/02/16/sine/</id>
    <published>2024-02-16T12:32:58.000Z</published>
    <updated>2024-03-04T13:16:46.732Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑！</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the trigonometric sine of an angle.  Special cases:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the</span></span><br><span class="line"><span class="comment"> * result is NaN.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;If the argument is zero, then the result is a zero with the</span></span><br><span class="line"><span class="comment"> * same sign as the argument.&lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The computed result must be within 1 ulp of the exact result.</span></span><br><span class="line"><span class="comment"> * Results must be semi-monotonic.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   a   an angle, in radians.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the sine of the argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> a)</span> {</span><br><span class="line">    <span class="keyword">return</span> StrictMath.sin(a); <span class="comment">// default impl. delegates to StrictMath</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the trigonometric sine of an angle. Special cases:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the</span></span><br><span class="line"><span class="comment"> * result is NaN.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;If the argument is zero, then the result is a zero with the</span></span><br><span class="line"><span class="comment"> * same sign as the argument.&lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   a   an angle, in radians.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the sine of the argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> a)</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @(#)k_sin.c 1.3 95/01/18 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ====================================================</span></span><br><span class="line"><span class="comment"> * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Developed at SunSoft, a Sun Microsystems, Inc. business.</span></span><br><span class="line"><span class="comment"> * Permission to use, copy, modify, and distribute this</span></span><br><span class="line"><span class="comment"> * software is freely granted, provided that this notice</span></span><br><span class="line"><span class="comment"> * is preserved.</span></span><br><span class="line"><span class="comment"> * ====================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* __kernel_sin( x, y, iy)</span></span><br><span class="line"><span class="comment"> * kernel sin function on [-pi/4, pi/4], pi/4 ~ 0.7854</span></span><br><span class="line"><span class="comment"> * Input x is assumed to be bounded by ~pi/4 in magnitude.</span></span><br><span class="line"><span class="comment"> * Input y is the tail of x.</span></span><br><span class="line"><span class="comment"> * Input iy indicates whether y is 0. (if iy=0, y assume to be 0). </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Algorithm</span></span><br><span class="line"><span class="comment"> *1. Since sin(-x) = -sin(x), we need only to consider positive x. </span></span><br><span class="line"><span class="comment"> *2. if x &lt; 2^-27 (hx&lt;0x3e400000 0), return x with inexact if x!=0.</span></span><br><span class="line"><span class="comment"> *3. sin(x) is approximated by a polynomial of degree 13 on</span></span><br><span class="line"><span class="comment"> *   [0,pi/4]</span></span><br><span class="line"><span class="comment"> *           3            13</span></span><br><span class="line"><span class="comment"> *   sin(x) ~ x + S1*x + ... + S6*x</span></span><br><span class="line"><span class="comment"> *   where</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * |sin(x)         2     4     6     8     10     12  |     -58</span></span><br><span class="line"><span class="comment"> * |----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| &lt;= 2</span></span><br><span class="line"><span class="comment"> * |  x            | </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *4. sin(x+y) = sin(x) + sin'(x')*y</span></span><br><span class="line"><span class="comment"> *    ~ sin(x) + (1-x*x/2)*y</span></span><br><span class="line"><span class="comment"> *   For better accuracy, let </span></span><br><span class="line"><span class="comment"> *     3      2      2      2      2</span></span><br><span class="line"><span class="comment"> *r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))</span></span><br><span class="line"><span class="comment"> *   then                   3    2</span></span><br><span class="line"><span class="comment"> *sin(x) = x + (S1*x + (x *(r-y/2)+y))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FDLIBM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fdlibm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> __kernel_sin(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">int</span> iy)</span><br><span class="line">{</span><br><span class="line"><span class="type">double</span> z, r, v;</span><br><span class="line"><span class="type">int32_t</span> ix;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> half = <span class="number">5.00000000000000000000e-01</span>;<span class="comment">/* 0x3FE00000, 0x00000000 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S1 = <span class="number">-1.66666666666666324348e-01</span>;<span class="comment">/* 0xBFC55555, 0x55555549 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S2 = <span class="number">8.33333333332248946124e-03</span>;<span class="comment">/* 0x3F811111, 0x1110F8A6 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S3 = <span class="number">-1.98412698298579493134e-04</span>;<span class="comment">/* 0xBF2A01A0, 0x19C161D5 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S4 = <span class="number">2.75573137070700676789e-06</span>;<span class="comment">/* 0x3EC71DE3, 0x57B1FE7D */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S5 = <span class="number">-2.50507602534068634195e-08</span>;<span class="comment">/* 0xBE5AE5E6, 0x8A2B9CEB */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S6 = <span class="number">1.58969099521155010221e-10</span>;<span class="comment">/* 0x3DE5D93A, 0x5ACFD57C */</span></span><br><span class="line"></span><br><span class="line">GET_HIGH_WORD(ix, x);</span><br><span class="line">ix &amp;= IC(<span class="number">0x7fffffff</span>);<span class="comment">/* high word of x */</span></span><br><span class="line"><span class="keyword">if</span> (ix &lt; IC(<span class="number">0x3e400000</span>))<span class="comment">/* |x| &lt; 2**-27 */</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int32_t</span>) x == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x;<span class="comment">/* generate inexact */</span></span><br><span class="line">}</span><br><span class="line">z = x * x;</span><br><span class="line">v = z * x;</span><br><span class="line">r = S2 + z * (S3 + z * (S4 + z * (S5 + z * S6)));</span><br><span class="line"><span class="keyword">if</span> (iy == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x + v * (S1 + z * r);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> x - ((z * (half * y - v * r) - y) - v * S1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="math display">\[\sin (x_0 + \Delta x) \approx \sin (x_0) + \sin'(x_0) \frac {\Deltax}{1!} + \sin''(x_0) \frac { \Delta x^2}{2!} +\sin'''(x_0) \frac {\Delta x^3}{3!} + \cdots\]</span></p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/C_mathematical_functions">Cmathematical functions</a></li><li><a href="https://en.wikipedia.org/wiki/Sine_and_cosine">Sine andcosine</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑！&lt;/h1&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>payne hanek 归约算法</title>
    <link href="https://www.longluo.me/blog/2024/01/22/payne-hanek/"/>
    <id>https://www.longluo.me/blog/2024/01/22/payne-hanek/</id>
    <published>2024-01-22T13:10:50.000Z</published>
    <updated>2024-02-25T12:34:22.666Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/582590074">CodyWaite和Payne-Hanek归约算法的详细解释</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.c</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Argument Reduction" scheme="https://www.longluo.me/tags/Argument-Reduction/"/>
    
    <category term="Computer Arithmetic" scheme="https://www.longluo.me/tags/Computer-Arithmetic/"/>
    
    <category term="参数归约" scheme="https://www.longluo.me/tags/%E5%8F%82%E6%95%B0%E5%BD%92%E7%BA%A6/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
    <category term="Trigonometric" scheme="https://www.longluo.me/tags/Trigonometric/"/>
    
  </entry>
  
  <entry>
    <title>音乐背后的数学</title>
    <link href="https://www.longluo.me/blog/2024/01/12/the-math-of-music/"/>
    <id>https://www.longluo.me/blog/2024/01/12/the-math-of-music/</id>
    <published>2024-01-12T11:18:38.000Z</published>
    <updated>2024-03-11T13:10:24.222Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="声音是什么">声音是什么？</h1><h1 id="什么是和弦">什么是和弦？</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://plus.maths.org/content/magical-mathematics-music">Themagical mathematics of music</a></li><li><a href="https://mp.weixin.qq.com/s/KxePYsQY7sHDnFnaZjP6lA">北大王杰教授：用数学分析动人音乐的奥秘（上）</a></li><li><a href="https://mp.weixin.qq.com/s/BrwDDcIWEXqmCKnq63duvg">北大王杰教授：用数学分析动人音乐的奥秘（下）</a></li><li><a href="https://www.numericana.com/answer/music.htm">MathematicalAspects of Music</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;声音是什么&quot;&gt;声音是什么？&lt;/h1&gt;
&lt;h1 id=&quot;什么是和弦&quot;&gt;什么是和弦？&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Music" scheme="https://www.longluo.me/tags/Music/"/>
    
  </entry>
  
  <entry>
    <title>素描背后的物理</title>
    <link href="https://www.longluo.me/blog/2023/12/30/the-physics-behind-drawings/"/>
    <id>https://www.longluo.me/blog/2023/12/30/the-physics-behind-drawings/</id>
    <published>2023-12-30T14:53:51.000Z</published>
    <updated>2024-03-11T13:15:42.116Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Light">Light</a></li><li><a href="https://en.wikipedia.org/wiki/Diffuse_reflection">Diffusereflection</a></li><li><a href="https://en.wikipedia.org/wiki/Reflection_(physics)">Reflection(physics)</a></li><li><a href="https://en.wikipedia.org/wiki/Bloom_(shader_effect)">Bloom(shader effect)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    <category term="Physics" scheme="https://www.longluo.me/categories/Physics/"/>
    
    
    <category term="Physics" scheme="https://www.longluo.me/tags/Physics/"/>
    
  </entry>
  
  <entry>
    <title>cody waite</title>
    <link href="https://www.longluo.me/blog/2023/12/19/cody-waite/"/>
    <id>https://www.longluo.me/blog/2023/12/19/cody-waite/</id>
    <published>2023-12-19T12:10:19.000Z</published>
    <updated>2024-02-25T12:34:30.747Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/582590074">CodyWaite和Payne-Hanek归约算法的详细解释</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.c</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Argument Reduction" scheme="https://www.longluo.me/tags/Argument-Reduction/"/>
    
    <category term="Computer Arithmetic" scheme="https://www.longluo.me/tags/Computer-Arithmetic/"/>
    
    <category term="参数归约" scheme="https://www.longluo.me/tags/%E5%8F%82%E6%95%B0%E5%BD%92%E7%BA%A6/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
    <category term="Trigonometric" scheme="https://www.longluo.me/tags/Trigonometric/"/>
    
  </entry>
  
  <entry>
    <title>浮点数</title>
    <link href="https://www.longluo.me/blog/2023/12/03/floating-point/"/>
    <id>https://www.longluo.me/blog/2023/12/03/floating-point/</id>
    <published>2023-12-03T14:12:45.000Z</published>
    <updated>2024-05-24T13:17:21.065Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><p>假如你知道浮点数的话，你就知道为什么了！</p><p>按照 IEEE 754 浮点数标准 制定的 浮点数运算法则， float类型的单精度浮点数 的尾数部分有 <span class="math inline">\(\large{23}\)</span> 位二进制数，如下图所示：</p><figure><img src="http://www.longluo.me/assets/blog/images/floating_point/ieee_754_single_floating_point_format.svg" alt="IEEE_754_Single_Floating_Point_Format"><figcaption aria-hidden="true">IEEE_754_Single_Floating_Point_Format</figcaption></figure><p>在十进制下，大致相当于 <span class="math inline">\(\large{\log_{10}{2^{23}} = 23 \cdot \log {2} \approx 23 \times 0.301 \approx6.9}\)</span> ，有效数字大约有 <span class="math inline">\(\large{7}\)</span> 位。</p><p>所以当 <span class="math inline">\(\large {x = 1000001}\)</span>时，我们应该使用 double 类型的双精度浮点数 [^12]，这样才能保证结果有<strong>足够的精度</strong>！</p><p>双精度浮点数的尾数部分有 <span class="math inline">\(\large{52}\)</span> 位，如下图所示：</p><figure><img src="http://www.longluo.me/assets/blog/images/floating_point/ieee_754_double_floating_point_format.svg" alt="IEEE_754_Double_Floating_Point_Format"><figcaption aria-hidden="true">IEEE_754_Double_Floating_Point_Format</figcaption></figure><p>在十进制中大致相当于 <span class="math inline">\(\large{\log_{10}{2^{52}} = 52 \cdot \log {2} \approx 52 \times 0.301 \approx15.6}\)</span> ，也就是说当 <span class="math inline">\(\large{x}\)</span> 有效数字是 <span class="math inline">\(\large {[7,15]}\)</span> 时，我们应该使用 double类型的双精度浮点数可以保证精度！</p><p>但这仍然有个问题，那就是 <span class="math inline">\(\large{x}\)</span> 有效数字 超过 <span class="math inline">\(\large{15}\)</span> 位，应该怎么办？</p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li><li><a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">Floating-pointarithmetic</a></li><li><a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">Single-precisionfloating-point format</a></li><li><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">Double-precisionfloating-point format</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;p&gt;假如你知道浮点数的话，你就知道为什么了！&lt;/p&gt;
&lt;p&gt;按照 IEEE 754 浮点数标准 制定的 浮点数运算法则， float
类型的单精度浮</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Remez Algorithm</title>
    <link href="https://www.longluo.me/blog/2023/10/07/remez-algorithm/"/>
    <id>https://www.longluo.me/blog/2023/10/07/remez-algorithm/</id>
    <published>2023-10-06T23:08:37.000Z</published>
    <updated>2024-03-11T13:17:35.339Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Remez_algorithm">Remezalgorithm</a></li><li><a href="https://mathworld.wolfram.com/RemezAlgorithm.html">RemezAlgorithm</a></li><li><a href="https://blog.csdn.net/m0_66201040/article/details/123955780">8.2雷米兹算法</a></li><li><a href="https://valelab4.ucsf.edu/svn/3rdpartypublic/boost/libs/math/doc/sf_and_dist/html/math_toolkit/backgrounders/remez.html">TheRemez Method</a></li><li><a href="https://en.wikipedia.org/wiki/Geometric_series">Geometricseries</a></li><li><a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomialcoefficient</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Calculus" scheme="https://www.longluo.me/tags/Calculus/"/>
    
    <category term="Taylor Series" scheme="https://www.longluo.me/tags/Taylor-Series/"/>
    
  </entry>
  
  <entry>
    <title>参数归约算法(Argument Range Reduction)：如何在浮点数环境下计算超大数字的三角函数值？</title>
    <link href="https://www.longluo.me/blog/2023/09/16/argument-range-reduction/"/>
    <id>https://www.longluo.me/blog/2023/09/16/argument-range-reduction/</id>
    <published>2023-09-16T14:05:07.000Z</published>
    <updated>2024-03-03T07:57:11.759Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>之前写过一篇介绍 CORDIC 算法 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 的文章，里面提到 CORDIC算法的 <a href="http://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/#cordic-%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%8D%E8%B6%B3"><strong>不足</strong></a>之处，CORDIC 算法的输入角度范围需要在 <span class="math inline">\([−99.88^{\circ} , 99.88^{\circ}]\)</span>，那么我们不禁要问，如果输入角度 <span class="math inline">\(\large{\theta }\)</span> 很大的话，怎么处理呢？</p><p>这个问题同样存在于 泰勒展开式(Taylor series) <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>中，比如 <span class="math inline">\(\large {\sin (x) }\)</span> 和<span class="math inline">\(\large {\cos (x) }\)</span>的泰勒展开式：</p><p><span class="math display">\[\sin(x) = x - \frac {1}{3!}x^3 + \frac {1}{5!}x^5 - \frac {1}{7!} x^7 +\frac {1}{9!} x^9 + o(x^9) \quad \forall x \subset \mathbb{R}\]</span></p><p><span class="math display">\[\cos(x) = 1 - \frac {1}{2!}x^2 + \frac {1}{4!}x^4 - \frac {1}{6!} x^6 +\frac {1}{8!} x^8 + o(x^8) \quad \forall x \subset \mathbb{R}\]</span></p><p>虽然在整个实数集 <span class="math inline">\(\large {\mathbb{R}}\)</span>都成立，但是在实际应用中因为展开项数限制和浮点数的精度限制， <span class="math inline">\(\large {x}\)</span> 的范围只有在接近 <span class="math inline">\(\large {0}\)</span> 的时候才有比较高的精度。</p><p>但是实际应用中，如果输入 <span class="math inline">\(\large{x}\)</span> 很大的话，比如 <span class="math inline">\(\large {2^{32},10^{10}, 10^{22} \dots }\)</span> 情况下怎么得到足够精确的值呢？</p><p>中学里我们知道三角函数是<strong>周期函数</strong>，对于比较大的值，我们可以使用下面的公式将值<strong>归约</strong>到一个比较小的范围内。</p><p><span class="math display">\[x' = x - 2k \pi \quad k \subset \mathbb{Z}\]</span></p><p>这就是我们今天要讲的 <strong>参数归约(Argument Reduction)</strong>算法。</p><h1 id="从小学计算题开始">从小学计算题开始</h1><p><strong>参数归约</strong>听起来就很唬人，什么是参数啊，什么归约啊，都是些高大上的名词，听起来云里雾里的！</p><p>为了不让大家产生厌倦和畏难心理，我们先从一道小学数学计算题开始：</p><p>不借助计算器，计算 <span class="math inline">\(\large {66600 \times666000}\)</span> 的值！</p><p>对于这道题，大家可能会列出下列算术：</p><p><span class="math display">\[66600 \times 666000 = 666 \times 666 \times 100000 = 44355600000\]</span></p><p>但其实呢，我们也可以使用下面的方法：</p><p><span class="math display">\[\begin{aligned}66600 \times 666000 &amp;= 111^2 \times 4 \times 9 \times 10^5\\&amp;= 444 \times 999 \times 10^5\\&amp;= 444 \times (1000 - 1) \times 10^5\\&amp;= 4443556 \times 10^5    \end{aligned}\]</span></p><p>如果我说上面这 <span class="math inline">\(\large {2}\)</span>种方法都用到了<strong>参数归约</strong>的思想，你可能会感到震惊，什么？这种小学计算题也用到了参数归约算法吗？</p><span id="more"></span><h1 id="什么是参数归约-argument-reduction">什么是参数归约 ArgumentReduction ？</h1><p>上一章计算 <span class="math inline">\(\large {66600 \times666000}\)</span> 时，我们将 <span class="math inline">\(\large {666\times 666}\)</span> 化简为 <span class="math inline">\(\large {444\times (1000 - 1)}\)</span> ，再在结果后面直接加上 <span class="math inline">\(\large {5}\)</span> 个 <span class="math inline">\(\large {0}\)</span>，那么你有没有想过这背后隐含了什么数学思想吗？</p><p>下面我们正式进入今天的课题：<strong>参数归约(ArgumentReduction)</strong> 。</p><p>为了提高数学函数的计算效率，将初始问题转变或者说缩小到函数更容易计算的域内，这就是参数归约。</p><p>已知函数 <span class="math inline">\(\large {f}\)</span> ，求 <span class="math inline">\(\large {y = f(x)}\)</span> 的值，可以通过以下<span class="math inline">\(\large {3}\)</span> 个步骤进行计算：</p><ol type="1"><li>将 <span class="math inline">\(\large {x}\)</span> 转换为缩小的参数<span class="math inline">\(\large {x'}\)</span> ；</li><li>计算 <span class="math inline">\(\large {y' =f(x')}\)</span> ；</li><li>使用函数恒等式从 <span class="math inline">\(\large{f(x')}\)</span> 计算出 <span class="math inline">\(\large{f(x)}\)</span> 。</li></ol><p>现在回到上一节的小学数学计算题，我们实际上用到了 <span class="math inline">\(\large {2}\)</span> 种参数归约：</p><ol type="1"><li>指数/对数 运算公式</li></ol><p><span class="math display">\[exp(x + y) = \exp(x) \exp(y)\]</span></p><p><span class="math display">\[\log (xy) = \log (x) + \log (y)\]</span></p><ol start="2" type="1"><li>相加公式。不过上面小学数学题用的非常简单的分配律和结合律，实际上我们用的更复杂的公式，比如各种三角恒等式：</li></ol><p><span class="math display">\[\sin (x + y) = \sin(x) \cos (y) + \cos (x) \sin (y)\]</span></p><p><span class="math display">\[\tan (x + y) = \frac {\tan (x) + \tan (y)}{1 - \tan (x) \tan (y)}\]</span></p><p>实际上为了让幂级数更快地收敛，通常我们取 <span class="math inline">\(\large {x = y}\)</span> 以获得双倍公式，比如 <span class="math inline">\(\large {e^ {2x} = (e^x)^2}\)</span> ，比如快速幂算法(Exponentiation by squaring) <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ,其具体实现可参考这篇文章： <a href="http://www.longluo.me/blog/2022/01/02/Leetcode-powx-n/">Fast PowerAlgorithm: Binary Exponentiation</a> 。</p><p>而计算器中也常用到三倍角公式 <span class="math inline">\(\large {\sin(3x) = 3 \sin (x) - 4 \sin ^3(x)}\)</span>去计算三角函数值，具体可参考这个视频： <a href="https://www.bilibili.com/video/BV1AW4y1A7HN">计算器是如何计算出三角函数和对数的？</a>。</p><p>可能有同学会问，那二倍角公式 <span class="math inline">\(\large {\sin(2x) = 2 \sin(x) \cos (x)}\)</span>就不用了吗？这个谜底待后续章节介绍。</p><h1 id="如何对参数进行归约">如何对参数进行归约？</h1><p>这一章我们来讲如何进行参数归约，通常我们区分 <span class="math inline">\(\large {2}\)</span> 种参数归约：</p><ol type="1"><li>加法参数归约： <span class="math inline">\(\large {x' = x -kC}\)</span> ，其中 <span class="math inline">\(\large {C}\)</span>是实常数， <span class="math inline">\(\large {k}\)</span> 是整数。</li></ol><p>这种归约可以应用在 <span class="math inline">\(\large {f(x)}\)</span>是周期函数的情况，比如三角函数，此时 <span class="math inline">\(\large{C = 2 \pi}\)</span> ；也可以应用于其他函数，比如小学数学我们知道计算<span class="math inline">\(\large { \frac {a}{b}}\)</span>就是看有多少个 <span class="math inline">\(\large {b}\)</span>相加小于等于 <span class="math inline">\(\large {a}\)</span>，具体可参考这篇文章：<a href="http://www.longluo.me/blog/2022/05/30/leetcode-divide-two-integers-en/">29.Divide Two Integers</a> 。</p><ol start="2" type="1"><li>乘法参数归约：<span class="math inline">\(\large {x' =\frac{x}{kC}}\)</span>，其中 <span class="math inline">\(\large{C}\)</span> 是实常数， <span class="math inline">\(\large {k}\)</span>是整数。</li></ol><p>应用于计算指数函数 <span class="math inline">\(\large {\exp(x)}\)</span> 时，其中 <span class="math inline">\(\large {C =2}\)</span> 。</p><p>值得注意的是，对于给定的函数，两种参数归约方式都可能使用。例如，对于<span class="math inline">\(\large {\sin (x) }\)</span>，我们既可以使用三倍角公式 <span class="math inline">\(\large {\sin (3x)= 3 \sin (x) - 4 \sin^3 (x)}\)</span> 化简，也可以使用加法归约 <span class="math inline">\(\large {\sin (x + 2 k \pi) = \sin (x)}\)</span>。</p><h1 id="数值分析-numerical-analysis">数值分析 Numerical Analysis</h1><p>通过上面的分析，现在让我们去计算任意输入 <span class="math inline">\(\large {x}\)</span> 的 <span class="math inline">\(\large { \sin (x)}\)</span> 、 <span class="math inline">\(\large {\cos (x)}\)</span> 的值，可以分为下面<span class="math inline">\(\large {2}\)</span> 种情况：</p><ol type="1"><li><span class="math inline">\(\large {0 &lt; x \leq \frac{\pi}{2}}\)</span> ，使用泰勒展开或者 CORDIC 算法；</li><li><span class="math inline">\(\large {x &gt; \frac {\pi}{2}}\)</span>，先将 <span class="math inline">\(\large {x}\)</span> 归约到 <span class="math inline">\(\large {x' = x + k \frac {\pi}{2}}\)</span>，再回到第一步计算。</li></ol><p>听起来似乎很简单，但事实上远远没有这么容易！</p><p>我们的电脑是基于 <strong>二进制(Binary)</strong> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>的，本质只是高电平和低电平在电路上切换运行而已。因为 CPU 种的逻辑运算单元(Arithmetic logic unit) <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>只能做加法和移位操作，因此而诞生了 计算机算术(Computer Arithmetic) <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> 这门学科！</p><p>数学中有一门学科 数值分析(Numerical Analysis) <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>就是专门研究各种计算的！</p><p>虽然三角函数的周棋是 <span class="math inline">\(\large {2\pi}\)</span> ，但实际上我们只用归约到 <span class="math inline">\(\large {[-\frac {\pi}{4},\frac {\pi}{4}]}\)</span>即可，这里大家可以想想为什么？</p><p>之前我以为数值运算对于 <span class="math inline">\(\large {[-\frac{\pi}{2},\frac {\pi}{2}]}\)</span> 的参数，会使用 CORDIC算法，但实际上我看了一些数值计算库，发现对于 <span class="math inline">\(\large {[-\frac {\pi}{2},\frac {\pi}{2}]}\)</span>还是使用泰勒(Taylor Series) <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>逼近，当然里面用了很多技巧，大家可以看看库函数的具体实现即可解惑（这里先挖个坑，等我彻底看懂了再来这里填坑！）。</p><p>那对于 <span class="math inline">\(\large {x &gt; \frac{\pi}{2}}\)</span> ，如何计算呢？</p><h1 id="cody-waite-归约算法">Cody-Waite 归约算法</h1><p>我们可以使用下列公式将 <span class="math inline">\(\large{x}\)</span> 归约到 <span class="math inline">\(\large {[-\frac{\pi}{4},\frac {\pi}{4}]}\)</span> ：</p><p><span class="math display">\[x' = x - \lfloor  \frac {x}{\frac {\pi}{2}} \rfloor \times \frac{\pi}{2}\]</span></p><p>我们可以很容易按照上述思想写出对应的代码，这就是 Cody &amp; Waite提出的 Cody-Waite 归约算法<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> 。</p><p>但是如果你认为这样就高枕无忧了的话，就太早了！</p><p>假如输入 <span class="math inline">\(\large {x = 1000001}\)</span>的话，上面的方法就会失效！想一想为什么？</p><h1 id="payne-hanek-归约算法">Payne-Hanek 归约算法</h1><p>上一章提出了一个问题，有效数字 超过 <span class="math inline">\(\large {15}\)</span>位的超大数字该如何计算呢？针对这个问题， Payne 与 Hanek <a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>提出把浮点运算转换为大整数运算，来解决超大数字的浮点数归约问题。</p><p>要弄懂 Payne-Hanek归约算法，需要对数学有比较深的理解，下面一步一步来分析！</p><p>对于输入 <span class="math inline">\(\large {x}\)</span> ：</p><p><span class="math display">\[x = k \cdot (\frac {\pi}{2}) + r \quad k \subset \mathbb{Z}, r \subset[-\frac {\pi}{4},\frac {\pi}{4}]\]</span></p><p>两边同乘 <span class="math inline">\(\large {\frac{2}{\pi }}\)</span>，可得：</p><p><span class="math display">\[x \cdot ( \frac{2}{\pi }) = k + r \cdot (\frac{2}{\pi })\]</span></p><p>因为 <span class="math inline">\(\left| r \right | \leq \frac{\pi}{4}\)</span> ， <span class="math inline">\(r \cdot (\frac {2}{\pi}) \leq 0.5\)</span> ，也就是说：</p><p><span class="math display">\[y = x \cdot (\frac {2}{\pi })\]</span></p><p>即：</p><p><span class="math display">\[k = \left \lfloor y \right \rfloor\]</span></p><p>那么所求浮点数的尾数部分：</p><p><span class="math display">\[f = y − k\]</span></p><p>最终可得到归约之后的结果 <span class="math inline">\(\large{r}\)</span> ：</p><p><span class="math display">\[r = f \cdot (\frac {\pi }{2})\]</span></p><p>回到我们的目标，我们需要知道 <span class="math inline">\(\large{k}\)</span> 的值 和 <span class="math inline">\(\large {r}\)</span>的值！</p><p>那我们能直接用上述公式计算吗？</p><p>我们知道 <span class="math inline">\(\large {\pi}\)</span>是超越数，是无法用二进制表示的，在计算机里只能去近似。我们最终要求得的三角函数的误差取决于下面几个方面：</p><ol type="1"><li>使用多少位数的 <span class="math inline">\(\large {\pi}\)</span>近似值；</li><li>参数归约时产生的误差；</li><li>计算参数归约之后的三角函数时的误差。</li></ol><p>对于输入参数 <span class="math inline">\(\large {x}\)</span>不是很大的情况，误差主要由参数归约时产生的误差决定，而当输入参数 <span class="math inline">\(\large {x}\)</span>很大的情况，参数归约产生的误差就不再是主要因素了！</p><h2 id="计算-large-k">计算 <span class="math inline">\(\large{k}\)</span></h2><p>由之前的推导，我们知道：</p><p><span class="math display">\[k = \left \lfloor y \right \rfloor = x \cdot (\frac {2}{\pi })\]</span></p><p>但是由于浮点数的精度限制，我们知道对于 <span class="math inline">\(\large {x}\)</span>很大情况，我们不能直接去计算！</p><p>由三角函数关系可知，我们实际上只需要计算 <span class="math inline">\(\large {k \% 4}\)</span>的值即可，也就是说只需要知道 <span class="math inline">\(\large{k}\)</span> 的最后 <span class="math inline">\(\large {2}\)</span> 个二进制位值即可，这样就可以节省大量运算了！</p><p>让我们回到 浮点数标准 <a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> ，以 <span class="math inline">\(\large {32}\)</span>位单精度浮点数为例，其值可以表示为：</p><p><span class="math display">\[x = (-1)^{b_{31}} \times 2^{(b_{30}b_{29}\dots b_{23})_{2} - 127} \times(1.b_{22}b_{21}\dots b_{0})_{2}\]</span></p><p>即为：</p><p><span class="math display">\[\text {value} = (-1)^{\text {sign}} \times 2^{(E - 127)} \times \left (1+ \sum _{i=1}^{23}b_{23-i} 2^{-i} \right)\]</span></p><p>(原始论文和数值分析具体实现代码太难看懂了，这篇文章写了快 1个月了！:-( )</p><h1 id="小结">小结</h1><p>这是目前我对<strong>参数归约(Argument Reduction)</strong>算法的理解，后续有新的发现、感悟都会更新此文章。</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="http://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/">CORDIC算法：一种高效计算三角函数值的方法</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="http://www.longluo.me/blog/2023/04/26/Taylor-Series/">泰勒展开式(Taylorseries)</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">Exponentiationby squaring</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Binary_number">Binary number</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">Arithmeticlogic unit</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://zh.wikipedia.org/wiki/Category:%E8%A8%88%E7%AE%97%E6%A9%9F%E7%AE%97%E8%A1%93">计算机算术</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://en.wikipedia.org/wiki/Numerical_analysis">NumericalAnalysis</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p><a href="http://www.longluo.me/blog/2023/04/26/Taylor-Series/">泰勒展开式(Taylorseries)</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn9"><p>W. Cody and W. Waite, Software Manual for the ElementaryFunctions, Prentice-Hall, Englewood Cliffs, N.J., 1980.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn10"><p><a href="https://dl.acm.org/doi/pdf/10.1145/1057600.1057602">M. Payne andR. Hanek, “Radian Reduction for Trigonometric Functions”, Signum,p19-24, Jan 1983.</a><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn11"><p><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE754</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前写过一篇介绍 CORDIC 算法 &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 的文章，里面提到 CORDIC
算法的 &lt;a href=&quot;http://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/#cordic-%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%8D%E8%B6%B3&quot;&gt;&lt;strong&gt;不足&lt;/strong&gt;&lt;/a&gt;
之处，CORDIC 算法的输入角度范围需要在 &lt;span class=&quot;math inline&quot;&gt;&#92;([−99.88^{&#92;circ} , 99.88^{&#92;circ}]&#92;)&lt;/span&gt;
，那么我们不禁要问，如果输入角度 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large
{&#92;theta }&#92;)&lt;/span&gt; 很大的话，怎么处理呢？&lt;/p&gt;
&lt;p&gt;这个问题同样存在于 泰勒展开式(Taylor series) &lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;
中，比如 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {&#92;sin (x) }&#92;)&lt;/span&gt; 和
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {&#92;cos (x) }&#92;)&lt;/span&gt;
的泰勒展开式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sin(x) = x - &#92;frac {1}{3!}x^3 + &#92;frac {1}{5!}x^5 - &#92;frac {1}{7!} x^7 +
&#92;frac {1}{9!} x^9 + o(x^9) &#92;quad &#92;forall x &#92;subset &#92;mathbb{R}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;cos(x) = 1 - &#92;frac {1}{2!}x^2 + &#92;frac {1}{4!}x^4 - &#92;frac {1}{6!} x^6 +
&#92;frac {1}{8!} x^8 + o(x^8) &#92;quad &#92;forall x &#92;subset &#92;mathbb{R}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然在整个实数集 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {
&#92;mathbb{R}}&#92;)&lt;/span&gt;
都成立，但是在实际应用中因为展开项数限制和浮点数的精度限制， &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {x}&#92;)&lt;/span&gt; 的范围只有在接近 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {0}&#92;)&lt;/span&gt; 的时候才有比较高的精度。&lt;/p&gt;
&lt;p&gt;但是实际应用中，如果输入 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large
{x}&#92;)&lt;/span&gt; 很大的话，比如 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {2^{32},
10^{10}, 10^{22} &#92;dots }&#92;)&lt;/span&gt; 情况下怎么得到足够精确的值呢？&lt;/p&gt;
&lt;p&gt;中学里我们知道三角函数是&lt;strong&gt;周期函数&lt;/strong&gt;，对于比较大的值，我们可以使用下面的公式将值&lt;strong&gt;归约&lt;/strong&gt;到一个比较小的范围内。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
x&#39; = x - 2k &#92;pi &#92;quad k &#92;subset &#92;mathbb{Z}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这就是我们今天要讲的 &lt;strong&gt;参数归约(Argument Reduction)&lt;/strong&gt;
算法。&lt;/p&gt;
&lt;h1 id=&quot;从小学计算题开始&quot;&gt;从小学计算题开始&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;参数归约&lt;/strong&gt;
听起来就很唬人，什么是参数啊，什么归约啊，都是些高大上的名词，听起来云里雾里的！&lt;/p&gt;
&lt;p&gt;为了不让大家产生厌倦和畏难心理，我们先从一道小学数学计算题开始：&lt;/p&gt;
&lt;p&gt;不借助计算器，计算 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {66600 &#92;times
666000}&#92;)&lt;/span&gt; 的值！&lt;/p&gt;
&lt;p&gt;对于这道题，大家可能会列出下列算术：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
66600 &#92;times 666000 = 666 &#92;times 666 &#92;times 100000 = 44355600000
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但其实呢，我们也可以使用下面的方法：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
66600 &#92;times 666000 &amp;amp;= 111^2 &#92;times 4 &#92;times 9 &#92;times 10^5
&#92;&#92;&amp;amp;= 444 &#92;times 999 &#92;times 10^5
&#92;&#92;&amp;amp;= 444 &#92;times (1000 - 1) &#92;times 10^5
&#92;&#92;&amp;amp;= 4443556 &#92;times 10^5    
&#92;end{aligned}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果我说上面这 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {2}&#92;)&lt;/span&gt;
种方法都用到了&lt;strong&gt;参数归约&lt;/strong&gt;的思想，你可能会感到震惊，什么？这种小学计算题也用到了参数归约算法吗？&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Argument Reduction" scheme="https://www.longluo.me/tags/Argument-Reduction/"/>
    
    <category term="Computer Arithmetic" scheme="https://www.longluo.me/tags/Computer-Arithmetic/"/>
    
    <category term="参数归约" scheme="https://www.longluo.me/tags/%E5%8F%82%E6%95%B0%E5%BD%92%E7%BA%A6/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
    <category term="Trigonometric" scheme="https://www.longluo.me/tags/Trigonometric/"/>
    
  </entry>
  
  <entry>
    <title>素描背后的数学</title>
    <link href="https://www.longluo.me/blog/2023/08/02/perspective/"/>
    <id>https://www.longluo.me/blog/2023/08/02/perspective/</id>
    <published>2023-08-02T11:15:11.000Z</published>
    <updated>2024-03-11T13:16:44.086Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Sketch_(drawing)">Sketch(drawing)</a></li><li><a href="https://en.wikipedia.org/wiki/Projective_geometry">Projectivegeometry</a></li><li><a href="https://zh.wikipedia.org/zh-cn/%E9%98%BF%E5%B0%94%E5%B8%83%E9%9B%B7%E5%B8%8C%E7%89%B9%C2%B7%E4%B8%A2%E5%8B%92">阿尔布雷希特·丢勒</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%98%82%C2%B7%E5%B7%B4%E8%92%82%E6%96%AF%E5%A1%94%C2%B7%E9%98%BF%E5%B0%94%E4%BC%AF%E8%92%82">莱昂·巴蒂斯塔·阿尔伯蒂</a></li><li><a href="https://book.douban.com/subject/25662171/">论绘画</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Art" scheme="https://www.longluo.me/tags/Art/"/>
    
    <category term="Sketch" scheme="https://www.longluo.me/tags/Sketch/"/>
    
  </entry>
  
  <entry>
    <title>发生在计算机内存里的进化：解密遗传算法(Genetic Algorithm)</title>
    <link href="https://www.longluo.me/blog/2023/06/12/genetic-algorithm/"/>
    <id>https://www.longluo.me/blog/2023/06/12/genetic-algorithm/</id>
    <published>2023-06-12T00:32:31.000Z</published>
    <updated>2023-11-14T14:24:40.448Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="这篇文章部分内容还在优化demo-还在继续开发大概还需要-7---8-小时写作时间">这篇文章部分内容还在优化，Demo还在继续开发，大概还需要 7 - 8 小时写作时间。</h1><p>无限猴子定理（英语：Infinite monkey theorem）</p><p>让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。</p><p>在这里，几乎必然是一个有特定含义的数学术语，“猴子”也不是一只真正意义上的猴子，它被用来比喻成一个可以产生无限随机字母序列的抽象设备。这个理论说明把一个很大但有限的数看成无限的推论是错误的。猴子精确地通过键盘敲打出一部完整的作品比如说莎士比亚的哈姆雷特，在宇宙的生命周期中发生的概率也是极其低的，但并不是零。</p><p>遗传算法(Genetic Algorithm) <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>是一种元启发式搜索和优化技术，借鉴了生物进化中的自然选择和遗传机制。它已经在各个领域展示出了强大的应用潜力。本文将介绍遗传算法的发展历史、原理、示例，以及其广泛应用和不足之处。</p><h1 id="发展历史">发展历史</h1><p>遗传算法的发展可以追溯到上世纪60年代的约翰·荷兰德（JohnHolland）和他的同事们的工作。他们首先提出了基因型与表现型之间的映射关系，并通过模拟生物进化过程来解决复杂的优化问题。</p><h1 id="原理">原理</h1><p>遗传算法的核心原理是模拟自然进化的过程。它通过定义适应度函数来评估候选解的质量，并利用遗传操作（选择、交叉和变异）对候选解进行迭代改进。具体而言，算法从一个初始种群开始，通过选择适应度较高的个体作为父代，进行交叉和变异操作产生新的后代个体，然后通过评估适应度来选择出下一代个体。这个过程不断迭代，直到找到满足特定条件的优秀解。</p><p>It’s never too late</p><h1 id="举个例子">举个例子</h1><p>目前参考网络资源写了一个简单的Demo，地址：http://longluo.me/projects/genetic</p><p>这个例子还有待完善！</p><p><a href="http://longluo.me/projects/genetic"><img src="https://user-images.githubusercontent.com/3395062/247012809-febec500-50dd-4d52-a6f6-d5b86aba4132.png" alt="Genetic Algorithm"></a></p><span id="more"></span><h1 id="应用领域">应用领域</h1><p>遗传算法在各个领域都有广泛的应用。它被用于优化问题、机器学习、数据挖掘、调度问题等。例如，在工程设计中，可以使用遗传算法来优化设计参数，以获得更好的性能。在人工智能领域，遗传算法被用于训练神经网络的参数。</p><h1 id="todos">ToDos</h1><ul><li>利用遗传算法优化 <a href="http://www.longluo.me/blog/2023/05/05/pid/">PID</a> ，自动调谐 PID参数，目前开发中…</li><li>利用遗传算法应用于 <a href="http://www.longluo.me/blog/2023/03/03/Neutral-Network/">机器学习</a>，目前还在开发中…</li></ul><h1 id="缺点">缺点</h1><p>遗传算法在应用中存在一些缺点，但可以采取一些方法来规避这些问题。以下是一些常见的遗传算法缺点及其应对措施的例子：</p><p>可能陷入局部最优解：由于遗传算法的随机性质，可能导致算法收敛到局部最优解而无法达到全局最优解。为了规避这个问题，可以采用以下方法：</p><p>多次运行算法：运行遗传算法的多个独立实例，以增加搜索空间的探索性。引入多样性维护机制：通过保留一部分较差个体、增加变异操作的概率或引入新的个体，以增加种群的多样性，避免过早陷入局部最优解。计算复杂度高：遗传算法需要进行大量的计算和评估操作，导致计算复杂度较高。为了降低计算成本，可以尝试以下方法：</p><p>优化评估函数：通过对评估函数进行优化，减少计算成本。使用近似算法：在某些情况下，可以使用近似算法或启发式方法来加速计算过程，以减少计算复杂度。参数选择困难：遗传算法中的参数选择对算法的性能和效果至关重要。不正确的参数选择可能导致算法效果不佳。为了解决这个问题，可以采取以下措施：</p><p>参数调优：通过实验和测试，调整算法的参数，以找到最佳的参数组合。自适应参数调整：引入自适应机制，根据问题的特性和算法的表现，动态调整参数值。举例来说，假设有一个优化问题，需要找到一个函数的最小值。遗传算法被用来解决这个问题，但在初步运行中发现算法很容易陷入局部最优解。为了规避这个问题，可以采取多次运行算法的方法，每次使用不同的初始种群和随机数种子，以增加搜索空间的覆盖度，从而更有可能找到全局最优解。</p><p>另外，遗传算法在每一代选择操作时都会考虑适应度函数的评估，这可能导致计算复杂度的增加。为了降低计算成本，可以对适应度函数进行优化，使用更高效的算法或数据结构进行计算。同时，可以利用并行计算或分布式计算的方法，提高算法的计算效率。</p><p>总之，通过合理的方法和技巧，可以规避遗传算法的一些缺点，并提高算法的效率和性能。根据具体的问题和应用场景，选择适当的策略和方法来克服遗传算法的局限性。</p><h1 id="总结">总结</h1><p>综上所述，遗传算法作为一种强大的优化技术，在解决复杂问题和优化搜索中具有广泛的应用。通过模拟生物进化的机制，它能够发现优秀的解决方案。然而，它也面临局部最优解和计算复杂度高的挑战。随着计算能力和算法改进的不断提升，遗传算法在未来将继续发挥重要作用，并为各个领域的问题提供创新解决方案。</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/George_Gamow">George Gamow</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;这篇文章部分内容还在优化demo-还在继续开发大概还需要-7---8-小时写作时间&quot;&gt;这篇文章部分内容还在优化，Demo
还在继续开发，大概还需要 7 - 8 小时写作时间。&lt;/h1&gt;
&lt;p&gt;无限猴子定理（英语：Infinite monkey theorem）&lt;/p&gt;
&lt;p&gt;让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。&lt;/p&gt;
&lt;p&gt;在这里，几乎必然是一个有特定含义的数学术语，“猴子”也不是一只真正意义上的猴子，它被用来比喻成一个可以产生无限随机字母序列的抽象设备。这个理论说明把一个很大但有限的数看成无限的推论是错误的。猴子精确地通过键盘敲打出一部完整的作品比如说莎士比亚的哈姆雷特，在宇宙的生命周期中发生的概率也是极其低的，但并不是零。&lt;/p&gt;
&lt;p&gt;遗传算法(Genetic Algorithm) &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;
是一种元启发式搜索和优化技术，借鉴了生物进化中的自然选择和遗传机制。它已经在各个领域展示出了强大的应用潜力。本文将介绍遗传算法的发展历史、原理、示例，以及其广泛应用和不足之处。&lt;/p&gt;
&lt;h1 id=&quot;发展历史&quot;&gt;发展历史&lt;/h1&gt;
&lt;p&gt;遗传算法的发展可以追溯到上世纪60年代的约翰·荷兰德（John
Holland）和他的同事们的工作。他们首先提出了基因型与表现型之间的映射关系，并通过模拟生物进化过程来解决复杂的优化问题。&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;&gt;原理&lt;/h1&gt;
&lt;p&gt;遗传算法的核心原理是模拟自然进化的过程。它通过定义适应度函数来评估候选解的质量，并利用遗传操作（选择、交叉和变异）对候选解进行迭代改进。具体而言，算法从一个初始种群开始，通过选择适应度较高的个体作为父代，进行交叉和变异操作产生新的后代个体，然后通过评估适应度来选择出下一代个体。这个过程不断迭代，直到找到满足特定条件的优秀解。&lt;/p&gt;
&lt;p&gt;It’s never too late&lt;/p&gt;
&lt;h1 id=&quot;举个例子&quot;&gt;举个例子&lt;/h1&gt;
&lt;p&gt;目前参考网络资源写了一个简单的Demo，地址：http://longluo.me/projects/genetic&lt;/p&gt;
&lt;p&gt;这个例子还有待完善！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://longluo.me/projects/genetic&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3395062/247012809-febec500-50dd-4d52-a6f6-d5b86aba4132.png&quot; alt=&quot;Genetic Algorithm&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Genetic Algorithm" scheme="https://www.longluo.me/tags/Genetic-Algorithm/"/>
    
    <category term="AI" scheme="https://www.longluo.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>CORDIC算法：一种高效计算三角函数值的方法</title>
    <link href="https://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/"/>
    <id>https://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/</id>
    <published>2023-06-07T09:11:28.000Z</published>
    <updated>2024-02-25T14:03:27.882Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>任何一款科学计算器上都可以计算三角函数，三角函数应用于生活工作中的方方面面，但计算机是如何计算三角函数值的呢？</p><p>三角函数本质上是直角三角形的3条边的<strong>比例关系</strong>，计算并没有很直观，那么计算机是如何计算三角函数值的呢？</p><p>在微积分中我们学习过 <a href="http://www.longluo.me/blog/2023/04/26/taylor-series/">泰勒公式</a>，我们知道可以使用泰勒展开式来对某个值求得其近似值，例如：</p><p><span class="math display">\[\sin \angle 18^{\circ} = \frac{\sqrt {5} - 1}{4} \approx 0.3090169943\]</span></p><p>利用泰勒公式，取前 <span class="math inline">\(4\)</span> 项：</p><p><span class="math display">\[\sin x \approx x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!}\]</span></p><p>代入可得：</p><p><span class="math display">\[\sin \angle 18^{\circ} = \sin \frac{\pi}{10} = \frac{\pi}{10} -\frac{1}{6} (\frac{\pi}{10})^3 + \frac{1}{120} (\frac{\pi}{10})^5 -\frac{1}{5040} (\frac{\pi}{10})^7 \approx 0.30903399538\]</span></p><p>可见取前 <span class="math inline">\(4\)</span> 项时精度已经在 <span class="math inline">\(10^{-5}\)</span>之下，对于很多场合精度已经<strong>足够高</strong>了。</p><p>在没有了解 CORDIC(Coordinate Rotation Digital Computer) Algorithm <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>算法之前，我一直以为计算器是利用泰勒公式去求解，最近才了解到原来在计算机中，CORDIC算法<strong>远比</strong>泰勒公式高效。</p><p>下面我们就来了解下泰勒公式的不足之处和 CORDIC 算法是怎么做的。</p><h1 id="泰勒公式的缺点">泰勒公式的缺点</h1><p>上一节我们使用泰勒公式去计算三角函数值时，需要做很多次乘法运算，而计算器中乘法运算是很<strong>昂贵</strong>的，其缺点如下所示：</p><ol type="1"><li>展开过小则会导致展开精度不够，展开过大则会导致计算量过大；</li><li>幂运算需要使用乘法器，存在很多重复计算；</li><li>需要很多变量来存储中间值。</li></ol><p>在之前的文章 <a href="http://www.longluo.me/blog/2019/06/21/strassens-matrix-multiplication-algorithm/">矩阵乘法的Strassen 算法</a>，就是通过<strong>减少乘法，多做加法</strong>，从而大大降低了运算量，那么我们可以用相同的思想来优化运算吗？</p><p>当然可以，让我们请出今天的主角：<strong>CORDIC 算法</strong>。</p><span id="more"></span><h1 id="解析-cordic-算法">解析 CORDIC 算法</h1><p>我们知道单位圆上一点 <span class="math inline">\(P\)</span>，其坐标为：<span class="math inline">\((\cos \theta , \sin \theta)\)</span> ，如下图所示：</p><figure><img src="https://user-images.githubusercontent.com/3395062/245137553-974a4579-cf2f-4fc1-84bd-84600da2fad9.svg" alt="Unit Cycle"><figcaption aria-hidden="true">Unit Cycle</figcaption></figure><p>如果我们接收一个旋转向量 <span class="math inline">\(M_{in}\)</span>逆时针旋转 <span class="math inline">\(\theta\)</span> ，将点 <span class="math inline">\(P(x_{in} , y_{in})\)</span> 旋转到 <span class="math inline">\(P'(x_{R} , y_{R})\)</span> , 如下图所示：</p><figure><img src="https://user-images.githubusercontent.com/3395062/245138071-9b15482b-034a-4517-90c7-db8e302865cf.png" alt="CORDIC"><figcaption aria-hidden="true">CORDIC</figcaption></figure><p>很容易得到如下公式：</p><p><span class="math display">\[x_R = x_{in} cos(\theta) - y_{in} sin(\theta)\]</span></p><p><span class="math display">\[y_R = x_{in} sin(\theta) + y_{in} cos(\theta)\]</span></p><p>实际上由 <a href="http://www.longluo.me/blog/2021/12/29/Fourier-transform/">复数运算</a>，我们知道复数乘法就是<strong>幅角相加，模长相乘</strong>。我们可以将上式写成下列<strong>矩阵运算</strong>形式：</p><p><span class="math display">\[\begin{aligned}\begin{bmatrix} x_{R} \\ y_{R} \end{bmatrix} = \begin{bmatrix} \cos(\theta)  &amp; -\sin (\theta) \\ \sin (\theta) &amp; \cos (\theta )\end{bmatrix} \begin{bmatrix} x_{in} \\ y_{in} \end{bmatrix}\end{aligned}\]</span></p><p>但上式运算时，只是对向量 <span class="math inline">\(v_{in} ={\begin{bmatrix} x_{in} \\ y_{in} \end{bmatrix}}\)</span>进行了<strong>线性变换</strong>，乘以一个旋转向量 <span class="math inline">\(M_{in}\)</span> ，得到了旋转后的结果：向量 <span class="math inline">\(v_{R} = {\begin{bmatrix} x_{R} \\ y_{R}\end{bmatrix}}\)</span> 。</p><p>但是上式仍然需要 <span class="math inline">\(4\)</span> 次乘法和<span class="math inline">\(2\)</span> 次加减法操作，复杂度没有任何降低，那怎么办呢？</p><p><strong><em>当当…当！</em></strong></p><p>通过上述分析，我们已经知道可以使用<strong>有限次旋转</strong>操作来避免复杂的乘法操作，我们修改矩阵运算公式，提取<span class="math inline">\(\cos (\theta )\)</span>，则公式可以修改为：</p><p><span class="math display">\[\begin{bmatrix} x_{R} \\ y_{R} \end{bmatrix} = cos(\theta)\begin{bmatrix} 1 &amp; -tan(\theta) \\ tan(\theta) &amp; 1\end{bmatrix} \begin{bmatrix} x_{in} \\ y_{in} \end{bmatrix}\]</span></p><p>如果我们选择合适的角度值 <span class="math inline">\(\theta_i\)</span>，使得</p><p><span class="math display">\[\tan (\theta_{i}) = 2^{-i} \quad i=0, 1,\dots , n\]</span></p><p>这样和 <span class="math inline">\(\tan (\theta_{i})\)</span>乘法操作就变成了<strong>移位</strong>操作，我们知道计算机中<strong>移位</strong>操作是非常快的，就可以大大加快计算速度了。</p><p>但这里仍然有 <span class="math inline">\(3\)</span>个问题需要解决：</p><ol type="1"><li>对于任意角度，可以通过满足条件的角度累加来得到在数学上相同的结果吗？</li><li>每次旋转得到的结果仍然需要乘以 <span class="math inline">\(\cos(\theta )\)</span>，这部分的计算成本如何？如何计算？</li><li>因为每次旋转角度 <span class="math inline">\(\theta =\arctan(2^{-i})\)</span>，朝着目标角度进行旋转时，可能会出现没有超过目标角度的情况，也会存在超过目标角度的情况，这种情况如何解决呢？</li></ol><figure><img src="https://user-images.githubusercontent.com/3395062/245393710-1977d19d-3b0c-451b-8d40-838c64f979a4.png" alt="CORDIC Expand"><figcaption aria-hidden="true">CORDIC Expand</figcaption></figure><p>对于第一个问题，答案是<strong>否定</strong>的。可以从数学上证明只有<span class="math inline">\(\angle 45^{\circ}\)</span>的倍数角才可以得到完全一致的结果。但是在工程应用中，我们只需要满足<strong>一定精度</strong>即可，可以增加迭代次数无限逼近原始角度，如下所示提高<span class="math inline">\(n\)</span> 值以无限逼近原始角度。</p><p><span class="math display">\[\theta_{d} = \sum_{i=0}^{n} \theta_{i} \quad \forall \tan(\theta_{i}) =2^{-i}\]</span></p><p>对于第二个问题，我们先来个例子，以 <span class="math inline">\(57.535^{\circ}\)</span> 为例来看看求解过程：</p><p><span class="math display">\[57.535^{\circ} = 45^{\circ}+26.565^{\circ}-14.03^{\circ}\]</span></p><p>那么第一次旋转：</p><p><span class="math display">\[\begin{bmatrix} x_{0} \\ y_{0} \end{bmatrix} = cos(45^{\circ})\begin{bmatrix} 1 &amp; -1 \\ 1 &amp; 1 \end{bmatrix} \begin{bmatrix}x_{in} \\ y_{in} \end{bmatrix}\]</span></p><p>第二次旋转：</p><p><span class="math display">\[\begin{bmatrix} x_{1} \\ y_{1} \end{bmatrix} = cos(26.565^{\circ})\begin{bmatrix} 1 &amp; -2^{-1} \\ 2^{-1} &amp; 1 \end{bmatrix}\begin{bmatrix} x_{0} \\ y_{0} \end{bmatrix}\]</span></p><p>第三次旋转：</p><p><span class="math display">\[\begin{bmatrix} x_{2} \\ y_{2} \end{bmatrix} = cos(-14.03^{\circ})\begin{bmatrix} 1 &amp; 2^{-2} \\ -2^{-2} &amp; 1 \end{bmatrix}\begin{bmatrix} x_{1} \\ y_{1} \end{bmatrix}\]</span></p><p>综合可得：</p><p><span class="math display">\[\begin{bmatrix} x_{2} \\ y_{2} \end{bmatrix} = cos(45^{\circ})cos(26.565^{\circ}) cos(-14.03^{\circ}) \begin{bmatrix} 1 &amp; -1 \\ 1&amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; -2^{-1} \\ 2^{-1} &amp; 1\end{bmatrix} \begin{bmatrix} 1 &amp; 2^{-2} \\ -2^{-2} &amp; 1\end{bmatrix} \begin{bmatrix} x_{in} \\ y_{in} \end{bmatrix}\]</span></p><p>因为 <span class="math inline">\(\tan (\theta_{i}) = 2^{-i}\)</span>，由三角公式可以计算出：</p><p><span class="math display">\[\cos(\theta_{i}) = \frac {1}{\sqrt {1 + \tan ^{2}(\theta_{i})}} = \frac{1}{\sqrt {1 + 2^{-2i}}}\]</span></p><p>令 <span class="math inline">\(K_i = \cos(\theta_{i})\)</span>，则当进行 <span class="math inline">\(n\)</span> 次迭代之后：</p><p><span class="math display">\[K(n) = \prod _{i=0}^{n-1}K_{i} = \prod _{i=0}^{n-1}{\frac {1}{\sqrt {1 +2^{-2i}}}}\]</span></p><p>当 <span class="math inline">\(\theta_{i}\)</span> 越来越小时， <span class="math inline">\(\cos \theta\)</span> 也越来越逼近 <span class="math inline">\(1\)</span> ，当迭代次数 <span class="math inline">\(n \to \infty\)</span> ， <span class="math inline">\(K(n)\)</span> 极限存在，求解可得：</p><p><span class="math display">\[K = \lim _{n \to \infty }K(n) \approx 0.6072529350088812561694\]</span></p><p>由 <span class="math inline">\(K\)</span>我们实际上可以得到最终的向量 <span class="math inline">\(v_R\)</span>的模长极限为：</p><p><span class="math display">\[A = {\frac {1}{K}} = \lim _{n \to \infty } \prod _{i=0}^{n - 1}{\sqrt {1+ 2^{-2i}}} \approx 1.64676025812107\]</span></p><p>实际上当迭代次数为 <span class="math inline">\(6\)</span>时，可以计算出缩放比例 <span class="math inline">\(K\)</span>，就已经精确到 <span class="math inline">\(0.6072\)</span>了，如下所示：</p><p><span class="math display">\[K \approx cos(45^{\circ}) cos(26.565^{\circ}) \times \dots \timescos(0.895^{\circ}) = 0.6072\]</span></p><p>实际上，任意角度只要迭代次数超过 <span class="math inline">\(6\)</span> ，我们可以直接使用 <span class="math inline">\(K = 0.6072\)</span> 这个值。</p><p>对于第三个问题，稍微有点复杂，我们在下一节继续讲解！</p><h1 id="角度累加">角度累加</h1><p>上一节遗留的问题是迭代旋转角度时，旋转角度不一定会落在目标角度内，我们需要引入一个角度误差，用来衡量旋转角度和目标角之间距离，如下所示：</p><p><span class="math display">\[\theta_{error} = \theta_d - \sum_{i=0}^{n} \theta_{i}\]</span></p><p>当 <span class="math inline">\(\theta_{error} &gt; 0\)</span>时，我们应该逆时针旋转，而 <span class="math inline">\(\theta_{error}&lt; 0\)</span> ，则顺时针旋转。根据精度需要，当 <span class="math inline">\(\left | \theta_{error} \right | \le\epsilon\)</span> 即可退出迭代。</p><p>同时我们修改之前的公式，引入 <span class="math inline">\(\sigma_{i}\in \left \{ +1, -1 \right \}\)</span> ，于是可以得到最终公式：</p><p><span class="math display">\[x \left [ i+1 \right ] = x \left [ i \right ] - \sigma_{i} 2^{-i} y\left [ i \right ]\]</span></p><p><span class="math display">\[y \left [ i+1 \right ] = y \left [ i \right ] + \sigma_{i} 2^{-i} x\left [ i \right ]\]</span></p><p><span class="math display">\[z \left [ i+1 \right ] = z \left [ i \right ] - \sigma_{i} tan^{-1} (2^{-i} )\]</span></p><h1 id="举个例子">举个例子</h1><p>上面讲了这么多，来个实例吧，练习巩固下知识，看看自己是否真的懂了？</p><p>计算 <span class="math inline">\(\sin 70^{\circ}\)</span> 和 <span class="math inline">\(\cos 70^{\circ}\)</span> 的值。</p><p>从 <span class="math inline">\(x_{in}=1, y_{in} = 0\)</span>开始，迭代 <span class="math inline">\(6\)</span> 次结果如下：</p><table><colgroup><col style="width: 14%"><col style="width: 13%"><col style="width: 23%"><col style="width: 23%"><col style="width: 23%"></colgroup><thead><tr class="header"><th style="text-align: center;">第 <span class="math inline">\(i\)</span> 次迭代</th><th><span class="math inline">\(\sigma_{i}\)</span></th><th><span class="math inline">\(x \left[ i \right ]\)</span></th><th><span class="math inline">\(y \left[ i \right ]\)</span></th><th><span class="math inline">\(z \left[ i \right ]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">-</td><td>-</td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(70^{\circ}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(25^{\circ}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(0.5\)</span></td><td><span class="math inline">\(1.5\)</span></td><td><span class="math inline">\(-1.5651^{\circ}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td><span class="math inline">\(-1\)</span></td><td><span class="math inline">\(0.875\)</span></td><td><span class="math inline">\(1.375\)</span></td><td><span class="math inline">\(12.4711^{\circ}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(0.7031\)</span></td><td><span class="math inline">\(1.4844\)</span></td><td><span class="math inline">\(5.3461^{\circ}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(4\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(0.6103\)</span></td><td><span class="math inline">\(1.5283\)</span></td><td><span class="math inline">\(1.7698^{\circ}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(5\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(0.5625\)</span></td><td><span class="math inline">\(1.5474\)</span></td><td><span class="math inline">\(-0.0201^{\circ}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(6\)</span></td><td><span class="math inline">\(-1\)</span></td><td><span class="math inline">\(0.5867\)</span></td><td><span class="math inline">\(1.5386\)</span></td><td><span class="math inline">\(0.8751^{\circ}\)</span></td></tr></tbody></table><p>迭代到第 <span class="math inline">\(6\)</span>次时，角度误差已经小于 <span class="math inline">\(1^{\circ}\)</span>了， 通过表格可知：</p><p><span class="math display">\[x_{R} = 0.6072 \times 0.5867 = 0.3562\]</span></p><p><span class="math display">\[y_{R} = 0.6072 \times 1.5386 = 0.9342\]</span></p><p>通过计算器可知，<span class="math inline">\(\cos(70^{\circ}) =0.34202\)</span> ，<span class="math inline">\(\sin(70^{\circ}) =0.93969\)</span> ，误差已经在 <span class="math inline">\(\frac{1}{100}\)</span> 之下了，实际应用中我们会迭代 <span class="math inline">\(16\)</span>次，误差会<strong>非常小</strong>。</p><h1 id="在线-cordic-算法demo">在线 CORDIC 算法Demo</h1><p>通过上面分析，我们已经知道了 CORDIC算法的原理，下面就开始编程吧！</p><p>用 JavaScript 写了一个在线互动版本，<a href="http://www.longluo.me/projects/cordic/">传送门 →</a> ：</p><ol type="1"><li>可以调整不同迭代次数，和系统库函数 <span class="math inline">\(\textit{Math.cos}\)</span> ，<span class="math inline">\(\textit{Math.sin}\)</span> 进行比较：</li></ol><p><a href="http://www.longluo.me/projects/cordic/"><img src="https://user-images.githubusercontent.com/3395062/245661590-40c39225-cedf-41b1-94c4-25c526557edb.png" alt="Cordic Results"></a></p><ol start="2" type="1"><li>可以查看每次迭代的结果，掌握 Cordic 算法迭代原理：</li></ol><p><a href="http://www.longluo.me/projects/cordic/"><img src="https://user-images.githubusercontent.com/3395062/245661581-1ecbc272-8d70-4d3a-84ba-47c98c1bfacd.png" alt="Cordic Iteration Results"></a></p><h1 id="cordic-算法的优点">CORDIC 算法的优点</h1><p>CORDIC 算法相比其他算法的优点，体现在以下几个方面：</p><ol type="1"><li>简化运算：CORDIC算法主要使用位移、加法和减法等简单的运算，避免了复杂的乘法操作，从而提高了计算速度；</li><li>并行计算：CORDIC算法的迭代操作是相互独立的，可以进行并行计算，利用现代计算机的多核优势，进一步提升计算效率；</li><li>硬件优化：CORDIC算法适用于硬件实现，可以通过专用硬件电路（如FPGA）进行加速，极大地提高计算速度；</li><li>低存储需求：CORDIC算法只需存储一小组预先计算好的旋转角度，节省了存储空间；</li><li>迭代控制：通过控制迭代次数，可以平衡计算精度和计算速度，根据需求进行调整。</li></ol><h1 id="cordic-算法的不足">CORDIC 算法的不足</h1><p>几个月这篇文章发布之后，陆陆续续得到了不少读者的宝贵意见，有读者反馈说没有写CORDIC算法的<strong>缺点</strong>，也有读者反馈在他在嵌入式处理器STM32上还不如<a href="http://www.longluo.me/blog/2023/04/26/Taylor-Series/">泰勒展开式(TaylorSeries)</a> 快。</p><p>对于这 <span class="math inline">\(\large {2}\)</span>个问题，我又查阅了一些 CORDIC 算法<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 的资料，可以回答下这<span class="math inline">\(\large {2}\)</span> 个问题。</p><p>CORDIC 算法的不足之处在于下面几点：</p><h2 id="收敛速度慢">收敛速度慢</h2><p>CORDIC 算法的收敛速度较慢，比如当输入值 <span class="math inline">\(\large {\theta }\)</span> 很接近 <span class="math inline">\(\large {0}\)</span> 或 <span class="math inline">\(\large {\frac {\pi}{2}}\)</span>时，这个时候就需要进行<strong>多轮迭代</strong>才能达到足够的精度。</p><p>当 <span class="math inline">\(\large {\theta \approx 0 }\)</span>时，实际上只需要取前 <span class="math inline">\(\large {2}\)</span>项就有足够精度了，而且收敛速度快多了！</p><p><span class="math display">\[\sin(x) = x - \frac {1}{3!}x^3\]</span></p><p><span class="math display">\[\cos(x) = 1 - \frac {1}{2!}x^2\]</span></p><h2 id="精度">精度</h2><p>如上一小节，当输入值 <span class="math inline">\(\large {\theta}\)</span> 是小角度或者大角度的情况时，CORDIC算法的固定迭代次数可能也无法提供足够的精度。</p><h2 id="输入参数范围">输入参数范围</h2><p>CORDIC 算法在实际应用中需要考虑<strong>输入参数的限制</strong>，特别是幅值和角度范围，这是因为 CORDIC算法是一种<strong>迭代</strong>算法，对于较大的角度，需要更多的迭代次数才能达到所需的精度，从而导致计算效率的下降。</p><p>CORDIC算法适用于处理相对<strong>较小范围</strong>的角度，<strong>确切</strong>来说是在<span class="math inline">\([−99.88^{\circ} , 99.88^{\circ}]\)</span>的范围内表现最佳，下面我们来证明下：</p><p>由 CORDIC 算法计算过程可知：</p><p><span class="math display">\[\left | z[i] \right | \leq \sum_{j=i}^{\infty } \arctan 2^{-j}\]</span></p><p>那么可得：</p><p><span class="math display">\[\theta_{max} = z[0]_{max} = \sum_{j=0}^{\infty } \arctan 2^{-j} \approx1.7429(99.88^{\circ}) \quad \quad \sigma_j = 1, z[j] &gt; 0\]</span></p><p>假设 <span class="math inline">\(\large {\theta &lt;\theta_{max}}\)</span> ， 则有：</p><p><span class="math display">\[\left | z[i] \right | \leq \arctan (2^{−(i−1)})\]</span></p><p>因此</p><p><span class="math display">\[\arctan (2^{−i}) \leq \sum_{j=i+1}^{\infty } \arctan (2^{−j}) \quad\forall i\]</span></p><p>所以 CORDIC算法的输入范围是：<span class="math inline">\([−99.88^{\circ} , 99.88^{\circ}]\)</span> 。</p><h2 id="cordic-算法的fpga实现">CORDIC 算法的FPGA实现</h2><p>对于第 <span class="math inline">\(\large {2}\)</span>个问题，我不太清楚那位读者是如何测试的！如之前所述，在某些情况下，泰勒展开式是<strong>优于</strong>CORDIC 算法的！</p><p>CORDIC 算法是在硬件中实现的，是 FPGA 设计<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>中的经典例题。</p><h1 id="总结">总结</h1><p>CORDIC算法是一种高效计算三角函数值的方法。相比传统的泰勒展开式，它具有简单高效、低存储需求和迭代控制等优势。在需要计算三角函数值的应用中，CORDIC算法更快速、更节省资源。</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/CORDIC">CORDIC</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://en.wikibooks.org/wiki/Digital_Circuits/CORDIC">DigitalCircuits/CORDIC</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://zipcpu.com/dsp/2017/08/30/cordic.html">Using a CORDIC tocalculate sines and cosines in an FPGA</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何一款科学计算器上都可以计算三角函数，三角函数应用于生活工作中的方方面面，但计算机是如何计算三角函数值的呢？&lt;/p&gt;
&lt;p&gt;三角函数本质上是直角三角形的3条边的&lt;strong&gt;比例关系&lt;/strong&gt;，计算并没有很直观，那么计算机是如何计算三角函数值的呢？&lt;/p&gt;
&lt;p&gt;在微积分中我们学习过 &lt;a href=&quot;http://www.longluo.me/blog/2023/04/26/taylor-series/&quot;&gt;泰勒公式&lt;/a&gt;
，我们知道可以使用泰勒展开式来对某个值求得其近似值，例如：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sin &#92;angle 18^{&#92;circ} = &#92;frac{&#92;sqrt {5} - 1}{4} &#92;approx 0.3090169943
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;利用泰勒公式，取前 &lt;span class=&quot;math inline&quot;&gt;&#92;(4&#92;)&lt;/span&gt; 项：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sin x &#92;approx x - &#92;frac{x^3}{3!} + &#92;frac{x^5}{5!} - &#92;frac{x^7}{7!}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代入可得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sin &#92;angle 18^{&#92;circ} = &#92;sin &#92;frac{&#92;pi}{10} = &#92;frac{&#92;pi}{10} -
&#92;frac{1}{6} (&#92;frac{&#92;pi}{10})^3 + &#92;frac{1}{120} (&#92;frac{&#92;pi}{10})^5 -
&#92;frac{1}{5040} (&#92;frac{&#92;pi}{10})^7 &#92;approx 0.30903399538
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可见取前 &lt;span class=&quot;math inline&quot;&gt;&#92;(4&#92;)&lt;/span&gt; 项时精度已经在 &lt;span class=&quot;math inline&quot;&gt;&#92;(10^{-5}&#92;)&lt;/span&gt;
之下，对于很多场合精度已经&lt;strong&gt;足够高&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;在没有了解 CORDIC(Coordinate Rotation Digital Computer) Algorithm &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;
算法之前，我一直以为计算器是利用泰勒公式去求解，最近才了解到原来在计算机中，CORDIC
算法&lt;strong&gt;远比&lt;/strong&gt;泰勒公式高效。&lt;/p&gt;
&lt;p&gt;下面我们就来了解下泰勒公式的不足之处和 CORDIC 算法是怎么做的。&lt;/p&gt;
&lt;h1 id=&quot;泰勒公式的缺点&quot;&gt;泰勒公式的缺点&lt;/h1&gt;
&lt;p&gt;上一节我们使用泰勒公式去计算三角函数值时，需要做很多次乘法运算，而计算器中乘法运算是很&lt;strong&gt;昂贵&lt;/strong&gt;的，其缺点如下所示：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;展开过小则会导致展开精度不够，展开过大则会导致计算量过大；&lt;/li&gt;
&lt;li&gt;幂运算需要使用乘法器，存在很多重复计算；&lt;/li&gt;
&lt;li&gt;需要很多变量来存储中间值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在之前的文章 &lt;a href=&quot;http://www.longluo.me/blog/2019/06/21/strassens-matrix-multiplication-algorithm/&quot;&gt;矩阵乘法的
Strassen 算法&lt;/a&gt;
，就是通过&lt;strong&gt;减少乘法，多做加法&lt;/strong&gt;，从而大大降低了运算量，那么我们可以用相同的思想来优化运算吗？&lt;/p&gt;
&lt;p&gt;当然可以，让我们请出今天的主角：&lt;strong&gt;CORDIC 算法&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="CORDIC" scheme="https://www.longluo.me/tags/CORDIC/"/>
    
    <category term="Trigonometry" scheme="https://www.longluo.me/tags/Trigonometry/"/>
    
  </entry>
  
  <entry>
    <title>我们常见的地图是如何绘制的？墨卡托投影是什么？</title>
    <link href="https://www.longluo.me/blog/2023/05/20/the-mercator-projection/"/>
    <id>https://www.longluo.me/blog/2023/05/20/the-mercator-projection/</id>
    <published>2023-05-20T02:43:35.000Z</published>
    <updated>2024-05-25T00:55:47.202Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>最近在书店里看到一本 <a href="https://book.douban.com/subject/35548116/">《数学的奥秘》</a>，原著是 《The Secret Life of Equations: The 50 Greatest Equations andHow They Work》，讲的是最伟大的数学方程式起源、构成、含义和应用。书的内容并不多，我看了其中的一部分，里面有讲墨卡托投影 (Mercator projection)<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 。</p><p>我对地理和地图一直很感兴趣，但之前对原理一直一知半解的，只知道我们常见的地图都是墨卡托投影，由墨卡托<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 在1569年创立。但墨卡托投影的原理是什么却并不清楚。书里面只有几页，但具体公式缺乏说明及推导过程，所以这几天通过查找资料掌握了墨卡托投影的原理。</p><h1 id="如何绘制地图">如何绘制地图？</h1><p>在大航海时代，航海家可以通过六分仪和观察日月星辰获取到经纬度，但在茫茫大海中迷失方向是很可怕的事情，如何才能正确的航行到目的地呢？</p><p>地球由于自转是一个两极比赤道略短的扁球体，但扁率约为 <span class="math inline">\(\frac {1}{300}\)</span>，非常之低，因为可以视为球体。因为<strong>球面不是可展曲面</strong>，也就是如果展成平面的话，长度会发生形变，所以也会形变。因为根据高斯绝妙定理(Gauss theorem egregium)<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ，平面的高斯曲率为 <span class="math inline">\(0\)</span> ，而球面的高斯曲率为 <span class="math inline">\(\frac {1}{R^2}\)</span> ，其中 <span class="math inline">\(R\)</span>为球面半径，所以在保持图形完整性前提下，将球面转化为平面，投影后得到的经纬线网形状必然会产生变形，也就是说，在投影的过程中，变形是必然存在的。</p><p>在这种情况下，墨卡托运用<strong>等角圆柱投影法</strong>绘制了航海图，极大地方便了航海家。有了墨卡托海图，航海家想要到达某个目的地，只需要在出发点和目的地之间连一条直线，量出这条航线和经线的夹角，按照航行路线就能到达目的地。</p><figure><img src="https://www.longluo.me/assets/blog/images/map/earth_map_mercator.jpg" alt="Map Mercator Projection"><figcaption aria-hidden="true">Map Mercator Projection</figcaption></figure><h1 id="什么是墨卡托投影">什么是墨卡托投影？</h1><p>设想将地球置于在一中空的圆柱里，如下图所示，其基准纬线（赤道）与圆柱相切。再设想地球中心处放置一灯泡，那么从球心处发射的光线会把球面上的图形投影到圆柱体上，之后再将把圆柱体展开，那么就可以得到一张墨卡托投影绘制出的地图。</p><span id="more"></span><figure><img src="https://www.longluo.me/assets/blog/images/map/mercator_cylindrical_projection_basics.svg" alt="Mercator Projection"><figcaption aria-hidden="true">Mercator Projection</figcaption></figure><h1 id="墨卡托公式的推导">墨卡托公式的推导</h1><p>设 <span class="math inline">\(P(lng, lat)\)</span>表示投影前的球面上的点，在数学上我们常使用弧度制，则表示为 <span class="math inline">\(P(\lambda , \varphi )\)</span> ，其中 <span class="math inline">\(\lambda = lng \cdot \frac{\pi}{180} , \quad\varphi = lat \cdot \frac{\pi}{180}\)</span>，所以<strong>墨卡托投影</strong>就是将球面上的 <span class="math inline">\(P(\lambda , \varphi )\)</span>转换为平面直角坐标系 <span class="math inline">\(P' (x, y)\)</span>，即定义为下面的一个映射：</p><p><span class="math display">\[f: P \rightarrow P'\]</span></p><p>那么则有函数 <span class="math inline">\(f_x\)</span> 和 <span class="math inline">\(f_y\)</span> ：</p><p><span class="math display">\[\left\{  \begin{aligned}  x &amp;=  f_x(\lambda , \varphi ) \\  y &amp;=  f_y(\lambda , \varphi ) \\  \end{aligned}  \right.\]</span></p><p>如下图，图中由经纬线分割出的方块区域 <span class="math inline">\(\BoxKPMQ\)</span> 映射为 <span class="math inline">\(\BoxK'P'M'Q'\)</span> ，如果 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(Q\)</span> 点足够近的话，那么 <span class="math inline">\(\Box KPMQ\)</span> 可以近似为矩形。</p><figure><img src="https://www.longluo.me/assets/blog/images/map/mercator_cylindrical_projection_infinitesimals.svg" alt="Infinity small"><figcaption aria-hidden="true">Infinity small</figcaption></figure><p><span class="math inline">\(P\)</span> 的经纬度为 <span class="math inline">\([\lambda , \varphi ]\)</span> ，相邻点 <span class="math inline">\(Q\)</span> 的经纬度为 <span class="math inline">\([\lambda + \mathrm{d}\lambda , \varphi +\mathrm{d}\varphi]\)</span> ，那么平行赤道的纬线所在圆的半径 <span class="math inline">\(r = R \cos \varphi\)</span> ，则有圆弧：</p><p><span class="math display">\[PM = r \times \mathrm{d} \lambda = R \cos \varphi \mathrm{d} \lambda\]</span></p><p>，圆弧 <span class="math inline">\(PK = R \mathrm{d} \varphi\)</span>。投影变换后平面上的矩形长宽分别为 <span class="math inline">\(\mathrm{d} x\)</span> 和 <span class="math inline">\(\mathrm{d} y\)</span> 。</p><p>在变换后，在微观局部应该保持长宽比例不变，那么：</p><p><span class="math display">\[\frac{R \cdot \mathrm{d} {\varphi}}{\mathrm{d} y} = \frac{R \cdot cos\varphi \cdot \mathrm{d} \lambda }{\mathrm{d} x}\]</span></p><p>另外也可以根据墨卡托投影是<strong>等角投影</strong><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>，<span class="math inline">\(\angle \alpha =  \angle \beta\)</span>，则有：</p><p><span class="math display">\[\tan \angle \alpha \approx \frac{PM}{QM} = \frac {R \cos \varphi\mathrm{d} \lambda }{R \mathrm{d} \varphi }\]</span></p><p><span class="math display">\[\tan \angle \beta = \frac{P'M'}{Q'M'} = \frac{\mathrm{d}x}{\mathrm{d} y}\]</span></p><p>那么：</p><p><span class="math display">\[\frac{R \cos \varphi \mathrm{d} \lambda }{R \mathrm{d} \varphi } = \frac{\mathrm{d} x}{\mathrm{d} y}\]</span></p><p>显然同一条经线上的点，变换到墨卡托之后横坐标相同，而横坐标的值就是赤道弧线划过的长度，所以<span class="math inline">\(x = R \cdot \lambda\)</span> ，那么 <span class="math inline">\(\mathrm{d} x = R \times \mathrm{d}\lambda\)</span> 。</p><p>消掉 <span class="math inline">\(\mathrm{d} x\)</span> 和 <span class="math inline">\(\mathrm{d} \lambda\)</span> ，可得：</p><p><span class="math display">\[\left \{ \begin{align}x'(\lambda ) &amp;= R \\y'(\varphi ) &amp;=R \cdot \frac{1}{\cos \varphi } \cdot \mathrm{d}{\varphi} = R \sec \varphi \\\end{align} \right.\]</span></p><p>对上式积分可得：</p><p><span class="math display">\[\int dy = R \int \frac{1}{ \cos \varphi} d\varphi = R \int \sec \varphid \varphi = R \ln(\sec \varphi + \tan \varphi ) + C\]</span></p><p>可得：</p><p><span class="math display">\[y = R \ln \tan(\frac{\pi}{4} + \frac{\varphi }{2}) + C\]</span></p><p>根据初始条件可知 <span class="math inline">\(C = 0\)</span>，所以等角投影的公式：</p><p><span class="math display">\[\left \{ \begin{aligned}x &amp; = R(\lambda -\lambda _{0})  \\y &amp; = R \ln \left[ \tan \left ( {\frac {\pi }{4}} + {\frac {\varphi}{2}} \right ) \right ]  \\\end{aligned} \right.\]</span></p><h1 id="等角航线">等角航线</h1><p>之前讲过墨卡托投影的地图上，经线投影成一组平行线，两地之间的等方位角曲线(Rhumb line)，在地图上是一条直线。航海家只需要保持方位角不变，不改变航线即可达到终点，所以在航海中得到广泛应用。但这条航线并不是两地之间的最短航线，我们知道球面上两点间最短距离是通过两点间大圆的劣弧，如下图所示。在航海或航空中，运用此特性而走最短距离的航线叫做大圆航线(Great Circle Route) 。</p><figure><img src="https://www.longluo.me/assets/blog/images/map/mercator_rhumb_line_vs_great_circle_arc.png" title="大圆航线" alt="Big Arc"><figcaption aria-hidden="true">Big Arc</figcaption></figure><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Mercator_projection">墨卡托投影Mercator projection</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://en.wikipedia.org/wiki/Gerardus_Mercator">GerardusMercator</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E7%BB%9D%E5%A6%99%E5%AE%9A%E7%90%86/18910263">高斯绝妙定理</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://mathworld.wolfram.com/MercatorProjection.html">MercatorProjection</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近在书店里看到一本 &lt;a href=&quot;https://book.douban.com/subject/35548116/&quot;&gt;《数学的奥秘》&lt;/a&gt;
，原著是 《The Secret Life of Equations: The 50 Greatest Equations and
How They Work》
，讲的是最伟大的数学方程式起源、构成、含义和应用。书的内容并不多，我看了其中的一部分，里面有讲
墨卡托投影 (Mercator projection)&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;我对地理和地图一直很感兴趣，但之前对原理一直一知半解的，只知道我们常见的地图都是墨卡托投影，由墨卡托&lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; 在
1569年创立。但墨卡托投影的原理是什么却并不清楚。书里面只有几页，但具体公式缺乏说明及推导过程，所以这几天通过查找资料掌握了墨卡托投影的原理。&lt;/p&gt;
&lt;h1 id=&quot;如何绘制地图&quot;&gt;如何绘制地图？&lt;/h1&gt;
&lt;p&gt;在大航海时代，航海家可以通过六分仪和观察日月星辰获取到经纬度，但在茫茫大海中迷失方向是很可怕的事情，如何才能正确的航行到目的地呢？&lt;/p&gt;
&lt;p&gt;地球由于自转是一个两极比赤道略短的扁球体，但扁率约为 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac {1}{300}&#92;)&lt;/span&gt;
，非常之低，因为可以视为球体。因为&lt;strong&gt;球面不是可展曲面&lt;/strong&gt;，也就是如果展成平面的话，长度会发生形变，所以也会形变。因为根据高斯绝妙定理
(Gauss theorem egregium)&lt;a href=&quot;#fn3&quot; class=&quot;footnote-ref&quot; id=&quot;fnref3&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; ，平面的高斯曲率为 &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt; ，而球面的高斯曲率为 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac {1}{R^2}&#92;)&lt;/span&gt; ，其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(R&#92;)&lt;/span&gt;
为球面半径，所以在保持图形完整性前提下，将球面转化为平面，投影后得到的经纬线网形状必然会产生变形，也就是说，在投影的过程中，变形是必然存在的。&lt;/p&gt;
&lt;p&gt;在这种情况下，墨卡托运用&lt;strong&gt;等角圆柱投影法&lt;/strong&gt;绘制了航海图，极大地方便了航海家。有了墨卡托海图，航海家想要到达某个目的地，只需要在出发点和目的地之间连一条直线，量出这条航线和经线的夹角，按照航行路线就能到达目的地。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/map/earth_map_mercator.jpg&quot; alt=&quot;Map Mercator Projection&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;Map Mercator Projection&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h1 id=&quot;什么是墨卡托投影&quot;&gt;什么是墨卡托投影？&lt;/h1&gt;
&lt;p&gt;设想将地球置于在一中空的圆柱里，如下图所示，其基准纬线（赤道）与圆柱相切。再设想地球中心处放置一灯泡，那么从球心处发射的光线会把球面上的图形投影到圆柱体上，之后再将把圆柱体展开，那么就可以得到一张墨卡托投影绘制出的地图。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Map" scheme="https://www.longluo.me/tags/Map/"/>
    
    <category term="Mercator Projection" scheme="https://www.longluo.me/tags/Mercator-Projection/"/>
    
  </entry>
  
  <entry>
    <title>智能控制系统的灵魂：深入研究 PID 控制器的算法逻辑</title>
    <link href="https://www.longluo.me/blog/2023/05/05/pid/"/>
    <id>https://www.longluo.me/blog/2023/05/05/pid/</id>
    <published>2023-05-05T00:58:10.000Z</published>
    <updated>2024-02-25T12:36:26.357Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>PID 算法 s是自动控制领域中很重要的算法。</p><p><span class="math display">\[u(t) = K_Pe(t) + K_I \int e(t) \mathrm{d}t + K_D\frac{\mathrm{d}e(t)}{\mathrm{d}t}\]</span></p><h1 id="simple-pid-controller">Simple PID Controller</h1><p>非常简单的 PID 算法在线互动式模拟器，<a href="http://www.longluo.me/projects/pid/">传送门 →</a> ：</p><p><a href="http://www.longluo.me/projects/pid/"><img src="https://user-images.githubusercontent.com/3395062/238180467-c7852d59-b9e3-4fe5-89b4-d8ddd4d44592.png" alt="PID Algorithm"></a></p><p>之前这个是 PID v1.0 版本，最近重构了代码，增加了一些新功能：</p><ol type="1"><li>增加机器人速度 <span class="math inline">\(v\)</span> 及加速度 <span class="math inline">\(a\)</span> 显示；</li><li>增加 2 个图表展示 PID X 轴方向及 Y 轴方向的 P、I、D <span class="math inline">\(3\)</span> 个分量随时间变化显示；</li><li>之前代码将时间及速度固定了，但这不符合实际，增加随 <span class="math inline">\(dt\)</span> 变化积分和微分项；</li></ol><p><a href="http://www.longluo.me/projects/pid/"><img src="https://user-images.githubusercontent.com/3395062/246782983-695c0d08-1998-4d96-b13b-a0a5827f19fc.png" alt="pid_track"></a></p><span id="more"></span><p><strong>ToDos</strong>:</p><ol type="1"><li>增加阻力因素，以更接近实际;</li><li>增加自动调谐P，I，D 3个参数的功能，目前开发中。</li></ol><p><a href="http://www.longluo.me/projects/pid/"><img src="https://user-images.githubusercontent.com/3395062/246718003-f60c6c83-39ae-4863-9471-13abc6a1acfd.png" alt="PID v2"></a></p><p><a href="http://www.longluo.me/projects/pid/">传送门不变 →</a></p><h1 id="pid-平衡小车">PID 平衡小车</h1><p>PID 平衡小车 在线网络版，<a href="http://www.longluo.me/projects/pidcart/">传送门 →</a> ：</p><p><a href="http://www.longluo.me/projects/pidcart/"><img src="https://user-images.githubusercontent.com/3395062/240794381-8f260327-5042-460a-ba61-434b9bfbc620.png" alt="PID Control Cart"></a></p><h1 id="参考文献">参考文献</h1><p>1 <a href="https://en.wikipedia.org/wiki/PID_controller">PIDController</a> 2. <a href="https://opencv.org/">OpenCV</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PID 算法 s是自动控制领域中很重要的算法。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
u(t) = K_Pe(t) + K_I &#92;int e(t) &#92;mathrm{d}t + K_D
&#92;frac{&#92;mathrm{d}e(t)}{&#92;mathrm{d}t}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;simple-pid-controller&quot;&gt;Simple PID Controller&lt;/h1&gt;
&lt;p&gt;非常简单的 PID 算法在线互动式模拟器，&lt;a href=&quot;http://www.longluo.me/projects/pid/&quot;&gt;传送门 →&lt;/a&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.longluo.me/projects/pid/&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3395062/238180467-c7852d59-b9e3-4fe5-89b4-d8ddd4d44592.png&quot; alt=&quot;PID Algorithm&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前这个是 PID v1.0 版本，最近重构了代码，增加了一些新功能：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;增加机器人速度 &lt;span class=&quot;math inline&quot;&gt;&#92;(v&#92;)&lt;/span&gt; 及加速度 &lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt; 显示；&lt;/li&gt;
&lt;li&gt;增加 2 个图表展示 PID X 轴方向及 Y 轴方向的 P、I、D &lt;span class=&quot;math inline&quot;&gt;&#92;(3&#92;)&lt;/span&gt; 个分量随时间变化显示；&lt;/li&gt;
&lt;li&gt;之前代码将时间及速度固定了，但这不符合实际，增加随 &lt;span class=&quot;math inline&quot;&gt;&#92;(dt&#92;)&lt;/span&gt; 变化积分和微分项；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://www.longluo.me/projects/pid/&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3395062/246782983-695c0d08-1998-4d96-b13b-a0a5827f19fc.png&quot; alt=&quot;pid_track&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="PID" scheme="https://www.longluo.me/tags/PID/"/>
    
    <category term="Control Theory" scheme="https://www.longluo.me/tags/Control-Theory/"/>
    
  </entry>
  
  <entry>
    <title>解密卡尔曼滤波(Kalman Filter)算法：深入解析卡尔曼滤波算法原理与在线可视化实例 </title>
    <link href="https://www.longluo.me/blog/2023/04/29/kalman-filter/"/>
    <id>https://www.longluo.me/blog/2023/04/29/kalman-filter/</id>
    <published>2023-04-29T14:36:45.000Z</published>
    <updated>2024-04-19T00:06:49.362Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>Kalman Filter<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 是贝叶斯滤波器的一种特殊实现。</p><h1 id="kalman-filter-1d-一维卡尔曼滤波器">Kalman Filter 1D |一维卡尔曼滤波器</h1><p>一维卡尔曼滤波器如下图所示：</p><figure><img src="https://user-images.githubusercontent.com/3395062/239743987-c86b622d-7c17-429c-8221-def992aacf55.PNG" alt="Kalman Filter 1D"><figcaption aria-hidden="true">Kalman Filter 1D</figcaption></figure><p>在线动画展示：http://www.longluo.me/projects/kalman/</p><span id="more"></span><h1 id="kalman-filter-2d-二维卡尔曼滤波器">Kalman Filter 2D |二维卡尔曼滤波器</h1><p>二维卡尔曼滤波器如下图所示：</p><figure><img src="https://user-images.githubusercontent.com/3395062/240522410-5a8fe8e6-30f8-42dc-b498-999cb9e604b3.png" alt="Kalman Filter 2D"><figcaption aria-hidden="true">Kalman Filter 2D</figcaption></figure><p>使用了 OpenCV<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>实现，可执行文件下载：https://github.com/longluo/Publish/blob/master/Kalman/</p><p>或者在线动画展示：http://www.longluo.me/projects/kalman2D/</p><p><a href="http://www.longluo.me/projects/kalman2D/"><img src="https://user-images.githubusercontent.com/3395062/240794186-e17c3f0e-6ee5-4611-809c-887ece06ad2d.png" alt="Kalman Filter 2D Web"></a></p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Kalman_filter">Kalman Filter</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://opencv.org/">OpenCV</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kalman Filter&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 是贝叶斯滤波器的一种特殊实现。&lt;/p&gt;
&lt;h1 id=&quot;kalman-filter-1d-一维卡尔曼滤波器&quot;&gt;Kalman Filter 1D |
一维卡尔曼滤波器&lt;/h1&gt;
&lt;p&gt;一维卡尔曼滤波器如下图所示：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/3395062/239743987-c86b622d-7c17-429c-8221-def992aacf55.PNG&quot; alt=&quot;Kalman Filter 1D&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;Kalman Filter 1D&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;在线动画展示：http://www.longluo.me/projects/kalman/&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Kalman Filter" scheme="https://www.longluo.me/tags/Kalman-Filter/"/>
    
  </entry>
  
  <entry>
    <title>从记忆到洞察：轻松掌握泰勒展开式(Taylor Series)的记忆技巧</title>
    <link href="https://www.longluo.me/blog/2023/04/26/taylor-series/"/>
    <id>https://www.longluo.me/blog/2023/04/26/taylor-series/</id>
    <published>2023-04-26T00:36:45.000Z</published>
    <updated>2023-11-14T14:24:40.572Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>在数学、物理学、工程和计算机领域中，泰勒公式<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>是一种广泛使用的分析方法，用来计算函数的<strong>近似值</strong>。在实践中，很多函数非常复杂，而且某些函数是不可积的，想求其某点的值，直接求无法实现。</p><p>泰勒公式可以将复杂的函数近似地表达为简单的多项式函数，用一个<strong>多项式函数</strong>去逼近一个给定的函数(即尽量使多项式函数图像拟合给定的函数图像)。注意在逼近的时候一定是从函数图像上的某个点展开。</p><p>下图所示就是不同项数的泰勒公式对 <span class="math inline">\(\sinx\)</span> 的逼近：</p><figure><img src="https://user-images.githubusercontent.com/3395062/234470707-9971afaa-ab07-4661-9001-fcccd8e6cedd.png" alt="768px-Sintay"><figcaption aria-hidden="true">768px-Sintay</figcaption></figure><p>泰勒级数的定义为：</p><p><span class="math display">\[f(x) = \sum _{n=0}^{\infty}{\frac{f^{(n)}(a)}{n!}}(x-a)^{n} = f(a) +{\frac {f'(a)}{1!}}(x - a) + {\frac {f''(a)}{2!}}(x - a)^{2}+ {\frac {f'''(a)}{3!}}(x - a)^{3} + \cdots\]</span></p><p>这里，<span class="math inline">\(n!\)</span> 表示 <span class="math inline">\(n\)</span> 的阶乘，而 <span class="math inline">\(f^{(n)}(a)\)</span> 表示函数 <span class="math inline">\(f\)</span> 在点 <span class="math inline">\(a\)</span> 处的 <span class="math inline">\(n\)</span> 阶导数。如果 <span class="math inline">\(a = 0\)</span>，这个级数也被称为麦克劳林级数(Maclaurin series)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p><p>泰勒展开式有很多，那么如何记忆呢？首先我们需要明白，泰勒公式之间都是有相互关联的，我们可以通过推导来理解性记忆这些公式。泰勒公式的具体推导过程可以参考数学分析教材或者网络<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> 。</p><p>下面我们就推导这些公式，以便更好的记忆<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>！</p><h1 id="几何级数-geometric-series">几何级数 Geometric series</h1><p>对于 <span class="math inline">\(-1 &lt; x &lt; 1\)</span>的情况，几何级数<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> 由等比数列求和公式可得：</p><p><span class="math display">\[\frac{1}{1 - x} = \sum _{n=0}^{\infty}x^{n} = 1 + x + x^{2} + \cdots +x^{n}\]</span></p><p>用 <span class="math inline">\(-x\)</span> 代入 <span class="math inline">\(x\)</span> 上式，则：</p><p><span class="math display">\[\frac{1}{1 + x} = \sum _{n=0}^{\infty}(-1)^nx^{n} = 1 - x + x^{2} - x^3+ \cdots + (-1)^n x^{n}\]</span></p><p>用 <span class="math inline">\(x^2\)</span> 替代 <span class="math inline">\(x\)</span> , 由于 <span class="math inline">\(\arctan x = \int_{0}^{x} \frac{1}{1 + x^2}\mathrm{d}x\)</span> ，对于 <span class="math inline">\(-1 \le x \le 1,x \neq \pm i\)</span> ，</p><p><span class="math display">\[\arctan x = \sum _{n=0}^{\infty }{\frac {(-1)^{n}}{2n + 1}}x^{2n + 1} =x - {\frac {x^3}{3}} + {\frac {x^5}{5}} - \cdots + \frac{(-1)^n}{2n +1}x^{2n + 1}\]</span></p><p>因为 <span class="math inline">\(\frac{1}{(1 - x)^2} = (\frac{1}{1 -x})'\)</span> ，则：</p><p><span class="math display">\[\begin{aligned}\frac {1}{(1-x)^2} &amp;= \sum _{n=1}^{\infty }n x^{n-1} \\&amp;= 1 + 2x + 3x^2 + \cdots + n x^{n-1}\end{aligned}\]</span></p><p>同 <span class="math inline">\(\frac{1}{(1 - x)^3} = \frac{1}{2}(\frac{1}{(1 - x)^2})'\)</span> ，则有：</p><p><span class="math display">\[\frac {1}{(1 - x)^3} = \sum _{n=2}^{\infty }{\frac {n(n - 1)}{2}}x^{n -2}\]</span></p><h1 id="指数函数-exponent-function">指数函数 Exponent function</h1><p>由于 <span class="math inline">\(\frac{\mathrm{d} e^x}{\mathrm{d} x}= e^x\)</span> ，<span class="math inline">\(e^0 = 1\)</span> 那么：</p><p><span class="math display">\[e^x = \sum _{n=0}^{\infty }{\frac{x^n}{n!}} = 1 + x + {\frac{x^2}{2!}} +{\frac {x^3}{3!}} + \cdots + {\frac{x^n}{n!}}\]</span></p><p>很明显：</p><p><span class="math display">\[\begin{aligned}(e^x)' &amp;=(\frac{1}{0!}+\frac{x}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\cdots)' \\e^x &amp;= 0+1+\frac{x}{1}+\frac{x^2}{2!}+\frac{x^3}{3!}\cdots \\&amp;= 1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\cdots\end{aligned}\]</span></p><p>对于普通指数函数 <span class="math inline">\(a^x\)</span> , 由于<span class="math inline">\(a^x=e^{x\ln a}\)</span> ，如果将 <span class="math inline">\(x\)</span> 换为 <span class="math inline">\(x\lna\)</span> ，那么 <span class="math inline">\(a^x\)</span>的泰勒展开式：</p><p><span class="math display">\[\begin{aligned}a^x &amp;= e^{x \ln a} \\&amp;= 1 + x \ln a + \frac{(x \ln a)^2}{2!} + \frac{(x \ln a)^3}{3!} +\cdots + \frac{(x \ln a)^n}{n!} \\\end{aligned}\]</span></p><span id="more"></span><h1 id="三角级数-trigonometric-functions">三角级数 Trigonometricfunctions</h1><p>由欧拉公式 <span class="math inline">\(e^x = \cos x + i \sinx\)</span> ，可以推导 <span class="math inline">\(\sin x\)</span> 和<span class="math inline">\(\cos x\)</span> 的泰勒展开式：</p><p><span class="math inline">\(\sin x\)</span>是<strong>奇函数</strong>，只有<strong>奇数项</strong>，<span class="math inline">\(\sin 0 = 1\)</span> ，同时 <span class="math inline">\(-1 \le \sin x  \le 1\)</span>，所以不同多次项的正负号要依次出现：</p><p><span class="math display">\[\sin x = \sum _{n=0}^{\infty} \frac{(-1)^{n}}{(2n + 1)!} x^{2n + 1} = x- \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \cdots +(-1)^n\frac{x^{2n + 1}}{(2n + 1)!}\]</span></p><p><span class="math inline">\(\sin x\)</span> 求导为 <span class="math inline">\(\cos x\)</span> ，同时 <span class="math inline">\(\cos x\)</span>是<strong>偶函数</strong>，只有<strong>偶数项</strong>，<span class="math inline">\(\cos 0 = 1\)</span> ，</p><p><span class="math display">\[\begin{aligned}\cos x &amp;= \frac{\mathrm{d} \sin x}{\mathrm{d} x}  \\&amp;= 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + \cdots +(-1)^n\frac{x^{2n}}{(2n)!} \\\end{aligned}\]</span></p><h1 id="自然对数-natural-logarithm">自然对数 Natural logarithm</h1><p>由几何级数求和公式：</p><p><span class="math display">\[\frac{1}{1 - x} = \sum _{n=0}^{\infty}x^{n} = 1 + x + x^{2} + \cdots +x^{n} \quad \forall x \in (-1, 1)\]</span></p><p>代入 <span class="math inline">\((1- x)\)</span> 则 <span class="math inline">\(\frac{1}{x}\)</span> 在 <span class="math inline">\(a = 1\)</span> 的泰勒展开式为：</p><p><span class="math display">\[\frac{1}{x} = \sum _{n=0}^{\infty}(1 - x)^{n} = 1 - (x - 1) + (x -1)^{2} + \cdots + (-1)^n(x - 1)^{n} \quad \forall x \in (0, 2)  \]</span></p><p>因为 <span class="math inline">\(\frac {d}{dx}(ln(1-x)) = \frac{-1}{1-x}\)</span> ，<span class="math inline">\(x &lt; 1\)</span>，则：</p><p><span class="math display">\[\frac{-1}{1-x} = -(1 - x)^{-1} = -(1 + x + x^2 + x^3 + \cdots + x^n)\]</span></p><p>所以 <span class="math inline">\(\ln (1 - x)\)</span>泰勒展开式：</p><p><span class="math display">\[\ln (1 - x) = -x - \frac {x^2}{2} - \frac {x^3}{3} - \frac {x^4}{4} -\cdots\]</span></p><p>用 $ 1- x$ 代入上式 <span class="math inline">\(x\)</span> ，则 <span class="math inline">\(\ln x\)</span> 在 <span class="math inline">\(a =1\)</span> 的泰勒展开式为：</p><p><span class="math display">\[\ln (x) = \sum_{n = 1}^{\infty} (-1)^{n - 1} \frac{(x - 1)^n}{n} = (x -1) - {\tfrac {1}{2}}(x - 1)^{2} + {\tfrac {1}{3}}(x - 1)^{3} - {\tfrac{1}{4}}(x - 1)^{4} + \cdots\]</span></p><p>对于 <span class="math inline">\(-1 &lt; x \le 1\)</span> ，<span class="math inline">\(\ln (1 + x) = \int \frac{1}{1 + x}\mathrm{d}x\)</span> ，那么： <span class="math display">\[\begin{aligned}\ln(1 + x) &amp;= \sum _{n=1}^{\infty}{\frac{(-1)^{n + 1}}{n}}x^{n} \\&amp;= x - \frac{x^2}{2} + \frac {x^3}{3} - \cdots + \frac {(-1)^{n +1}}{n}x^n\end{aligned}\]</span></p><p>那么对于 <span class="math inline">\(-1 \le x &lt; 1\)</span>，则有：</p><p><span class="math display">\[\begin{aligned}\ln(1 - x) &amp;= -\sum _{n=1}^{\infty}{\frac{x^n}{n}} \\&amp;= -x - \frac {x^2}{2} - \frac {x^3}{3} -\cdots - \frac {x^n}{n}\end{aligned}\]</span></p><p>当 <span class="math inline">\(0 &lt; x \le 1\)</span> ， <span class="math inline">\(\ln x = \ln (1 + (x - 1))\)</span> ，则：</p><p><span class="math display">\[\ln x = \sum _{n=1}^{\infty}{\frac{(-1)^{n + 1}}{n}}x^{n} = (x - 1) -\frac{(x - 1)^2}{2} + \frac {(x - 1)^3}{3} - \cdots + \frac {(-1)^{n +1}}{n}x^n\]</span></p><h1 id="二项式-binomial-series">二项式 Binomial series</h1><p>当 <span class="math inline">\(-1 \le x \le 1\)</span> 时，对于任意<span class="math inline">\(\alpha \in \mathbb {C}\)</span>，由二项式定理<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> 即可得:</p><p><span class="math display">\[\begin{aligned}(1 + x)^{\alpha} &amp;= \sum _{n=0}^{\infty}{\binom{\alpha}{n}}x^{n} \\&amp;= 1 + \alpha x + \frac{\alpha(\alpha - 1)}{2!}x^2 + \cdots +\frac{\alpha (\alpha - 1) \cdots (\alpha - n + 1)}{n!}x^{n}\end{aligned}\]</span></p><p>其中：</p><p><span class="math display">\[{\binom {\alpha}{n}} = \prod _{k = 1}^{n}{\frac{\alpha - k + 1}{k}} ={\frac {\alpha (\alpha - 1) \cdots (\alpha - n + 1)}{n!}}\]</span></p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Taylor_series">Taylor series</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://mathworld.wolfram.com/MaclaurinSeries.html">MaclaurinSeries</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://zhuanlan.zhihu.com/p/148221397">带余项的泰勒公式、欧拉-麦克劳林公式的推导</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://www.zhihu.com/question/25956068">泰勒展开的公式怎么记忆？</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Geometric_series">Geometricseries</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomialcoefficient</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数学、物理学、工程和计算机领域中，泰勒公式&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;
是一种广泛使用的分析方法，用来计算函数的&lt;strong&gt;近似值&lt;/strong&gt;。在实践中，很多函数非常复杂，而且某些函数是不可积的，想求其某点的值，直接求无法实现。&lt;/p&gt;
&lt;p&gt;泰勒公式可以将复杂的函数近似地表达为简单的多项式函数，用一个&lt;strong&gt;多项式函数&lt;/strong&gt;去逼近一个给定的函数(即尽量使多项式函数图像拟合给定的函数图像)。注意在逼近的时候一定是从函数图像上的某个点展开。&lt;/p&gt;
&lt;p&gt;下图所示就是不同项数的泰勒公式对 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;sin
x&#92;)&lt;/span&gt; 的逼近：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/3395062/234470707-9971afaa-ab07-4661-9001-fcccd8e6cedd.png&quot; alt=&quot;768px-Sintay&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;768px-Sintay&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;泰勒级数的定义为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
f(x) = &#92;sum _{n=0}^{&#92;infty}{&#92;frac{f^{(n)}(a)}{n!}}(x-a)^{n} = f(a) +
{&#92;frac {f&#39;(a)}{1!}}(x - a) + {&#92;frac {f&#39;&#39;(a)}{2!}}(x - a)^{2}
+ {&#92;frac {f&#39;&#39;&#39;(a)}{3!}}(x - a)^{3} + &#92;cdots
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里，&lt;span class=&quot;math inline&quot;&gt;&#92;(n!&#92;)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 的阶乘，而 &lt;span class=&quot;math inline&quot;&gt;&#92;(f^{(n)}(a)&#92;)&lt;/span&gt; 表示函数 &lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; 在点 &lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt; 处的 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 阶导数。如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(a = 0&#92;)&lt;/span&gt;
，这个级数也被称为麦克劳林级数(Maclaurin series)&lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;泰勒展开式有很多，那么如何记忆呢？首先我们需要明白，泰勒公式之间都是有相互关联的，我们可以通过推导来理解性记忆这些公式。泰勒公式的具体推导过程可以参考数学分析教材或者网络&lt;a href=&quot;#fn3&quot; class=&quot;footnote-ref&quot; id=&quot;fnref3&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;下面我们就推导这些公式，以便更好的记忆&lt;a href=&quot;#fn4&quot; class=&quot;footnote-ref&quot; id=&quot;fnref4&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;
！&lt;/p&gt;
&lt;h1 id=&quot;几何级数-geometric-series&quot;&gt;几何级数 Geometric series&lt;/h1&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;&#92;(-1 &amp;lt; x &amp;lt; 1&#92;)&lt;/span&gt;
的情况，几何级数&lt;a href=&quot;#fn5&quot; class=&quot;footnote-ref&quot; id=&quot;fnref5&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; 由等比数列求和公式可得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;frac{1}{1 - x} = &#92;sum _{n=0}^{&#92;infty}x^{n} = 1 + x + x^{2} + &#92;cdots +
x^{n}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用 &lt;span class=&quot;math inline&quot;&gt;&#92;(-x&#92;)&lt;/span&gt; 代入 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 上式，则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;frac{1}{1 + x} = &#92;sum _{n=0}^{&#92;infty}(-1)^nx^{n} = 1 - x + x^{2} - x^3
+ &#92;cdots + (-1)^n x^{n}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用 &lt;span class=&quot;math inline&quot;&gt;&#92;(x^2&#92;)&lt;/span&gt; 替代 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; , 由于 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;arctan x = &#92;int_{0}^{x} &#92;frac{1}{1 + x^2}
&#92;mathrm{d}x&#92;)&lt;/span&gt; ，对于 &lt;span class=&quot;math inline&quot;&gt;&#92;(-1 &#92;le x &#92;le 1,
x &#92;neq &#92;pm i&#92;)&lt;/span&gt; ，&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;arctan x = &#92;sum _{n=0}^{&#92;infty }{&#92;frac {(-1)^{n}}{2n + 1}}x^{2n + 1} =
x - {&#92;frac {x^3}{3}} + {&#92;frac {x^5}{5}} - &#92;cdots + &#92;frac{(-1)^n}{2n +
1}x^{2n + 1}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac{1}{(1 - x)^2} = (&#92;frac{1}{1 -
x})&#39;&#92;)&lt;/span&gt; ，则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
&#92;frac {1}{(1-x)^2} &amp;amp;= &#92;sum _{n=1}^{&#92;infty }n x^{n-1} &#92;&#92;
&amp;amp;= 1 + 2x + 3x^2 + &#92;cdots + n x^{n-1}
&#92;end{aligned}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac{1}{(1 - x)^3} = &#92;frac{1}{2}
(&#92;frac{1}{(1 - x)^2})&#39;&#92;)&lt;/span&gt; ，则有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;frac {1}{(1 - x)^3} = &#92;sum _{n=2}^{&#92;infty }{&#92;frac {n(n - 1)}{2}}x^{n -
2}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;指数函数-exponent-function&quot;&gt;指数函数 Exponent function&lt;/h1&gt;
&lt;p&gt;由于 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;frac{&#92;mathrm{d} e^x}{&#92;mathrm{d} x}
= e^x&#92;)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;&#92;(e^0 = 1&#92;)&lt;/span&gt; 那么：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
e^x = &#92;sum _{n=0}^{&#92;infty }{&#92;frac{x^n}{n!}} = 1 + x + {&#92;frac{x^2}{2!}} +
{&#92;frac {x^3}{3!}} + &#92;cdots + {&#92;frac{x^n}{n!}}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很明显：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
(e^x)&#39; &amp;amp;=
(&#92;frac{1}{0!}+&#92;frac{x}{1!}+&#92;frac{x^2}{2!}+&#92;frac{x^3}{3!}+&#92;cdots)&#39; &#92;&#92;
e^x &amp;amp;= 0+1+&#92;frac{x}{1}+&#92;frac{x^2}{2!}+&#92;frac{x^3}{3!}&#92;cdots &#92;&#92;
&amp;amp;= 1+x+&#92;frac{x^2}{2!}+&#92;frac{x^3}{3!}+&#92;cdots
&#92;end{aligned}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于普通指数函数 &lt;span class=&quot;math inline&quot;&gt;&#92;(a^x&#92;)&lt;/span&gt; , 由于
&lt;span class=&quot;math inline&quot;&gt;&#92;(a^x=e^{x&#92;ln a}&#92;)&lt;/span&gt; ，如果将 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 换为 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;ln
a&#92;)&lt;/span&gt; ，那么 &lt;span class=&quot;math inline&quot;&gt;&#92;(a^x&#92;)&lt;/span&gt;
的泰勒展开式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
a^x &amp;amp;= e^{x &#92;ln a} &#92;&#92;
&amp;amp;= 1 + x &#92;ln a + &#92;frac{(x &#92;ln a)^2}{2!} + &#92;frac{(x &#92;ln a)^3}{3!} +
&#92;cdots + &#92;frac{(x &#92;ln a)^n}{n!} &#92;&#92;
&#92;end{aligned}
&#92;]&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Calculus" scheme="https://www.longluo.me/tags/Calculus/"/>
    
    <category term="Taylor Series" scheme="https://www.longluo.me/tags/Taylor-Series/"/>
    
  </entry>
  
</feed>
