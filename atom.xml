<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long Luo&#39;s Life Notes</title>
  
  <subtitle>每一天都是奇迹</subtitle>
  <link href="https://www.longluo.me/atom.xml" rel="self"/>
  
  <link href="https://www.longluo.me/"/>
  <updated>2024-06-23T01:17:25.336Z</updated>
  <id>https://www.longluo.me/</id>
  
  <author>
    <name>Long Luo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正态分布(Normal Distribution)公式为什么长这样？</title>
    <link href="https://www.longluo.me/blog/2024/04/27/normal-distribution/"/>
    <id>https://www.longluo.me/blog/2024/04/27/normal-distribution/</id>
    <published>2024-04-27T05:16:57.000Z</published>
    <updated>2024-06-23T01:17:25.336Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>相信大家或多或少都听过六西格玛( <span class="math inline">\(\text{6Sigma}\)</span> ) <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 这个词，六西格玛是指生产的产品中，<span class="math inline">\(99.99966\%\)</span>的产品是没有质量问题的，即只有 <span class="math inline">\(3.4ppm\)</span> 的不良率。</p><p>假如一家工厂生产某型号零件，零件的长度要求是 <span class="math inline">\(100mm\)</span> ，允许的标准差是 <span class="math inline">\(0.1mm\)</span> 。根据 <span class="math inline">\(6 \sigma\)</span> 原则，零件规格允许的偏差范围是：<span class="math inline">\(100 \pm  6 \times 0.1 = 100 \pm 0.6\)</span>。</p><p>这意味着，零件长度超过 <span class="math inline">\(100.6mm\)</span>或低于 <span class="math inline">\(99.4mm\)</span>的概率是非常低的，约为 <span class="math inline">\(0.00034\%\)</span>。如果工厂每天生产 100 万个零件，只允许有 <span class="math inline">\(3.4\)</span> 个零件会超出 <span class="math inline">\(6 \sigma\)</span>的范围，几乎可以忽略不计。因此，生产过程是极其稳定和可靠的，达到了六西格玛水平。</p><p>那么 <span class="math inline">\(6 \sigma\)</span> 中 <span class="math inline">\(3.4ppm\)</span> 的不良率来自哪里呢？</p><p>学过中学数学都知道，在<strong>正态分布</strong>( <span class="math inline">\(\text{Normal Distribution}\)</span> ) <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 中， <span class="math inline">\(68.27\%\)</span> 的数据位于平均值的一个标准差内，<span class="math inline">\(95.45\%\)</span> 位于两个标准差内， <span class="math inline">\(99.73\%\)</span> 位于三个标准差内，这也是著名的68-95-99.7 Rule <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ，如下图 1 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/standard_deviation_diagram_micro.svg" alt="图1. 68-95-99.7 Rule"><figcaption aria-hidden="true">图1. 68-95-99.7 Rule</figcaption></figure><h1 id="什么是正态分布">什么是正态分布？</h1><p>数据可以用不同的方式“分布”，比如数据可以向左散布的多一些，也可以向右散布的多一些，或者分布的乱七八糟，如下图2 - 4 所示，</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/normal_distribution_skew_left.gif" alt="图2. 数据偏向左散布"><figcaption aria-hidden="true">图2. 数据偏向左散布</figcaption></figure><figure><img src="https://www.longluo.me/assets/blog/images/probability/normal_distribution_skew_right.gif" alt="图3. 数据偏向右散布"><figcaption aria-hidden="true">图3. 数据偏向右散布</figcaption></figure><figure><img src="https://www.longluo.me/assets/blog/images/probability/normal_distribution_random.gif" alt="图4. 数据随机分布"><figcaption aria-hidden="true">图4. 数据随机分布</figcaption></figure><p>但数据经常会集中在一个中心值的附近，而不向左或右偏斜，像一个<strong>钟形</strong>，如下图5 所示。</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/empirical_rule_histogram.svg" alt="图5. 数据正态分布"><figcaption aria-hidden="true">图5. 数据正态分布</figcaption></figure><p>正态分布，又称高斯分布（ <span class="math inline">\(\text{GaussianDistribution}\)</span> ），是一种重要的概率分布，是由数学王子高斯 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> 在 19世纪初提出的。有很多日常现象都符合这种分布，如人的身高、考试成绩等。正因为它几乎无处不在，所以叫Normal Distribution 。德国曾经发行的一款 10马克的纸币上就印着高斯和正态分布曲线，如下图 6 所示。</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/gauss_10_mark.jpg" alt="图6. 高斯和正态分布曲线"><figcaption aria-hidden="true">图6. 高斯和正态分布曲线</figcaption></figure><span id="more"></span><p>这个曲线的数学公式大家在中学里都早已见过，如下所示：</p><p><span class="math display">\[f(x; \mu ,\sigma ) = {\frac {1}{\sigma {\sqrt {2\pi }}}}\;e^{-{\frac{\left(x - \mu \right)^{2}}{2 \sigma ^{2}}}}    \tag{1} \label{1}\]</span></p><p><span class="math inline">\(\mu\)</span>是正态分布的数学期望值，可解释为位置参数，决定了分布的位置，表示<strong>曲线中心</strong>在哪里；方差<span class="math inline">\(\sigma ^{2}\)</span>为尺度参数，决定了分布的幅度，表示<strong>曲线的扁平情况</strong>。均值<span class="math inline">\(\mu\)</span> 和方差 <span class="math inline">\(\sigma ^{2}\)</span>不同，曲线形状也有所不同，如下图 7 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/normal_distribution_pdf.svg" alt="图7. 不同均值和方差的正态分布曲线"><figcaption aria-hidden="true">图7.不同均值和方差的正态分布曲线</figcaption></figure><p>正态分布的公式看起来非常复杂，里面有 <span class="math inline">\(\pi\)</span> 、 <span class="math inline">\(e\)</span> 、 <span class="math inline">\(\mu\)</span> 、 <span class="math inline">\(\sigma\)</span>，组合起来非常复杂。在学习时，课本介绍正态分布时就直接给出这个公式，却从来不说明这个概率密度函数是怎么推导来的，来龙去脉是什么。最近看了<a href="https://3blue1brown.com/">3Blue1Brown</a> 关于 <a href="https://www.3blue1brown.com/topics/probability">概率论的系列视频</a>，我知道了正态分布曲线公式为什么是这样，我们将在下一章节中推导出这个公式。</p><h1 id="正态分布公式怎么来的">正态分布公式怎么来的？</h1><p>有很多种方法都可以推导出正态分布公式，这里将介绍一种既优雅又直观的推导方式，由天文学家赫歇尔（JohnHerschel） <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> 在 1850 年给出的。<a href="https://3blue1brown.com/">3Blue1Brown</a> 的视频 <a href="https://www.youtube.com/watch?v=cy8r7WSuT1I">Why π is in thenormal distribution (beyond integral tricks)</a>中详细介绍了这种方式。不过视频中有一些不够严谨的地方，下面会先介绍视频中的推导方法，然后再介绍严谨的数学分析法。</p><p>考虑向一个镖盘投掷飞镖，过镖盘中心作 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span>轴。每次投掷飞镖都会受到随机因素而偏离目标，故每次飞镖在镖盘的落点 <span class="math inline">\((x, y)\)</span> 是 <span class="math inline">\(2\)</span> 维随机变量。</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/dartboard_unlabeled.svg" alt="图8. 飞镖镖盘"><figcaption aria-hidden="true">图8. 飞镖镖盘</figcaption></figure><p>假设满足以下 <span class="math inline">\(2\)</span> 个条件：</p><ol type="1"><li>落点的 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span> 轴坐标是相互独立的；</li><li>落点的概率密度函数仅与其到原点的距离有关，即分布在空间上具有旋转对称性。</li></ol><h2 id="blue1brown-herschel-推导方法">3Blue1Brown Herschel 推导方法</h2><p>如下图 9 所示，设箭头所示落点区域 <span class="math inline">\(P\)</span> 的概率密度函数为 <span class="math inline">\(f_2(x, y)\)</span> ， <span class="math inline">\(f_2\)</span> 表示有 <span class="math inline">\(2\)</span> 个输入参数，落点的坐标 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 。</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/normal_herschel_point.png" alt="图9. 落点概率密度函数"><figcaption aria-hidden="true">图9. 落点概率密度函数</figcaption></figure><p>由条件 <span class="math inline">\(1\)</span> 我们知道每个落点区域<span class="math inline">\(P\)</span> 的概率密度，可以表示为 <span class="math inline">\(x\)</span> 轴方向上概率密度函数与 <span class="math inline">\(y\)</span>轴方向上概率密度函数的<strong>乘积</strong>，每个方向上的概率密度函数只有对应方向上一个参数。</p><p>设 <span class="math inline">\(x\)</span> 轴方向上概率密度函数为<span class="math inline">\(g(x)\)</span> ， <span class="math inline">\(y\)</span> 轴方向上概率密度函数为 <span class="math inline">\(h(y)\)</span> ，则有以下公式：</p><p><span class="math display">\[f_2(x, y) = g(x) h(y)      \tag{2} \label{2}\]</span></p><p>又因为条件 <span class="math inline">\(2\)</span>我们知道可以通过旋转对称性，可知 <span class="math inline">\(x\)</span>轴和 <span class="math inline">\(y\)</span>轴方向上概率密度函数相同，所以 <span class="math inline">\(g(y) =h(y)\)</span> 。同时落点 <span class="math inline">\(P\)</span>距离原点的距离为 <span class="math inline">\(r = \sqrt{x^2 +y^2}\)</span> ，如下图 10 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/normal_herschel_distance_r.png" alt="图10. 落点概率密度函数只与半径有关"><figcaption aria-hidden="true">图10.落点概率密度函数只与半径有关</figcaption></figure><p>则 <span class="math inline">\(f_2(x, y)\)</span>概率密度函数表示为半径（距原点的距离）的单变量函数 <span class="math inline">\(f(r)\)</span> ，则有：</p><p><span class="math display">\[f_2(x, y) = f(r) = f(\sqrt {x^2 + y^2})            \tag{3} \label{3}\]</span></p><p>综合 <span class="math inline">\(\eqref{2}\)</span> 和 <span class="math inline">\(\eqref{3}\)</span> 可得：</p><p><span class="math display">\[f(\sqrt {x^2 + y^2}) = g(x) g(y)            \tag{4} \label{4}\]</span></p><p>假设 <span class="math inline">\(x\)</span> 轴上距离原点距离为 <span class="math inline">\(r\)</span> 的点 <span class="math inline">\(P\)</span> ，坐标为 <span class="math inline">\((r, 0)\)</span> ，如下图 11 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/normal_herschel_f_gr.png" alt="图11. 落点在 x 轴 (r, 0) 处"><figcaption aria-hidden="true">图11. 落点在 <span class="math inline">\(x\)</span> 轴 <span class="math inline">\((r,0)\)</span> 处</figcaption></figure><p>点 <span class="math inline">\(P(r, 0)\)</span>处的概率密度函数可以写成：</p><p><span class="math display">\[f_2(r, 0) = f(r) = g(r) g(0)             \tag{5} \label{5}\]</span></p><p>从上式 <span class="math inline">\(\eqref{5}\)</span> 可知 的 <span class="math inline">\(f(r)\)</span> 等于 <span class="math inline">\(g(r)\)</span> 乘以<strong>某个常数</strong> <span class="math inline">\(g(0)\)</span> ，所以 <span class="math inline">\(f(r) = C g(r)\)</span> ，其中 <span class="math inline">\(C\)</span> 为某个常数。</p><p>由于最终都需要进行归一化，这里不妨设 <span class="math inline">\(C =1\)</span> ，则公式 <span class="math inline">\(\eqref{4}\)</span>可以写成：</p><p><span class="math display">\[f(\sqrt {x^2 + y^2}) = f(x) f(y)             \tag{6} \label{6}\]</span></p><p>至此我们得到了<strong>最重要</strong>的关系式，问题转变为如何求解函数<span class="math inline">\(f\)</span> 。公式 <span class="math inline">\(\eqref{6}\)</span> 是一个函数方程 <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>，熟悉函数方程的同学可能一眼就知道满足公式 <span class="math inline">\(\eqref{6}\)</span>的函数解是<strong>指数函数</strong> <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> 。</p><p><span class="math display">\[f({r}) = e^{-{r}^2}               \tag{7} \label{7}\]</span></p><p>如果我们不知道这个函数方程的解怎么办呢？下面我们就来求解下。</p><p>设函数 <span class="math inline">\(h(x) = f(\sqrt {x})\)</span>，则有 <span class="math inline">\(h(x^2) = f(x)\)</span> ，那么公式<span class="math inline">\(\eqref{6}\)</span> 可以写成：</p><p><span class="math display">\[h(x^2 + y^2) = h(x^2) h(y^2)                  \tag{8} \label{8}\]</span></p><p>从公式 <span class="math inline">\(\eqref{8}\)</span> 我们知道任取<span class="math inline">\(2\)</span> 个正整数，先相加再代入函数 <span class="math inline">\(h\)</span> ，结果等于先分别代入函数 <span class="math inline">\(h\)</span> 再相乘。这意味着，函数 <span class="math inline">\(h\)</span> 把加法变成了乘法。</p><p>如果这个性质适用于任意 <span class="math inline">\(2\)</span>个正整数，那么很容易扩展至任意 <span class="math inline">\(n\)</span>个正整数：</p><p><span class="math display">\[h(x_1 + x_2 + \cdots + x_n) = h(x_1)h(x_2) \cdotsh(x_n)                  \tag{9} \label{9}\]</span></p><p>不妨代入 <span class="math inline">\(x = 5\)</span> ，则有：</p><p><span class="math display">\[\begin{aligned}h(5) &amp; = h(1 + 1 + 1 + 1 + 1) \\&amp; = h(1)h(1)h(1)h(1)h(1) \\&amp; = h(1)^5\end{aligned}\]</span></p><p>这里 <span class="math inline">\(x\)</span> 可以为任意整数 <span class="math inline">\(n\)</span> ，则有：</p><p><span class="math display">\[h(n) = h(1 + \cdots + 1) = h(1) \cdots h(1) =h(1)^n                    \tag{10} \label{10}\]</span></p><p>不妨令 <span class="math inline">\(a = h(1)\)</span> ，同时公式 <span class="math inline">\(\eqref{10}\)</span> 可以推广至实数域 <span class="math inline">\(\mathbb{R}\)</span> ，则有：</p><p><span class="math display">\[h(x) = a^x                    \tag{11} \label{11}\]</span></p><p>为了方便和统一，任意指数函数都可以写成以 <span class="math inline">\(e\)</span> 为底的指数函数：</p><p><span class="math display">\[h(x) = e^{\ln a x} = e^{c x}                    \tag{12} \label{12}\]</span></p><p>至此我们就求出了满足函数方程 <span class="math inline">\(\eqref{6}\)</span> 函数 <span class="math inline">\(f\)</span> 为：</p><p><span class="math display">\[f(x) = e^{cx^2}                                 \tag{13} \label{13}\]</span></p><p>那么常数 <span class="math inline">\(c\)</span>是多少呢？根据概率论我们知道：</p><p><span class="math display">\[\int f(x) \mathrm{d}x = \int e^{cx^2} \mathrm{d}x =1                                 \tag{14} \label{14}\]</span></p><p>上式就是大名鼎鼎的高斯积分（ <span class="math inline">\(\text{Gaussian Integral}\)</span> ） <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>，如何求解高斯积分网上有很多教程，这里不再赘述。</p><p>最终我们得出了 <span class="math inline">\(2\)</span>维情况下的未归一化的概率密度函数：</p><p><span class="math display">\[f_2(x, y) = f_1(x)f_1(y) = e^{-x^2} e^{-y^2} = e^{-(x^2 +y^2)}                                  \tag{15} \label{15}\]</span></p><h2 id="更严谨的数学分析法">更严谨的数学分析法</h2><p>上一节我们使用了不那么严谨的方法得到了正态分布的概率密度函数，下面我们使用另外一种方法求出正态分布的概率密度函数。</p><p>由落点分布分布在空间上具有旋转对称性，我们可知 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span>轴具有<strong>相同且连续</strong>的概率密度函数。</p><p>设落点 <span class="math inline">\(P\)</span> 的概率密度函数为 <span class="math inline">\(\rho (x, y)\)</span> ， <span class="math inline">\(x\)</span> 轴方向上概率密度函数为 <span class="math inline">\(f(x)\)</span> ，则 <span class="math inline">\(y\)</span> 轴方向上的概率密度函数为 <span class="math inline">\(f(y)\)</span> ，那么考虑如下图 12所示的一个<strong>充分小</strong>的<strong>黄色区域</strong> <span class="math inline">\(\Box ABCD\)</span> ：</p><figure><img src="https://www.longluo.me/assets/blog/images/probability/normal_distribution_proof.png" alt="图12. 落点概率密度函数"><figcaption aria-hidden="true">图12. 落点概率密度函数</figcaption></figure><p>飞镖落在黄色区域 <span class="math inline">\(\Box ABCD\)</span>的概率为：</p><p><span class="math display">\[\rho (x, y) \mathrm{d}x \mathrm{d}y = f(x) \mathrm{d}x \cdot f(y)\mathrm{d}y                    \tag{16} \label{16}\]</span></p><p>将等式左边转换为极坐标形式，</p><p><span class="math display">\[\begin{cases}x = r \cos \theta  \\y = r \sin \theta\end{cases}\]</span></p><p>在极坐标下的概率密度函数设为 <span class="math inline">\(f(r, \theta)\)</span> , 则有：</p><p><span class="math display">\[\rho (x, y) = \rho (r \cos \theta , r \sin \theta) = f(r, \theta)                    \]</span></p><p>由条件 <span class="math inline">\(2\)</span> , <span class="math inline">\(f(r, \theta )\)</span> 具有旋转对称性，也就是和<span class="math inline">\(\theta\)</span> 无关，所以</p><p><span class="math display">\[\frac{\mathrm{d} f(r, \theta)}{\mathrm{d} \theta} =0                     \]</span></p><p>对公式 <span class="math inline">\(\eqref{16}\)</span> 两边对 <span class="math inline">\(\theta\)</span> 求导，可得：</p><p><span class="math display">\[\frac{\mathrm{d} f(x)}{\mathrm{d} \theta } f(y) + f(x) \frac{\mathrm{d}f(y)}{\mathrm{d} \theta } = 0                    \]</span></p><p>利用链式法则，有：</p><p><span class="math display">\[-r \sin \theta f'(x)f(y) + f(x) f'(y) r \cos \theta =0                          \]</span></p><p>上式移项可得：</p><p><span class="math display">\[\frac{f'(x)}{f(x) x} = \frac{f'(y)}{f(y) y} =C                          \]</span></p><p>我们则有：</p><p><span class="math display">\[\frac{f'(x)}{f(x)} = C x                          \]</span></p><p>对上式进行积分，可得：</p><p><span class="math display">\[\int \frac{f'(x)}{f(x)} \mathrm{d}x = \int C x\mathrm{d}x                           \]</span></p><p>求解上式可得：</p><p><span class="math display">\[\ln f(x) = \frac{C}{2}x^2 + C'                           \]</span></p><p>则求得函数 <span class="math inline">\(f(x)\)</span> 为：</p><p><span class="math display">\[f(x) = A e^{\frac{1}{2}Cx^2}                           \tag{17}\label{17}\]</span></p><p>同理 <span class="math inline">\(f(y)\)</span> 为：</p><p><span class="math display">\[f(y) = A e^{\frac{1}{2}Cy^2}                           \tag{18}\label{18}\]</span></p><p>由概率论我们知道 <span class="math inline">\(C &lt; 0\)</span> ，同时<span class="math inline">\(\int_{0}^{\infty }  f(x) \mathrm{d}x =\frac{1}{2}\)</span> ，则：</p><p><span class="math display">\[\int_{0}^{\infty }  e^{\frac{C}{2} x^2} \mathrm{d}x =\frac{1}{2A}                        \]</span></p><p>考虑 <span class="math inline">\(2\)</span>维正态分布，并使用极坐标，则有：</p><p><span class="math display">\[\begin{aligned}\int_{0}^{\infty} \int_{0}^{\infty} e^{\frac{C}{2}(x^2 + y^2)}\mathrm{d}x \mathrm{d}y  &amp; = \int_{0}^{\infty} \int_{0}^{\infty}e^{\frac{C}{2}r^2} r \mathrm{d}r \mathrm{d}\theta \\&amp; = \int_{0}^{\frac{\pi }{2}} \int_{0}^{\infty} e^{\frac{C}{2}r^2} r\mathrm{d}r \mathrm{d}\theta  \\&amp; = \frac{1}{4A^2}\end{aligned}\]</span></p><p>令 <span class="math inline">\(u = r^2\)</span> ，则有：</p><p><span class="math display">\[\int_{0}^{\infty} e^{\frac{C}{2}r^2} r \mathrm{d}r = \int_{0}^{\infty}e^{\frac{C}{2}u} \frac{\mathrm{d}u}{2} = \frac{1}{2} \left [ \frac{2}{C}e^{\frac{C}{2} u} \right ]_{0}^{\infty } =-\frac{1}{C}                        \]</span></p><p>可得：</p><p><span class="math display">\[-\frac{1}{C} \int_{0}^{\frac{\pi }{2}} \mathrm{d}\theta = -\frac{1}{C}\frac{\pi}{2} = \frac{1}{4A^2}                           \]</span></p><p>所以可求得：</p><p><span class="math display">\[A = \sqrt{\frac {-C}{2 \pi}}                          \]</span></p><p>至此，我们只剩下一个<strong>未知参数</strong> <span class="math inline">\(C\)</span> 就得到所求公式 <span class="math inline">\(\eqref{17}\)</span> 。</p><p>考虑方差 <span class="math inline">\(\sigma^2\)</span> 定义，对于期望<span class="math inline">\(\mu = 0\)</span> ，则有：</p><p><span class="math display">\[\sigma ^2 = \int_{-\infty }^{\infty }x^2 f(x) \mathrm{d}x = 2\sqrt{\frac {-C}{2 \pi}} \int_{0}^{\infty }x^2 e^{\frac{C}{2} x^2}\mathrm{d}x                                                               \tag{19}\label{19}\]</span></p><p>令 <span class="math inline">\(u = x\)</span> ， <span class="math inline">\(v = \frac{1}{C} e^{\frac{C}{2} x^2}\)</span>，则有：</p><p><span class="math display">\[\mathrm{d}v = x e^{\frac{C}{2} x^2}\]</span></p><p>根据分部积分公式：</p><p><span class="math display">\[\int u \frac{\mathrm{d}v}{\mathrm{d}x}\,\mathrm{d}x = uv - \int\frac{\mathrm{d}u}{\mathrm{d}x}v\,\mathrm{d}x\]</span></p><p>则对公式 <span class="math inline">\(\eqref{19}\)</span>进行分部积分求解可得：</p><p><span class="math display">\[\begin{aligned}\int_{0}^{\infty } u \frac{\mathrm{d}v}{\mathrm{d}x}\,\mathrm{d}x &amp;= \lim_{x \to \infty} \frac{x}{C} e^{\frac{C}{2} x^2} - \frac{0}{C}e^{\frac{C}{2} 0} - \frac{1}{C} \int_{0}^{\infty } e^{\frac{C}{2} x^2}\mathrm{d}x \\&amp; = 0 - 0 - \frac{1}{C} \frac{\sqrt {2 \pi }}{2 \sqrt {-C}} \\&amp; = - \frac{1}{C} \frac{\sqrt {2 \pi }}{2 \sqrt {-C}}\end{aligned}  \]</span></p><p>所以我们求得 <span class="math inline">\(\sigma^2\)</span> 为：</p><p><span class="math display">\[\sigma^2 = 2 \sqrt{\frac {-C}{2 \pi}} \frac{-1}{C} \frac{\sqrt {2 \pi}}{2 \sqrt {-C}} = -\frac{1}{C}  \]</span></p><p>即：</p><p><span class="math display">\[C = -\frac{1}{\sigma^2}  \]</span></p><p>将求得 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(C\)</span> 代入公式 <span class="math inline">\(\eqref{17}\)</span>，最终我们求得概率密度函数为：</p><p><span class="math display">\[f(x) = {\frac {1}{\sigma {\sqrt {2\pi }}}}\;e^{-{\frac {x^{2}}{2\sigma^{2}}}}                                                      \tag{20}\label{20}\]</span></p><p>公式 <span class="math inline">\(\eqref{20}\)</span> 是期望 <span class="math inline">\(\mu = 0\)</span> 的特殊情况，当期望 <span class="math inline">\(\mu \ne 0\)</span> 时，更一般的公式为：</p><p><span class="math display">\[f(x) = {\frac {1}{\sigma {\sqrt {2\pi }}}}\;e^{-{\frac {\left(x-\mu\right)^{2}}{2\sigma^{2}}}}                                                    \tag{21}\label{21}\]</span></p><p>特别地，当 <span class="math inline">\(\mu = 0\)</span> 且 <span class="math inline">\(\sigma = 1\)</span>，这个分布被称为<strong>标准正态分布</strong>：</p><p><span class="math display">\[f(x)={\frac {1}{\sqrt {2\pi }}}\, e^{-{\frac{x^{2}}{2}}}                                                 \tag{22}\label{22}\]</span></p><h1 id="正态分布公式的几何意义">正态分布公式的几何意义</h1><p>通过 <span class="math inline">\(\text{Herschel}\)</span>给出的优雅直观方法，仅仅依靠那 <span class="math inline">\(2\)</span>个假设条件，我们居然最终求出了正态分布的公式。有没有感觉到数学的美感？</p><p>最初看到 3Blue1Brown的这个视频，感觉非常美，正态分布那么复杂的公式居然有这么优雅直观的方式自然而然的出来了！</p><p>分析正态分布公式，公式中的 <span class="math inline">\(\pi\)</span>意味着<strong>空间上的对称性</strong>，即点分布距离中心是对称的。而<span class="math inline">\(e\)</span>的出现意味着取了<strong>时间上的极限</strong>，而这和中心极限定理（<span class="math inline">\(\text{Central limit theorem}\)</span> ） <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>有关，我会在下一篇文章详细解释，敬请期待！</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Six_Sigma">六西格玛</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://en.wikipedia.org/wiki/Normal_distribution">正态分布 Normaldistribution</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule">68-95-99.7法则</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss">高斯Gauss</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/John_Herschel">天文学家赫歇尔 JohnHerschel</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://en.wikipedia.org/wiki/Functional_equation">函数方程</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://en.wikipedia.org/wiki/Exponential_function">指数函数Exponential function</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p><a href="https://en.wikipedia.org/wiki/Gaussian_integral">高斯积分 Gaussianintegral</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn9"><p><a href="https://en.wikipedia.org/wiki/Central_limit_theorem">中心极限定理Central limit theorem</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相信大家或多或少都听过六西格玛( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{6
Sigma}&#92;)&lt;/span&gt; ) &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 这个词，六西格玛是指生产的产品中，
&lt;span class=&quot;math inline&quot;&gt;&#92;(99.99966&#92;%&#92;)&lt;/span&gt;
的产品是没有质量问题的，即只有 &lt;span class=&quot;math inline&quot;&gt;&#92;(3.4ppm&#92;)&lt;/span&gt; 的不良率。&lt;/p&gt;
&lt;p&gt;假如一家工厂生产某型号零件，零件的长度要求是 &lt;span class=&quot;math inline&quot;&gt;&#92;(100mm&#92;)&lt;/span&gt; ，允许的标准差是 &lt;span class=&quot;math inline&quot;&gt;&#92;(0.1mm&#92;)&lt;/span&gt; 。根据 &lt;span class=&quot;math inline&quot;&gt;&#92;(6 &#92;sigma&#92;)&lt;/span&gt; 原则，零件规格允许的偏差范围是：
&lt;span class=&quot;math inline&quot;&gt;&#92;(100 &#92;pm  6 &#92;times 0.1 = 100 &#92;pm 0.6&#92;)&lt;/span&gt;
。&lt;/p&gt;
&lt;p&gt;这意味着，零件长度超过 &lt;span class=&quot;math inline&quot;&gt;&#92;(100.6mm&#92;)&lt;/span&gt;
或低于 &lt;span class=&quot;math inline&quot;&gt;&#92;(99.4mm&#92;)&lt;/span&gt;
的概率是非常低的，约为 &lt;span class=&quot;math inline&quot;&gt;&#92;(0.00034&#92;%&#92;)&lt;/span&gt;
。如果工厂每天生产 100 万个零件，只允许有 &lt;span class=&quot;math inline&quot;&gt;&#92;(3.4&#92;)&lt;/span&gt; 个零件会超出 &lt;span class=&quot;math inline&quot;&gt;&#92;(6 &#92;sigma&#92;)&lt;/span&gt;
的范围，几乎可以忽略不计。因此，生产过程是极其稳定和可靠的，达到了六西格玛水平。&lt;/p&gt;
&lt;p&gt;那么 &lt;span class=&quot;math inline&quot;&gt;&#92;(6 &#92;sigma&#92;)&lt;/span&gt; 中 &lt;span class=&quot;math inline&quot;&gt;&#92;(3.4ppm&#92;)&lt;/span&gt; 的不良率来自哪里呢？&lt;/p&gt;
&lt;p&gt;学过中学数学都知道，在&lt;strong&gt;正态分布&lt;/strong&gt;( &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Normal Distribution}&#92;)&lt;/span&gt; ) &lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; 中， &lt;span class=&quot;math inline&quot;&gt;&#92;(68.27&#92;%&#92;)&lt;/span&gt; 的数据位于平均值的一个标准差内，
&lt;span class=&quot;math inline&quot;&gt;&#92;(95.45&#92;%&#92;)&lt;/span&gt; 位于两个标准差内， &lt;span class=&quot;math inline&quot;&gt;&#92;(99.73&#92;%&#92;)&lt;/span&gt; 位于三个标准差内，这也是著名的
68-95-99.7 Rule &lt;a href=&quot;#fn3&quot; class=&quot;footnote-ref&quot; id=&quot;fnref3&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; ，如下图 1 所示：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/probability/standard_deviation_diagram_micro.svg&quot; alt=&quot;图1. 68-95-99.7 Rule&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图1. 68-95-99.7 Rule&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h1 id=&quot;什么是正态分布&quot;&gt;什么是正态分布？&lt;/h1&gt;
&lt;p&gt;数据可以用不同的方式“分布”，比如数据可以向左散布的多一些，也可以向右散布的多一些，或者分布的乱七八糟，如下图
2 - 4 所示，&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/probability/normal_distribution_skew_left.gif&quot; alt=&quot;图2. 数据偏向左散布&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图2. 数据偏向左散布&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/probability/normal_distribution_skew_right.gif&quot; alt=&quot;图3. 数据偏向右散布&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图3. 数据偏向右散布&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/probability/normal_distribution_random.gif&quot; alt=&quot;图4. 数据随机分布&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图4. 数据随机分布&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;但数据经常会集中在一个中心值的附近，而不向左或右偏斜，像一个&lt;strong&gt;钟形&lt;/strong&gt;，如下图
5 所示。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/probability/empirical_rule_histogram.svg&quot; alt=&quot;图5. 数据正态分布&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图5. 数据正态分布&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;正态分布，又称高斯分布（ &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Gaussian
Distribution}&#92;)&lt;/span&gt; ），是一种重要的概率分布，是由数学王子高斯 &lt;a href=&quot;#fn4&quot; class=&quot;footnote-ref&quot; id=&quot;fnref4&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; 在 19
世纪初提出的。有很多日常现象都符合这种分布，如人的身高、考试成绩等。正因为它几乎无处不在，所以叫
Normal Distribution 。德国曾经发行的一款 10
马克的纸币上就印着高斯和正态分布曲线，如下图 6 所示。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/probability/gauss_10_mark.jpg&quot; alt=&quot;图6. 高斯和正态分布曲线&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图6. 高斯和正态分布曲线&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Probability" scheme="https://www.longluo.me/tags/Probability/"/>
    
    <category term="Normal Distribution" scheme="https://www.longluo.me/tags/Normal-Distribution/"/>
    
    <category term="Gauss" scheme="https://www.longluo.me/tags/Gauss/"/>
    
  </entry>
  
  <entry>
    <title>高速公路编号背后的数学密码</title>
    <link href="https://www.longluo.me/blog/2024/04/21/decode-the-highway-system-numbers/"/>
    <id>https://www.longluo.me/blog/2024/04/21/decode-the-highway-system-numbers/</id>
    <published>2024-04-21T00:08:32.000Z</published>
    <updated>2024-06-05T11:42:12.635Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>世界那么大，我想去看看！随着科技的发展，我们早已做到无需离开家就能领略世界各地的风景和文化。通过高清视频、高清直播、社交媒体、VR技术、各种图片或者视频分享平台，我们不仅可以体验世界名胜古迹、自然美景和各地的风土人情，还能与当地居民互动，了解他们的日常生活和传统文化。互联网丰富了人们的生活，缩小了地域的界限，真正实现了让世界触手可及，足不出户便可周游世界的梦想。但正所谓“百闻不如一见”，“读万卷书，不如行万里路！”，尽管互联网让我们可以虚拟游览世界，但亲自出行的体验无可替代。自由行不仅提供了前所未有的自由和灵活性，还能让我们亲身感受到大自然的美妙、城市的活力。这种身临其境的体验，远非屏幕前的感受可比。</p><p>当你打开地图软件时，你会看到如图 1 所示的道路标志，</p><figure><img src="https://www.longluo.me/assets/blog/images/road/highway_mark.png" alt="图1. 道路编号"><figcaption aria-hidden="true">图1. 道路编号</figcaption></figure><p>当你在道路出行时，你也会看到看到如下图 2所示的路牌，但你可能并未真正留意过这些标志。因为现在我们只需要有一部联网的智能手机，在地图类软件里，设定出发地和目的地，自然有导航会指引我们到达目的地。</p><figure><img src="https://www.longluo.me/assets/blog/images/road/china_expwy_g35_sign_with_name_in_luogang_tollgate.jpg" alt="图2. G35 高速萝岗路段"><figcaption aria-hidden="true">图2. G35 高速萝岗路段</figcaption></figure><p>这些编号肯定不是随机的，那么这些道路编号到底有什么用呢？出于好奇心你可能会去寻找答案，你很容易轻松找到中国国家高速的编号密码 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 和 高速公路是怎样命名和编号 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>这样的文章。但这些文章只是告诉我们是什么，并没有告诉我们为什么。</p><p>国内现行的高速公路命名是由交通部从 2005 年启动的 <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>，之前道路都以起始地和终点地命名。你可能会想，之前那种命名方式不是更合理吗？用了数字不是更加不清晰易懂吗？如果图1 不是路牌上写了济广高速，谁知道 G35 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> 是哪里到哪里呢？</p><p>如果你更进一步的话，如果你去了解世界其他国家的高速公路命名的话，你会惊讶的地发现为什么居然全世界各主要大国都选择了类似的编号系统，这背后的原因是什么呢？</p><p>要回答这个问题，我们需要把时钟拨回几十年前，回到高速公路诞生的时期，那个没有GPS，没有手机，只有纸质地图的时代，我们才能知道这种编号系统的<strong>重要意义</strong>和<strong>实用性</strong>，以及背后的<strong>数学密码</strong>。</p><h1 id="世界各国如何对高速公路进行编号">世界各国如何对高速公路进行编号？</h1><p>我们已经了解了国内高速公路编号 <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>，让我们看看其他国家的高速公路系统编号是什么样的。这些国家需要国土面积足够大，高速公路系统足够发达，国土疆域长宽比例没有太夸张，人口分布比较均匀。</p><span id="more"></span><h2 id="德国-germany">德国 （Germany）</h2><p>首先我们把目光投向德国 <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>，因为世界上第一条被广泛认可的现代意义上的高速公路就是德国的“Autobahn”<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> ，于 1932年建成，连接科隆与波恩，完全是为高速行驶的机动车辆设计和建造的。</p><p>在纳粹上台之后，高速公路建设被视为国家的重要工程，是当时德国最具标志性的基础设施项目之一，以展示德国的工程实力和国家威严<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>。高速公路建提高了交通运输效率和便利性，同时也为了支持军事行动和纳粹的宣传活动。这些公路被设计成宽敞平坦、直线且无障碍的道路，可以实现高速行驶。</p><p>这些高速公路被称为“Autobahn”，德语的意思就是“<strong>汽车道</strong>”，命名方式则采用了简单的字母和数字组合，例如<span class="math inline">\(A1, A2, \cdots , A9\)</span> 等 <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>。这种命名方式简洁明了，便于驾驶员识别和导航。</p><p>德国现在高速公路 (Bundesautobahn，BAB) 的编号系统是在 1974年开始使用的，所有的高速公路都以 <span class="math inline">\(A\)</span>开头后接一个空白与数字编号，如 <span class="math inline">\(A8\)</span>。穿越德国全国的<strong>东西向</strong>主要高速公路以<strong>偶数</strong>编号，<strong>南北向</strong>的道路则以<strong>单数</strong>编号。用来连接区域性重点城市的较短高速公路则以两位数字来编号，具体如下图3 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/deutschland_autobahnen_nummerierung.svg" alt="图3. 德国高速公路"><figcaption aria-hidden="true">图3. 德国高速公路</figcaption></figure><ul><li><span class="math inline">\(A1 - A9\)</span> :主要南北向高速公路，数字越小越西。</li><li><span class="math inline">\(A10 - A99\)</span> :主要东西向高速公路，数字越小越北。</li><li><span class="math inline">\(A100 - A999\)</span> :环路、支线和次要高速公路。两位数和三位数的编号通常用于城市环线和连接支线。</li></ul><p>当然德国也接入了欧盟标准的“E”编号系统与其他欧洲国家的公路系统协调，如下图 4 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/european_highways_de.png" alt="图4. 德国高速公路"><figcaption aria-hidden="true">图4. 德国高速公路</figcaption></figure><h2 id="法国-france">法国 （France）</h2><p>法国的高速公路系统 <a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>被称为“Autoroute”，通常以字母“A”开头，后跟一个数字。编号体系如下：</p><ul><li><span class="math inline">\(A1 - A16\)</span>沿着首都巴黎的放射性高速公路；</li><li><span class="math inline">\(A100 - A999\)</span> :区域性或次要高速公路。</li></ul><p>由于巴黎长期是法国的中心 <a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>，所以法国的高速系统沿巴黎放射性分布，如下图 5所示。当然法国是欧洲国家，所以也使用了欧盟标准的“E”编号系统与其他欧洲国家的公路系统协调。</p><figure><img src="https://www.longluo.me/assets/blog/images/road/france_autoroutes_map.png" alt="图5. 法国高速公路"><figcaption aria-hidden="true">图5. 法国高速公路</figcaption></figure><h2 id="俄罗斯-russia">俄罗斯 （Russia）</h2><p>俄罗斯的高速公路系统 <a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> 被称为 Avtomagistral，俄语里就是高速公路的意思，编号使用字母“M”、“A”或“P”开头，后跟数字：</p><ul><li><span class="math inline">\(M\)</span> 系列:连接首都莫斯科与其他重要城市和边界。</li><li><span class="math inline">\(A\)</span> 系列:连接各主要城市，通常为区域性主干道。</li><li><span class="math inline">\(P\)</span> 系列:其他重要的区域性公路。</li></ul><p>俄罗斯和法国类似，精华都在莫斯科圣彼得堡的东欧平原区，西伯利亚和远东地区人口稀少，高速分布如下图6 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/russian_federal_highways.png" alt="图6. 俄罗斯高速公路"><figcaption aria-hidden="true">图6. 俄罗斯高速公路</figcaption></figure><h2 id="欧洲-europe">欧洲 （Europe）</h2><p>欧洲的高速公路系统 <a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>使用“E”字母（Europe）作为前缀，后接一个数字，代表着欧洲主要道路网。</p><p>欧洲路线编号的决定是由 1975 年的欧洲经济委员会作出的，并在 1992年进行了修正。作为干线的A级道路编号是<strong>两位数</strong>，而作为地方线的B 级的道路编号则是三位数，主要规则如下所示：</p><ul><li>南北方向的道路按两位数编号，从西向东依次递增，以 <span class="math inline">\(5\)</span> 结尾。</li><li>东西方向的道路按两位数编号，从北向南依次递增，以 <span class="math inline">\(0\)</span> 结尾。</li></ul><p>当然还有其他一些规则，欧洲高速公路分布如下图 7 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/international_e_road_network_green.png" alt="图7. 欧洲 E 高速公路系统"><figcaption aria-hidden="true">图7. 欧洲 E 高速公路系统</figcaption></figure><p>由于加拿大 <a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> 和 巴西 <a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>人口分布不均匀，没有什么借鉴价值。当然有同学看到这会问，欧洲高速公路系统和国内编号规则几乎一致，那么国内是借鉴了欧洲的公路编号系统吗？</p><p>其实世界各大国的高速公路编号体系在设计上几乎一致，这种统一编码方案可以追溯到美国的州际高速公路<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>系统，这个我们会在下面的章节里进行详细讲解。</p><p>我们可以先问下自己几个问题：</p><ol type="1"><li>欧洲这种编号规则有什么好处？为什么要这么编号？</li><li>如果让你来对公路进行编号，你会怎么编号呢？</li><li>2个城市之间可能有多条线路，又该如何编号呢？</li></ol><h1 id="如何给道路进行编码">如何给道路进行编码？</h1><p>假设我们在下图 8 所示的纽约曼哈顿的 <span class="math inline">\(A\)</span>点，我们要去古根海姆博物馆。此时我们位于 东区第 87 大街和 第 3大道的十字路口，我们要去的目标在 东区第 88 大街和 第 5大道交汇处十字路口。很显然，我们有很多条路线可以到达目的地。</p><figure><img src="https://www.longluo.me/assets/blog/images/road/manhattan_road.png" alt="图8. 曼哈顿街区"><figcaption aria-hidden="true">图8. 曼哈顿街区</figcaption></figure><p>即使你是个路痴，当你沿着东区第 87大街走的时候，如果你走着走着发现走到了第 4大道，你就知道至少在东西方向上你的方向对了，而当你发现走到了第 2大道，你就知道你方向走反了。同理，对于南北方向上也是如此。这样，即使你绕了很多路，但你只要知道目的地所在街区的编号，你就调整方向，多走点路多花点时间也一定能走到目的地。</p><p>当然我在写这篇文章时，想找个浅显易懂的例子，结果发现曼哈顿街区完美的符合我想找的例子。因为道路规划太好了，呈棋盘状。实际中大部分城市街区命名不一定使用数字，也不一定如此横平竖直。但是曼哈顿街区因为都使用数字编号，我们想找具体地点太容易了，这还没用上二分查找呢！</p><p>由于现实中由于不同地区地理条件不一样，城市的分布往往在地图上是随机的，比如下图9 就是我随手绘制的一个道路分布图。</p><figure><img src="https://www.longluo.me/assets/blog/images/road/road_graph.png" alt="图9. 城市之间道路图"><figcaption aria-hidden="true">图9. 城市之间道路图</figcaption></figure><p>如何对这些道路进行命名？你可能会说，那就以出发地和目的地命名好了，比如<span class="math inline">\(AB\)</span> , <span class="math inline">\(BC\)</span>等。当然这样命名也可以，但是我们可以更进一步，让命名和曼哈顿街区命名一样，让名字就<strong>自带导航</strong>功能。</p><p>那比如有 100 条道路，如何给每条道路编上正确的号码呢？从 1开始递增当然也可以，但就没有任何信息了。</p><p>让我们回顾现实中的高速公路，我们知道一条高速公路有哪些属性呢？</p><ol type="1"><li>是东西走向？南北？还是东北、东南、西南、西北？</li><li>是国家级主干道还是省级，市级？</li><li>连接哪些城市？在哪个位置？</li></ol><p>还记得地球仪上的经线和纬线吗？<a href="https://www.longluo.me/blog/2023/05/20/the-mercator-projection/">墨卡托投影</a>制作的地图帮助无数航海家顺利抵达目的地，航海家只要知道测量出当前所在地经纬度，沿着连接目的地的方向就不会迷失方向。</p><p>想一想，如何数字也有很多属性，比如奇偶性、大小、位数等，参考之前的编号系统，我们可以用<strong>数字属性</strong>和<strong>高速公路属性</strong>一一对应<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> ，比如：</p><ol type="1"><li>奇偶 <span class="math inline">\(\leftrightarrow\)</span>公路走向</li><li>大小 <span class="math inline">\(\leftrightarrow\)</span>公路位置</li><li>数字位数 <span class="math inline">\(\leftrightarrow\)</span>主干道和次要干道</li><li><span class="math inline">\(5\)</span> 的倍数 <span class="math inline">\(\leftrightarrow\)</span> 重要道路</li></ol><p>不得不说，这种设计比曼哈顿的纯数字编号要好很多，绝对是天才般的设计 <a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>！下面我们就来介绍这种编号系统的诞生地：美国州际高速公路系统。</p><h1 id="州际公路interstate-highway-system的天才设计">州际公路（InterstateHighway System）的天才设计</h1><p>也许是艾森豪威尔总统 <a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>二战时担任盟军统帅，战后又担任美国驻德国占领军总司令的缘故，我想当时德国领先世界的高速公路系统肯定给他留下了深刻印象。在他1953 - 1961年担任总统期间，提出了州际高速公路系统的构想，并在1956年签署了《国家公路与交通法案》，旨在建立一套横贯美国的高速公路网络，以提升国家交通运输效率和安全性。这个宏伟的工程由联邦政府主导，并联合各州政府共同筹资和建设。经过数十年的不懈努力，美国州际高速公路系统于1992年正式完成，涵盖了数万英里的公路，连接了各个州份和城市，成为美国国家交通运输体系的重要组成部分，也促进了经济的发展和人口的流动。</p><p>州际公路系统每条线路和编号，可以参考这个在线网站：<a href="https://interstate-map.com/">Interstate Highway Map</a></p><p>下面我们来介绍下州际高速公路的编号规则 <a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>：</p><h2 id="位数字">2 位数字</h2><ol type="1"><li><strong>偶数</strong>且为 <span class="math inline">\(5\)</span>的倍数的 <span class="math inline">\(2\)</span>位数字表示东西向主干道，从南到北依次递增，如下图 10 所示：</li></ol><figure><img src="https://www.longluo.me/assets/blog/images/road/interstate_even.jpg" alt="图10. 偶数表示东西向主干道"><figcaption aria-hidden="true">图10. 偶数表示东西向主干道</figcaption></figure><p>其实也很好记， <span class="math inline">\(\text{Even}\)</span> 对应<span class="math inline">\(\text{East}\)</span> ，而且 <span class="math inline">\(0\)</span>不偏不倚，表示<strong>水平</strong>方向，很容易记吧！</p><ol start="2" type="1"><li><strong>奇数</strong>且为 <span class="math inline">\(5\)</span>的倍数的 <span class="math inline">\(2\)</span>位数字表示南北向主干道，从西到东依次递增，如下图 11 所示：</li></ol><figure><img src="https://www.longluo.me/assets/blog/images/road/interstate_odd.jpg" alt="图11. 奇数表示南北向主干道"><figcaption aria-hidden="true">图11. 奇数表示南北向主干道</figcaption></figure><p>其实也很好记，偶数表示东西向，那奇数就是南北向了，这是主要干道，肯定不能依次递增，所以每次递增<span class="math inline">\(5\)</span> 。注意西海岸的 <span class="math inline">\(5\)</span> 要当成 <span class="math inline">\(05\)</span> 。</p><p>如何理解数字增加方向呢？</p><p>由于美国本土大致呈矩形，如果我们在地图左下角作为坐标原点，建立一个笛卡尔坐标系，如下图12 所示，想必你忘不了：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/us_interstates_coord.jpg" alt="图12. 高速公路坐标"><figcaption aria-hidden="true">图12. 高速公路坐标</figcaption></figure><p>由于中国的国土疆域并不像美国接近一个矩形，所以坐标点实际是放在靠近北京的右上角，如下图13 所示：</p><figure><img src="https://www.longluo.me/assets/blog/images/road/china_national_expressway_network_coord.png" alt="图13. 国内高速公路坐标"><figcaption aria-hidden="true">图13. 国内高速公路坐标</figcaption></figure><p>如果你掌握了这个规则，那么下面这个路标，你能猜出大概在美国哪里吗？可以先猜测然后自寻答案验证下你的猜测。</p><figure><img src="https://www.longluo.me/assets/blog/images/road/us_road_sign.jpg" alt="图14. 美国某处路标"><figcaption aria-hidden="true">图14. 美国某处路标</figcaption></figure><h2 id="位数字-1">3 位数字</h2><p>相比 <span class="math inline">\(2\)</span>位数字高速公路是跨州线路(注：不完全如此)， <span class="math inline">\(3\)</span>位数的州际公路是服务于各个都会区的较短路线，它们连接到更长的两位数路线，并且充当环城公路、支线或连接线路。</p><p><span class="math inline">\(3\)</span> 位数编号规则如下：</p><ul><li>第 <span class="math inline">\(1\)</span> 位数字反映了道路的用途，后<span class="math inline">\(2\)</span>位数字反映路线连接到的任何两位数的州际公路。例如，I-395 连接到I-95，I-270 连接到 I-70 ；</li><li>第 <span class="math inline">\(1\)</span>位数字如果是<strong>偶数</strong>，说明和州际公路会有 <span class="math inline">\(2\)</span> 个交点，奇数则仅相交一次；</li><li>对于 <span class="math inline">\(3\)</span>位数的州际公路，只要同一数字不在同一州内重复，就可以根据需要重复相同的数字。</li></ul><figure><img src="https://www.longluo.me/assets/blog/images/road/interstate_auxiliary.png" alt="图15. 州际公路支线"><figcaption aria-hidden="true">图15. 州际公路支线</figcaption></figure><p>国内公路编号系统则大致相同，可以参考 主干道 <a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>和 辅道 <a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> ，具体可参考 <a href="http://www.chinahighway.org/">中国高速公路网</a> 。</p><p>上面就是美国州际高速公路的大致规则，当然也会有一些例外。</p><p>这套编号系统不仅方便导航，有效帮助驾驶员辨别方向，还提供了关于道路走向和地理位置的信息，提高了道路网络的整体效率和安全性，它是如此的成功，以致于后来陆续被其他国家所采用。</p><h1 id="总结">总结</h1><p>生活处处皆学问，正如王建硕老师写的系列文章：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5NzI0Mjg0MA==&amp;action=getalbum&amp;album_id=1501981971495911427&amp;scene=173&amp;subscene=&amp;sessionid=svr_17f196d2f28&amp;enterid=1717510695&amp;from_msgid=2652377029&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect">无用的冷知识</a>。如果我们对日常事务多一点好奇心，我们可以发现后面更多的原理！</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://www.thepaper.cn/newsDetail_forward_3357040">高速公路是怎样命名和编号的？</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://mp.weixin.qq.com/s/w1BO7tGNsSDFfzbwZshiUQ">5分钟看懂中国国家高速的编号密码</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://www.gov.cn/gzdt/2007-07/24/content_694440.htm">交通部通知开展国家高速公路网路线命名编号调整</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://en.wikipedia.org/wiki/G35_Jinan%E2%80%93Guangzhou_Expressway">G35</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/China_National_Highways">中华人民共和国高速公路</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://en.wikipedia.org/wiki/Autobahn">德国高速公路</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://www.historydefined.net/history-of-the-autobahn/">TheAutobahn: Unraveling the Story of the World’s First Superhighway</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p><a href="https://edition.cnn.com/travel/article/autobahn-germany-history/index.html">HowGerman Autobahns changed the world</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn9"><p><a href="https://www.britannica.com/place/Germany/Highways">Highways ofGermany</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn10"><p><a href="https://en.wikipedia.org/wiki/Autoroutes_of_France">Autoroutes ofFrance</a><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn11"><p><a href="https://www.zhihu.com/question/52288622">法国为什么首都一家独大？</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn12"><p><a href="https://en.wikipedia.org/wiki/Russian_federal_highways">俄罗斯联邦高速公路</a><a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn13"><p><a href="https://en.wikipedia.org/wiki/International_E-road_network">欧洲高速公路</a><a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn14"><p><a href="https://en.wikipedia.org/wiki/Trans-Canada_Highway">跨加拿大高速公路</a><a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn15"><p><a href="https://en.wikipedia.org/wiki/Brazilian_Highway_System">巴西高速公路</a><a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn16"><p><a href="https://en.wikipedia.org/wiki/Interstate_Highway_System">州际高速系统</a><a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn17"><p><a href="https://www.youtube.com/watch?v=8Fn_30AD7Pk">The Interstate’sForgotten Code</a><a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn18"><p><a href="https://ggwash.org/view/73804/decode-the-interstates-what-highway-numbers-actually-mean">Whathighway numbers actually mean</a><a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn19"><p><a href="https://en.wikipedia.org/wiki/Dwight_D._Eisenhower">Dwight D.Eisenhower</a><a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn20"><p><a href="https://99percentinvisible.org/article/american-highways-101-visual-guide-to-u-s-road-sign-designs-numbering-systems/">AmericanHighways 101</a><a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn21"><p><a href="https://en.wikipedia.org/wiki/List_of_primary_NTHS_Expressways">Listof primary NTHS Expressways</a><a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn22"><p><a href="https://en.wikipedia.org/wiki/List_of_auxiliary_NTHS_Expressways">Listof auxiliary NTHS Expressways</a><a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;世界那么大，我想去看看！随着科技的发展，我们早已做到无需离开家就能领略世界各地的风景和文化。通过高清视频、高清直播、社交媒体、
VR
技术、各种图片或者视频分享平台，我们不仅可以体验世界名胜古迹、自然美景和各地的风土人情，还能与当地居民互动，了解他们的日常生活和传统文化。互联网丰富了人们的生活，缩小了地域的界限，真正实现了让世界触手可及，足不出户便可周游世界的梦想。但正所谓“百闻不如一见”，“读万卷书，不如行万里路！”，尽管互联网让我们可以虚拟游览世界，但亲自出行的体验无可替代。自由行不仅提供了前所未有的自由和灵活性，还能让我们亲身感受到大自然的美妙、城市的活力。这种身临其境的体验，远非屏幕前的感受可比。&lt;/p&gt;
&lt;p&gt;当你打开地图软件时，你会看到如图 1 所示的道路标志，&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/road/highway_mark.png&quot; alt=&quot;图1. 道路编号&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图1. 道路编号&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;当你在道路出行时，你也会看到看到如下图 2
所示的路牌，但你可能并未真正留意过这些标志。因为现在我们只需要有一部联网的智能手机，在地图类软件里，设定出发地和目的地，自然有导航会指引我们到达目的地。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/road/china_expwy_g35_sign_with_name_in_luogang_tollgate.jpg&quot; alt=&quot;图2. G35 高速萝岗路段&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图2. G35 高速萝岗路段&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;这些编号肯定不是随机的，那么这些道路编号到底有什么用呢？出于好奇心你可能会去寻找答案，你很容易轻松找到
中国国家高速的编号密码 &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 和 高速公路是怎样命名和编号 &lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;
这样的文章。但这些文章只是告诉我们是什么，并没有告诉我们为什么。&lt;/p&gt;
&lt;p&gt;国内现行的高速公路命名是由交通部从 2005 年启动的 &lt;a href=&quot;#fn3&quot; class=&quot;footnote-ref&quot; id=&quot;fnref3&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;
，之前道路都以起始地和终点地命名。你可能会想，之前那种命名方式不是更合理吗？用了数字不是更加不清晰易懂吗？如果图
1 不是路牌上写了济广高速，谁知道 G35 &lt;a href=&quot;#fn4&quot; class=&quot;footnote-ref&quot; id=&quot;fnref4&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; 是哪里到哪里呢？&lt;/p&gt;
&lt;p&gt;如果你更进一步的话，如果你去了解世界其他国家的高速公路命名的话，你会惊讶的地发现为什么居然全世界各主要大国都选择了类似的编号系统，这背后的原因是什么呢？&lt;/p&gt;
&lt;p&gt;要回答这个问题，我们需要把时钟拨回几十年前，回到高速公路诞生的时期，那个没有
GPS
，没有手机，只有纸质地图的时代，我们才能知道这种编号系统的&lt;strong&gt;重要意义&lt;/strong&gt;和&lt;strong&gt;实用性&lt;/strong&gt;，以及背后的&lt;strong&gt;数学密码&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;世界各国如何对高速公路进行编号&quot;&gt;世界各国如何对高速公路进行编号？&lt;/h1&gt;
&lt;p&gt;我们已经了解了国内高速公路编号 &lt;a href=&quot;#fn5&quot; class=&quot;footnote-ref&quot; id=&quot;fnref5&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;
，让我们看看其他国家的高速公路系统编号是什么样的。这些国家需要国土面积足够大，高速公路系统足够发达，国土疆域长宽比例没有太夸张，人口分布比较均匀。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Code" scheme="https://www.longluo.me/tags/Code/"/>
    
    <category term="Navigation" scheme="https://www.longluo.me/tags/Navigation/"/>
    
    <category term="Highway" scheme="https://www.longluo.me/tags/Highway/"/>
    
  </entry>
  
  <entry>
    <title>2024 阿里巴巴全球数学竞赛预选赛 试题解答</title>
    <link href="https://www.longluo.me/blog/2024/04/16/2024-alibaba-global-mathematics-competition-qualifying-round/"/>
    <id>https://www.longluo.me/blog/2024/04/16/2024-alibaba-global-mathematics-competition-qualifying-round/</id>
    <published>2024-04-16T03:13:48.000Z</published>
    <updated>2024-06-16T10:40:11.360Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p><a href="https://damo.alibaba.com/?language=zh">阿里巴巴达摩院</a> 从2018年开始每年都会举办一届全球数学竞赛，之前一方面自己数学水平比较弱，另外一方面也没有报名，但一直很仰慕那些数学大神的风采。今年是第一次报名参加<a href="https://damo.alibaba.com/alibaba-global-mathematics-competition?language=zh">2024阿里巴巴全球数学竞赛</a>，上周末参加了预选赛，但遗憾的是，全部 <span class="math inline">\(7\)</span> 道题中只有第 <span class="math inline">\(1, 2, 6\)</span> 题会做，这里分享下我的解答：</p><h1 id="problem-1">Problem 1</h1><p>几位同学假期组成一个小组去某市旅游. 该市有 <span class="math inline">\(6\)</span> 座塔，它们的位置分别为 <span class="math inline">\(A, B, C, D, E, F\)</span>。同学们自由行动一段时间后，每位同学都发现，自己在所在的位置只能看到位于<span class="math inline">\(A, B, C, D\)</span> 处的四座塔，而看不到位于<span class="math inline">\(E\)</span> 和 <span class="math inline">\(F\)</span> 的塔。已知：</p><ol type="1"><li>同学们的位置和塔的位置均视为同一平面上的点，且这些点彼此不重合；</li><li>塔中任意 <span class="math inline">\(3\)</span> 点不共线；</li><li>看不到塔的唯一可能就是视线被其它的塔所阻挡，例如，如果某位同学所在的位置<span class="math inline">\(P\)</span> 和 <span class="math inline">\(A, B\)</span> 共线，且 <span class="math inline">\(A\)</span> 在线段<span class="math inline">\(PB\)</span> 上，那么该同学就看不到位于 <span class="math inline">\(B\)</span> 处的塔。</li></ol><p><strong>（5 分）</strong> 请问 这个旅游小组最多可能有多少名同学？</p><p><span class="math inline">\(A. 3\)</span><br><span class="math inline">\(B. 4\)</span> <span class="math inline">\(C.6\)</span> <span class="math inline">\(D. 12\)</span></p><h2 id="solution">Solution</h2><p>这道题选 <span class="math inline">\(C\)</span> ，最多只能有 <span class="math inline">\(6\)</span> 名同学。</p><blockquote><p>[!TIP] 这道题的解题思路是，从假设只有 <span class="math inline">\(1\)</span> 座塔开始，一直到 <span class="math inline">\(6\)</span> 座塔，找到思路。</p></blockquote><ol type="1"><li><p>假设有 <span class="math inline">\(1\)</span> 座塔 <span class="math inline">\(A\)</span> ，那么很显然有无数多同学可以看到塔<span class="math inline">\(A\)</span> ，也可以有无数多同学看不到塔<span class="math inline">\(A\)</span>​ ；</p></li><li><p>假设有 <span class="math inline">\(2\)</span> 座塔 <span class="math inline">\(A, B\)</span> ，那么只有以 <span class="math inline">\(A\)</span> 为起点的射线 <span class="math inline">\(AB\)</span> 且位于 <span class="math inline">\(B\)</span> 之后的同学无法看到塔 <span class="math inline">\(A\)</span> ；</p></li><li><p>假设有 <span class="math inline">\(3\)</span> 座塔 <span class="math inline">\(A, B, C\)</span>，同理可知存在无数位同学至少可以看见 <span class="math inline">\(2\)</span> 座塔；</p></li><li><p>假设有 <span class="math inline">\(4\)</span> 座塔 <span class="math inline">\(A, B, C, D\)</span>，同理可知存在无数位同学至少可以看见 <span class="math inline">\(2\)</span> 座塔；</p></li><li><p>假设有 <span class="math inline">\(6\)</span> 座塔 <span class="math inline">\(A, B, C, D, E, F\)</span> ，如果每位同学都无法看见<span class="math inline">\(E, F\)</span> 塔，如下图1 所示：</p></li></ol><figure><img src="https://www.longluo.me/assets/blog/images/math/2024-alibaba-math-contest-problem1-solution.png" alt="图1. Solution of Problem 1"><figcaption aria-hidden="true">图1. Solution of Problem 1</figcaption></figure><p>所以至多有 <span class="math inline">\(6\)</span> 位同学位于 <span class="math inline">\(M, N, O, P, R, Q\)</span> 处，无法看到塔 <span class="math inline">\(E, F\)</span> 。</p><span id="more"></span><h1 id="problem-2">Problem 2</h1><p>小明玩战机游戏。初始积分为 <span class="math inline">\(2\)</span>。在游戏进行中，积分会随着时间线性地连续减少 (速率为每单位时间段扣除<span class="math inline">\(1\)</span> )。游戏开始后，每隔一个随机时间段(时长为互相独立的参数为 <span class="math inline">\(1\)</span>的指数分布)，就会有一架敌机出现在屏幕上。当敌机出现时，小明立即进行操作，可以瞬间击落对方，或者瞬间被对方击落。如被敌机击落，则游戏结束。如小明击落敌机，则会获得<span class="math inline">\(1.5\)</span>个积分，并且可以选择在击落该次敌机后立即退出游戏，或者继续游戏。如选择继续游戏，则须等待到下一架敌机出现，中途不能主动退出。游戏的难度不断递增：出现的第<span class="math inline">\(n\)</span> 架敌机，小明击落对方的概率为<span class="math inline">\((0.85)^n\)</span> ，被击落的概率为 <span class="math inline">\(1 - (0.85)^n\)</span>，且与之前的事件独立。在任何时刻，如果积分降到 <span class="math inline">\(0\)</span> ，则游戏自动结束。</p><h2 id="第-1-问">第 1 问</h2><p><strong>小问 1 (5分)</strong>如果游戏中，小明被击落后，其之前的积分保持。那么为了游戏结束时的累积积分的数学期望最大化，小明应该在其击落第几架敌机后主动结束游戏？</p><p><span class="math inline">\(A. 1\)</span> <span class="math inline">\(B. 2\)</span> <span class="math inline">\(C.3\)</span> <span class="math inline">\(D. 4\)</span></p><h3 id="solution-1">Solution</h3><blockquote><p>[!TIP] 这道题考察的就是泊松过程<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，数学好的同学推出其表达式，然后计算可得。需要注意的是泊松分布<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Python 代码可以直接调用 API <a href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.exponential.html"><code>numpy.random.exponential</code></a>。虽然是 <a href="https://en.wikipedia.org/wiki/Exponential_distribution">指数分布</a>，但在 Java 中 需要使用 <code>-Math.log(1 - random.nextDouble())</code>而不是 <code>Math.exp(double a)</code> 。模拟代码如下所示：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarPlaneGame</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getExpectScore</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; planes; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">waitTime</span> <span class="operator">=</span> -Math.log(<span class="number">1</span> - random.nextDouble());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt;= score) {</span><br><span class="line">                score = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            score -= waitTime;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">possonPr</span> <span class="operator">=</span> random.nextDouble();</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">shootDownPr</span> <span class="operator">=</span> Math.pow(<span class="number">0.85</span>, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (possonPr &lt; shootDownPr) {</span><br><span class="line">                score += <span class="number">1.5</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">simulate</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">simulateTimes</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">scoreSum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; simulateTimes; i++) {</span><br><span class="line">            scoreSum += getExpectScore(planes);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> scoreSum / simulateTimes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> simulate(i);</span><br><span class="line">            System.out.println(<span class="string">"Shoot down "</span> + i + <span class="string">" planes, Expect Score: "</span> + result);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shoot down 1 planes, Expect Score: 2.2344824425425442</span><br><span class="line">Shoot down 2 planes, Expect Score: 2.290207012168609</span><br><span class="line">Shoot down 3 planes, Expect Score: 2.2653361024420042</span><br><span class="line">Shoot down 4 planes, Expect Score: 2.187342196221392</span><br></pre></td></tr></tbody></table></figure><p>可以看出击落第 <span class="math inline">\(2\)</span>架敌机后主动结束游戏，期望积分最大，所以答案选 <span class="math inline">\(B\)</span> 。</p><h2 id="第-2-问">第 2 问</h2><p><strong>小问 2 (5分)</strong>如果游戏中，小明被击落后，其之前积累的的积分会清零。那么为了游戏结束时的期望积分最大化，小明也会选择一个最优的时间主动结束游戏。请问在游戏结束时（小明主动结束游戏、或积分减到<span class="math inline">\(0\)</span>），下列哪一个选项最接近游戏结束时小明的期望积分？</p><p><span class="math inline">\(A. 2\)</span><br><span class="math inline">\(B. 4\)</span> <span class="math inline">\(C.6\)</span> <span class="math inline">\(D. 8\)</span></p><h3 id="solution-2">Solution</h3><blockquote><p>[!TIP] 通过第一问，我们知道期望积分是随着次数逐渐递减的。</p></blockquote><p>继续写代码模拟其过程，如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarPlaneGame</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getExpectScore2</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; planes; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">waitTime</span> <span class="operator">=</span> -Math.log(<span class="number">1</span> - random.nextDouble());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt;= score / <span class="number">2</span>) {</span><br><span class="line">                score /= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            score -= waitTime;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">possonPr</span> <span class="operator">=</span> random.nextDouble();</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">shootDownPr</span> <span class="operator">=</span> Math.pow(<span class="number">0.85</span>, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (possonPr &lt; shootDownPr) {</span><br><span class="line">                score += <span class="number">1.5</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                score = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">simulate</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">simulateTimes</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">scoreSum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; simulateTimes; i++) {</span><br><span class="line">            scoreSum += getExpectScore2(planes);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> scoreSum / simulateTimes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> simulate(i);</span><br><span class="line">            System.out.println(<span class="string">"Shoot down "</span> + i + <span class="string">" planes, Expect Score: "</span> + result);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shoot down 1 planes, Expect Score: 2.0230245088842116</span><br><span class="line">Shoot down 2 planes, Expect Score: 1.7658505471404586</span><br><span class="line">Shoot down 3 planes, Expect Score: 1.42047193787333</span><br><span class="line">Shoot down 4 planes, Expect Score: 1.0837167796697962</span><br><span class="line">Shoot down 5 planes, Expect Score: 0.8877915996251725</span><br><span class="line">Shoot down 6 planes, Expect Score: 0.7556905685107955</span><br><span class="line">Shoot down 7 planes, Expect Score: 0.7055539105268976</span><br><span class="line">Shoot down 8 planes, Expect Score: 0.6896372679317954</span><br></pre></td></tr></tbody></table></figure><p>可以看出最大期望积分是 <span class="math inline">\(2.023\)</span>左右，所以答案选 <span class="math inline">\(A\)</span> 。</p><h1 id="problem-3">Problem 3</h1><p>对于实数 <span class="math inline">\(T &gt; 0\)</span> ，称欧式平面<span class="math inline">\(\mathbb{R}^2\)</span> 的子集 <span class="math inline">\(\Gamma\)</span> 为 <span class="math inline">\(T\)</span> -稠密的，如果对任意 <span class="math inline">\(v \in \mathbb{R}^{2}\)</span> ，存在 <span class="math inline">\(w \in \Gamma\)</span> 满足 <span class="math inline">\(\|v-w\| \leqslant T\)</span> . 设 <span class="math inline">\(2\)</span> 阶整方阵 <span class="math inline">\(A\in \mathrm{M}_{2}(\mathbb{Z})\)</span> 满足 <span class="math inline">\(\operatorname{det}(A) \neq 0\)</span> .</p><ol type="1"><li><strong>证明题(10分)</strong> 假设 <span class="math inline">\(\operatorname{tr}(A)=0\)</span> . 证明存在 <span class="math inline">\(C &gt; 0\)</span> ，使得对任意正整数 <span class="math inline">\(n\)</span>​ ，集合</li></ol><p><span class="math display">\[A^{n} \mathbb{Z}^{2}:=\left\{A^{n} v: v \in \mathbb{Z}^{2}\right\}\]</span></p><p>是 <span class="math inline">\(C|\operatorname{det}(A)|^{n /2}\)</span> -稠密的.</p><ol start="2" type="1"><li><strong>证明题 (10分)</strong> 假设 <span class="math inline">\(A\)</span> 的特征多项式在有理数域上不可约.证明与(1)相同的结论.</li></ol><p>注: 这里 <span class="math inline">\(\mathbb{R}^{2}\)</span> 和 <span class="math inline">\(\mathbb{Z}^{2}\)</span> 中的向量约定为列向量,<span class="math inline">\(\mathbb{R}^{2}\)</span> 中的内积为标准内积,即 <span class="math inline">\(\langle v, w\rangle=v^{t} w\)</span> .(提示: 在对(2)的证明中, 可使用如下 <span class="math inline">\(\text{Minkowski}\)</span> 凸体定理的特殊情形：<span class="math inline">\(\mathbb{R}^{2}\)</span>中以原点为中心且面积为 <span class="math inline">\(4\)</span>的任意闭平行四边形中总包含 <span class="math inline">\(\mathbb{Z}^{2}\)</span>​ 中的非零向量.)</p><h2 id="solution-3">Solution</h2><blockquote><p>[!TIP] 先挖坑，等我看懂了大神的解答再来填坑！</p></blockquote><h1 id="problem-4">Problem 4</h1><p>设 <span class="math inline">\(d \geq 0\)</span> 是整数， <span class="math inline">\(V\)</span> 是 <span class="math inline">\(2d+1\)</span> 维复线性空间，有一组基</p><p><span class="math display">\[\left\{v_1, v_2, \cdots, v_{2 d+1}\right\} \text {. }\]</span></p><p>对任一整数 <span class="math inline">\(j\left(0 \leq j \leq\frac{d}{2}\right)\)</span> ，记 <span class="math inline">\(U_j\)</span> 是</p><p><span class="math display">\[v_{2 j+1}, v_{2 j+3}, \cdots, v_{2 d-2 j+1}\]</span></p><p>生成的子空间. 定义线性变换 <span class="math inline">\(f: V\rightarrow V\)</span> 为</p><p><span class="math display">\[f\left(v_i\right)=\frac{(i-1)(2 d+2-i)}{2} v_{i-1}+\frac{1}{2} v_{i+1},1 \leq i \leq 2 d+1 .\]</span></p><p>这里我们约定 <span class="math inline">\(v_0=v_{2d+2}=0\)</span>.</p><ol type="1"><li><p><strong>证明题 (10分)</strong> 证明: <span class="math inline">\(f\)</span> 的全部特征值为 <span class="math inline">\(-d,-d+1, \cdots, d\)</span>.</p></li><li><p><strong>问答题 (5分)</strong> 记 <span class="math inline">\(W\)</span> 是从属于特征值 <span class="math inline">\(-d+2 k(0 \leq k \leq d)\)</span> 的 <span class="math inline">\(f\)</span> 的特征子空间的和. 求 <span class="math inline">\(W \cap U_0\)</span> 的维数.</p></li><li><p><strong>问答题 (5分)</strong> 对任一整数 <span class="math inline">\(j\left(1 \leq j \leq \frac{d}{2}\right)\)</span>，求 <span class="math inline">\(W \cap U_j\)</span>​​​​ 的维数.</p></li></ol><h2 id="solution-4">Solution</h2><blockquote><p>[!TIP] 先挖坑，等我看懂了大神的解答再来填坑！</p></blockquote><h1 id="problem-5">Problem 5</h1><p><strong>证明题 (20分)</strong> 对于 <span class="math inline">\(\mathbb{R}^3\)</span> 中的任何中心对称的凸多面体<span class="math inline">\(V\)</span> ，证明可以找到一个椭球面 <span class="math inline">\(E\)</span> ，把凸多面体包在内部，且 <span class="math inline">\(E\)</span> 的表面积不超过 <span class="math inline">\(V\)</span> 的表面积的 <span class="math inline">\(3\)</span> 倍。</p><h2 id="solution-5">Solution</h2><blockquote><p>[!TIP] 先挖坑，等我看懂了大神的解答再来填坑！</p></blockquote><h1 id="problem-6">Problem 6</h1><h2 id="第-1-问-1">第 1 问</h2><p>假设有一枚硬币，投掷得到正面的概率为 <span class="math inline">\(\frac{1}{3}\)</span> 。独立地投掷该硬币 <span class="math inline">\(n\)</span> 次，记 <span class="math inline">\(X_n\)</span> 为其中得到正面的次数。试求 <span class="math inline">\(X_n\)</span> 为偶数的概率在 <span class="math inline">\(n\)</span> 趋于正无穷时的极限。</p><h3 id="solution-6">Solution</h3><blockquote><p>[!TIP] 当 <span class="math inline">\(n \to \infty\)</span>，直觉告诉我们，偶数次正面出现的概率和奇数次正面出现的概率是一样的，而<strong>奇数</strong>和<strong>偶数</strong>是均匀分布的，答案应该是<span class="math inline">\(\frac{1}{2}\)</span>。但这道题不是选择题也不是填空题，我们需要严谨证明这个结论！</p></blockquote><p>由题意可知，设随机变量 <span class="math inline">\(X_n\)</span>表示在 <span class="math inline">\(n\)</span>次独立投掷中正面出现的次数，每次出现正面的概率为 <span class="math inline">\(p = \frac{1}{3}\)</span> ，则 <span class="math inline">\(X_n\)</span> 服从参数为 <span class="math inline">\(\operatorname{B}(n, p)\)</span> 的二项分布<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ，那么 <span class="math inline">\(n\)</span> 次独立投掷中正面出现 <span class="math inline">\(k\)</span> 次的概率是：</p><p><span class="math display">\[\begin{equation}\operatorname{Pr}(X_n = k) = \binom{n}{k} p^k (1−p)^{n−k}    \tag{6.1.1}\label{6.1.1}\end{equation}\]</span></p><p>要求 <span class="math inline">\(X_n\)</span> 为偶数的概率，即：</p><p><span class="math display">\[\begin{aligned}\operatorname{Pr}(X_n \text { is even}) &amp; = \operatorname{Pr}(X_n =0) + \operatorname{Pr}(X_n = 2) + \cdots + \operatorname{Pr}(X_n = 2k, k= \left \lfloor \frac{n}{2} \right \rfloor ) \\&amp; = \sum_{k=0}^{\left \lfloor \frac{n}{2} \right \rfloor}\binom{n}{2k} p^{2k} (1 − p)^{n − 2k}\end{aligned}\]</span></p><p>带入 <span class="math inline">\(p = \frac{1}{3}\)</span>，可得：</p><p><span class="math display">\[\begin{equation}\operatorname{Pr}(X_n \text { is even}) = \sum_{k=0}^{\left \lfloor\frac{n}{2} \right \rfloor} \binom{n}{2k} (\frac{1}{3})^{2k}(\frac{2}{3})^{n−2k}    \tag{6.1.2} \label{6.1.2}\end{equation}\]</span></p><p>由 二项式定理<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> 可知：</p><p><span class="math display">\[\begin{equation}(x + y)^n = \sum_{k=0}^{n} \binom{n}{k} x^k y^{n−k}    \tag{6.1.3}\label{6.1.3}\end{equation}\]</span></p><p>那么易得共轭表达式：</p><p><span class="math display">\[\begin{align}(x + y)^n + (x − y)^n &amp; = 2 \sum_{k=0}^{\left \lfloor \frac{n}{2}\right \rfloor} x^{2k}y^{n - 2k}   \tag{6.1.4} \label{6.1.4} \\(x + y)^n - (x − y)^n &amp; = 2 \sum_{k=0}^{\left \lfloor \frac{n}{2}\right \rfloor} x^{2k + 1}y^{n - 2k - 1}   \tag{6.1.5} \label{6.1.5}\end{align}\]</span></p><p>可得：</p><p><span class="math display">\[\begin{aligned}\operatorname{Pr}(X_n \text { is even}) &amp; = \sum_{k=0}^{\left\lfloor \frac{n}{2} \right \rfloor} \binom{n}{2k} (\frac{1}{3})^{2k}(\frac{2}{3})^{n−2k} \\&amp; = \frac{1}{2} \left [ \left (\frac{1}{3} + \frac{2}{3} \right )^n+ \left (\frac{1}{3} - \frac{2}{3} \right )^n \right ]  \\&amp; = \frac{1}{2} \left [1 + \frac{1}{3^n} \right ]\end{aligned}\]</span></p><p>故答案为：</p><p><span class="math display">\[\lim_{n \to \infty} \operatorname{Pr}(X_n \text { is even}) = \lim_{n\to \infty} \frac{1}{2} \left (1 + \frac{1}{3^n} \right ) = \frac{1}{2}\]</span></p><blockquote><p>[!TIP] 这道题也可以用 <a href="https://en.wikipedia.org/wiki/Markov_chain">马尔可夫链</a>来做，构建递推关系式，感兴趣的同学可以试试！</p></blockquote><h2 id="第-2-问-1">第 2 问</h2><p>某人在过年期间参加了集五福活动，在这项活动中此人每扫描一次福字，可以随机地得到五张福卡中的一张。假设其每次扫福得到五福之一的概率固定，分别为<span class="math inline">\(p_i \in (0, 1) , i = 1, 2, \cdots ,5\)</span> 且 <span class="math inline">\(\sum_{i = 1}^{5} p_i =1\)</span> ，并假设其每次扫描得到的结果相互独立。在进行了 <span class="math inline">\(n\)</span> 次扫福之后，记 <span class="math inline">\(X^{i}_n, i =1, 2, \cdots, 5\)</span>为其得到每种福卡的张数。那么求极限 <span class="math inline">\(\lim _{n\to \infty} \operatorname{P} \left ( X^{(i)}_{2n}, i = 1, 2, \cdots, 5\text { 全部为偶数} \right )\)</span> 。</p><h3 id="solution-7">Solution</h3><blockquote><p>[!TIP] 直觉告诉我们，当 <span class="math inline">\(n \to\infty\)</span>时，五种福卡每种都是偶数的事件是<strong>相互独立</strong>的。通过第一问，我们已经知道答案是<span class="math inline">\(\frac{1}{2}\)</span>，那么五种福卡每种福卡的张数都是偶数的概率就是 <span class="math inline">\(\frac{1}{2^5} = \frac{1}{32}\)</span> ，而 <span class="math inline">\(2n\)</span> 次扫福卡的概率就是 <span class="math inline">\(\frac{1}{16}\)</span>。这个猜测对不对呢？下面我们就来证明下。</p></blockquote><p>由多项式定理<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> ：</p><p><span class="math display">\[\left (x_{1} + x_{2} + \cdots + x_{m} \right)^{n} = \sum_{\begin{array}{c} \alpha _{1} + \alpha _{2} + \cdots + \alpha _{m} = n\\ \alpha _{1},\alpha _{2},\cdots ,\alpha _{m} \geq 0 \end {array}}{\frac {n!}{\alpha _{1}! \dots \alpha _{m}!}}x_{1}^{\alpha _{1}} \dotsx_{m}^{\alpha _{m}}    \tag{6.2.1} \label{6.2.1}\]</span></p><p>设 <span class="math inline">\(k_i, i = 1,2, \cdots ,5\)</span>表示是 <span class="math inline">\(n\)</span> 次独立扫描福卡中得到第<span class="math inline">\(i\)</span> 种福卡的张数，则其概率为：</p><p><span class="math display">\[\begin{align}\operatorname{Pr} \left (X_{n}^{(i)} = k_i, i=1,2, \cdots ,5 \right)&amp;= \binom {n}{k_1, k_2, \cdots, k_5} p_1^{k_1} p_2^{k_2} \cdotsp_5^{k_5}   \nonumber  \\&amp; = \frac {n!}{k_1!k_2! \cdots k_5!} p_1^{k_1} p_2^{k_2} \cdotsp_5^{k_5}     \tag{6.2.2} \label{6.2.2}\end{align}\]</span></p><p>观察上式可知，所求概率为多项式 <span class="math inline">\(\left (p_1+ p_2 + p_3 + p_4 + p_5 \right )^{n}\)</span> 的 <span class="math inline">\(p_1^{k_1} p_2^{k_2} \cdots p_5^{k_5}\)</span>​项，<span class="math inline">\(\binom {n}{k_1, k_2, \cdots ,k_5}\)</span> 为其系数。</p><p>和问题 <span class="math inline">\(1\)</span>的共轭表达式类似，我们给不同福卡添加符号位，考虑如下求和表达式：</p><p><span class="math display">\[S_{2n} = \frac{1}{2^{5}} \sum_{\beta_{i} = \pm 1} \left (\beta_{1} p_{1}+ \beta_{2} p_{2} +\cdots + \beta_{5} p_{5}\right)^{2n}       \tag{6.2.3} \label{6.2.3}\]</span></p><p>对上式进行多项式展开，可得：</p><p><span class="math display">\[\begin{aligned}S_{2n} &amp; = \frac{1}{2^{5}} \sum_{\substack {\beta_{i} = \pm 1 \\x_{1} + x_{2} + \cdots + x_{5} = 2n}} \frac{(2n)!}{x_{1}!x_{2}! \cdotsx_{5}!} \beta{1}^{x_{1}} \beta_{2}^{x_{2}} \cdots \beta_{5}^{x_{5}}p_{1}^{x_{1}} p_{2}^{x_{2}} \cdots p_{5}^{x_{5}} \\&amp; = \frac{1}{2^{5}} \sum_{x_{1} + x_{2} + \cdots + x_{5} = 2n}\frac{(2n)!}{x_{1}!x_{2}! \cdots x_{5}!} p_{1}^{x_{1}} p_{2}^{x_{2}}\cdots p_{5}^{x_{5}} \sum_{\beta_{i} = \pm 1} \beta_{1}^{x_{1}}\beta_{2}^{x_{2}} \cdots \beta_{5}^{x_{5}}\end{aligned}\]</span></p><p>考虑 <span class="math inline">\(\sum _{\substack {\beta_{i} = \pm 1\\x_{1} + x_{2} + \cdots + x_{5} = 2n}} \beta_{1}^{x_{1}}\beta_{2}^{x_{2}} \cdots \beta_{5}^{x_{5}}\)</span> ，如果存在 $k $ 使得<span class="math inline">\(x_{k}\)</span>为<strong>奇数</strong>的话，那么：</p><p><span class="math display">\[\sum_{\beta_{i} = \pm 1} \beta_{1}^{x_{1}} \beta_{2}^{x_{2}} \cdots\beta_{5}^{x_{5}} = \sum_{\substack {\beta_{i}= \pm 1 \\ i \neq k}}\left[\left (1^{x_{k}} + (-1)^{x_{k}} \right) \prod_ {i \neq k}\beta_{i}^{x_{i}} \right ]=0\]</span></p><p>由于<strong>奇数项</strong>最终都会消去，只有偶数项 <span class="math inline">\(x_{i}\)</span> 才会留下来，故有：</p><p><span class="math display">\[\sum_{\beta_{i} = \pm 1} \beta_{1}^{x_{1}} \beta_{2}^{x_{2}} \cdots\beta_{k}^{x_{k}} = 2^{k}\]</span></p><p>那么求和表达式为：</p><p><span class="math display">\[\begin{aligned}S_{2n} &amp; = \sum_{\substack{x_{1} + x_{2} + \cdots + x_{k} = 2 n \\x_{i} \text { is even }}} \frac{(2 n)!}{x_{1}!x_{2}! \cdots x_{k}!}p_{1}^{x_{1}} p_{2}^{x_{2}} \cdots p_{k}^{x_{k}} \\&amp; = \operatorname{Pr} \left \{ X_{2 n}^{(i)} \text { is all even }\right\}\end{aligned}\]</span></p><p>因此，所求问题转化为在 <span class="math inline">\(X_{2n}^{(i)}\)</span> 均为偶数情况下，当 $n $ 时，其极限为：</p><p><span class="math display">\[\lim _{n \to \infty} \operatorname{Pr}\left \{X_{2 n}^{(i)} \text { isall even } \right\} = \lim _{n \to \infty} S_{2 n}\]</span></p><p>因为 <span class="math inline">\(\left | \beta_{1} p_{1} + \beta_{2}p_{2} + \cdots + \beta_{5} p_{5} \right | \leq 1\)</span> , 所以当 <span class="math inline">\(n \to \infty\)</span> 时，只有 <span class="math inline">\(\beta_i\)</span> 全为 <span class="math inline">\(1\)</span> 或者 <span class="math inline">\(-1\)</span> 情况下，</p><p><span class="math display">\[\left | \sum_{i=1}^{5} \beta_{i} p_{i} \right | = 1\]</span></p><p>因此，我们可以得到答案：</p><p><span class="math display">\[\lim _{n \to \infty} \operatorname{Pr} \left \{X_{2n}^{(i)} \text { isall even } \right \} = \frac{1}{2^{5}} \left [ (+1)^{2n} + (-1)^{2n}\right ] = \frac{1}{16}\]</span></p><h1 id="problem-7">Problem 7</h1><p>有这么一个音乐盒，它上面有一个圆形的轨道，轨道上的一点处还有一棵开花的树。当音乐盒处于开启模式时，音乐盒会发出音乐，轨道会按照顺时针匀速转动。</p><p>你可以在轨道上放置象征恋人的两颗棋子，我们不妨称它们为小红和小绿。当小红和小绿没有到达树下时，它们就会在轨道上各自移动。当某一颗棋子到达树下时，它就会在树下原地等待一段时间。此段时间内，如果另外一颗棋子也达到了树下，那么两颗棋子就会相遇，之后在它们将随即一起顺着轨道移动，不再分开；否则，等待时间结束，两颗棋子将各自顺着轨道继续移动。</p><p>考虑这个音乐盒的数学模型。我们把这个圆形轨道参数化成一个周长为 <span class="math inline">\(1\)</span>的圆环，我们认为棋子和树都可以用圆环上点表示。具体来说，我们用 <span class="math inline">\(X(t) \in [0, 1]\)</span> 和 <span class="math inline">\(Y(t) \in [0, 1]\)</span> 分别表示 <span class="math inline">\(t\)</span>时刻小红和小绿的在轨道上的位置坐标，而树的坐标是 <span class="math inline">\(\phi = 1\)</span> ，或者，等价地， <span class="math inline">\(\phi = 0\)</span> 。</p><p>当他们都没有抵达树下时 (见左图) ，他们的位置变化规律满足</p><p><span class="math display">\[\frac{\mathrm{d}}{\mathrm{d} t} X(t)=1, \quad\frac{\mathrm{d}}{\mathrm{d} t} Y(t) = 1\]</span></p><p>假设在 <span class="math inline">\(t_0\)</span>时刻，小绿到达了树下（见中图），即 <span class="math inline">\(Y \left(t_0 \right) = 1\)</span> ，它就会至多等待</p><p><span class="math display">\[\tau = K \left (X \left( t_0 \right ) \right)\]</span></p><p>的时间，换句话说，最长等待时间依赖于小红的当时的位置。</p><p>在等待期间，小绿不动，小红继续移动。如果等待期间的某时刻 <span class="math inline">\(t^\ast \in \left(t_0, t_0+\tau\right]\)</span>，小红也达到了树下，即 <span class="math inline">\(X\left (t^\ast\right) = 1\)</span>，那么两棋子相遇。如果等待时间结束时（见右图），小红仍没有到达树下，那么它们俩继续移动，此时他们的位置分别是</p><p><span class="math display">\[X \left(t_0 + \tau \right) = X \left(t_0 \right) + \tau, \quad Y\left(t_0 + \tau \right) = 0 .\]</span></p><p>注意，虽然小绿的坐标被重置了，但是它在圆环上的位置并没有变。</p><p>如果在某时刻小红到达树下，它也会按照相同的规则等待，最长等待时间取决于此时小绿的位置。显然，小红小绿的命运取决于最长等待时间函数<span class="math inline">\(K(\phi)\)</span> 的形式。</p><figure><img src="https://www.longluo.me/assets/blog/images/math/2024-alibaba-math-contest-problem7.png" alt="图2. Problem 7"><figcaption aria-hidden="true">图2. Problem 7</figcaption></figure><ol type="1"><li><strong>证明题 (10分)</strong> 我们设 <span class="math inline">\(f:\mathbb{R} \to \mathbb{R}\)</span> 是一个光滑函数， 满足</li></ol><p><span class="math display">\[f^{\prime} &gt; 0, \quad f^{\prime \prime} &lt; 0, \quad f(0)=0, \quadf(1) = 1 .\]</span></p><p>并设 <span class="math inline">\(\varepsilon\)</span>是一个充分小的正的常数。我们定义等待时间函数</p><p><span class="math display">\[K(\phi ) = f^{-1}(f(\phi ) + \epsilon ) - \phi .\]</span></p><p>证明除了唯一的例外（特定的初始距离）之外，无论小红和小绿的初始距离如何，他们最终会相遇的。</p><ol start="2" type="1"><li><strong>问答题 (10分)</strong> 我们考虑一个如下形式的 <span class="math inline">\(f\)</span> 函数</li></ol><p><span class="math display">\[f(\phi ) = \frac {1}{b} \ln \left (1 + \left (e^b - 1 \right ) \phi\right )\]</span></p><p>这里 <span class="math inline">\(b&gt;0\)</span> 是一个常数。当 <span class="math inline">\(b \ll 1, \varepsilon \ll 1\)</span>时，请估算出相遇之前小红小绿走过的圈数的数量级。</p><h2 id="solution-8">Solution</h2><blockquote><p>[!TIP] 这道题考试的时候没做出来，最近几天看了知乎上关于这次考试的讨论<a href="https://www.zhihu.com/question/652949289">如何评价2024阿里巴巴数学竞赛预选赛试题?</a>，看了大神们的解答，发现这道题不难，不要以为它是压轴题就觉得很难。这道题的关键在于找到小红和小绿的距离递推关系式，然后对这个关系式进行分析。下面的解法参考了知乎Fiddie 的解答<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> ，<a href="https://www.zhihu.com/people/s7gp3x">喵喵</a> 的解答<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>，我综合他们的解题思路自己推了一遍。</p></blockquote><p>由题设条件，我们知道当小红和小绿都没有在树下时，都随着圆形轨道顺时针匀速转动，也因此小红和小绿<strong>只可能</strong>在树下相遇。</p><p>不妨设<strong>最初条件</strong>为小红在小绿的前方，两者的距离为 <span class="math inline">\(d_0, \ d_0 \in (0, 1)\)</span> ， <span class="math inline">\(d_0 \le 0\)</span> 或 <span class="math inline">\(d_0 \ge 1\)</span> 两者相遇无需讨论。</p><p>当小红来到树下，此时小绿距离树下还有一段距离，小红将在树下等待一段时间。假设在小红等待时间结束之前，小绿都没能赶到树下，那么在等待时间结束时，记为<span class="math inline">\(t_{k}\)</span> 时刻。在 <span class="math inline">\(t_{k}\)</span> 时小绿距离树下还有 <span class="math inline">\(d_k\)</span> 的距离，即 <span class="math inline">\(X(t_k) = 0, \ Y(t_k) = 1 - d_k\)</span> 。</p><p>小红继续出发，在 <span class="math inline">\(d_k\)</span> 时之后，即<span class="math inline">\(t_k + d_k\)</span>时小绿将到达树下。此时小红已经出发了 <span class="math inline">\(d_k\)</span> 的距离，即 <span class="math inline">\(X(t_k) = d_k, \ Y(t_k) = 1\)</span> 。</p><p>小绿将在树下等待小红 <span class="math inline">\(\tau = K \left (X\left (d_{k} \right ) \right )\)</span> 的时间，即：</p><p><span class="math display">\[\begin{equation}\tau = K \left (X \left (d_{k} \right ) \right ) = f^{-1}(f(d_k) +\varepsilon) - d_k   \tag{7.1.1} \label{7.1.1}\end{equation}\]</span></p><p>分析 <span class="math inline">\(\eqref{7.1.1}\)</span> 可知：</p><ol type="1"><li><p>如果 <span class="math inline">\(f^{-1}(f(d_k) + \varepsilon) \ge1\)</span>，则小红将在等待时间结束之前到达树下，小红和小绿相遇，结束分析。</p></li><li><p>如果 <span class="math inline">\(f^{-1}(f(d_k) + \varepsilon)&lt; 1\)</span>，那么在小绿等待时间结束之前，小红没能赶到树下。</p></li></ol><p>在小绿等待时间结束那一刻，我们记为 <span class="math inline">\(t_{k+1}\)</span> 时刻，此时 <span class="math inline">\(X(t_{k+1}) = f^{-1}(f(d_k) + \varepsilon), \Y(t_{k+1}) = 0\)</span> ，两者距离为：</p><p><span class="math display">\[\begin{equation}d_{k+1} = 1 - f^{-1}(f(d_k) + \varepsilon)    \tag{7.1.2} \label{7.1.2}\end{equation}\]</span></p><p>至此我们找到了小红与小绿之间的<strong>距离递推关系式</strong>。</p><p>设两者之间<strong>距离数列</strong> ${ d_n } $表示一个人刚要从树下出发，另外一个距离树下的距离，那么问题转化为：对于任意初值<span class="math inline">\(d_0 \in (0, 1)\)</span>，除了某个特定的初始距离值之外，都存在某个 <span class="math inline">\(k\in \mathrm{Z^+}\)</span> ，使得数列 <span class="math inline">\(d_k \le0\)</span> 或者 <span class="math inline">\(d_k \ge 1\)</span> 。</p><p>这里我们需要证明 <span class="math inline">\(2\)</span> 种情况：</p><ol type="1"><li>存在某个特定的初始距离，使得小红和小绿永远不相遇；</li><li>除了某个特定的初始距离之外，小红和小绿总会相遇。</li></ol><p>考虑函数 <span class="math inline">\(g(x)\)</span>表示两者之间距离，函数 <span class="math inline">\(h(x)\)</span>表示前后时刻（ <span class="math inline">\(t_{k}\)</span> 和 <span class="math inline">\(t_{k+1}\)</span>）两者之间的<strong>距离变化</strong>，即 <span class="math inline">\(\Delta d = d_{k+1} - d_k = 1 - f^{-1}(f(d_k) +\varepsilon) - d_k\)</span> 。</p><p>则有：</p><p><span class="math display">\[\begin{equation}g(x) = 1 - f^{-1}(f(x) + \varepsilon) , \ x \in (0, 1)     \tag{7.1.3}\label{7.1.3}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}h(x) = g(x) - x = 1 - f^{-1}(f(x) + \varepsilon) - x     \tag{7.1.4}\label{7.1.4}\end{equation}\]</span></p><p>对 <span class="math inline">\(g(x) , \ h(x)\)</span> 求导可得：</p><p><span class="math display">\[\begin{equation}g^{\prime}(x) = \frac{\mathrm{d} g(x)}{\mathrm{d} x} = -\frac{f^{\prime}(x)} {f^{\prime}\left(f^{-1}(f(x) +\varepsilon)\right)}  \tag{7.1.5} \label{7.1.5}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}h^{\prime}(x) = \frac{\mathrm{d} h(x)}{\mathrm{d} x} = -1 -\frac{f^{\prime}(x)} {f^{\prime}\left(f^{-1}(f(x) +\varepsilon)\right)}  \tag{7.1.6} \label{7.1.6}\end{equation}\]</span></p><p>因为 <span class="math inline">\(f^{\prime}&gt;0 , f^{\prime \prime}&lt; 0\)</span> ，所以 <span class="math inline">\((f^{-1})^{\prime}&gt;0\)</span> , <span class="math inline">\(\left(f^{-1}\right)^{\prime \prime}&gt;0\)</span>，</p><p>又 <span class="math inline">\(h(0) = 1 - f^{-1}(\varepsilon) &gt;0\)</span> ， <span class="math inline">\(h(1) = - f^{-1}(f(1) +\varepsilon) &lt; 0\)</span> ，所以 <span class="math inline">\(h(x)\)</span> 在</p><p>针对第 <span class="math inline">\(1\)</span>种情况，需要证明：<strong>存在性</strong>和<strong>唯一性</strong>。</p><p>设距离数列 ${ d_n } $ 存在某个初值 <span class="math inline">\(d_0 =d^\ast\)</span> 满足公式 <span class="math inline">\(\eqref{7.1.2}\)</span> 使得 <span class="math inline">\(d_k = d^\ast , k = 0, 1, \cdots , n\)</span>，所以：</p><p><span class="math display">\[\begin{equation}d_{k+1} = d_k \Leftrightarrow d^\ast = 1 - f^{-1} \left (f(d^\ast) +\varepsilon \right )  \end{equation}\]</span></p><p>进一步化简可得：</p><p><span class="math display">\[\begin{equation}f(1 - d^\ast) = f(d^\ast) + \varepsilon         \end{equation}\]</span></p><p>设 <span class="math inline">\(x_1 = d^\ast, \ x_2 = 1 -d^\ast\)</span> ，那么 <span class="math inline">\(x_1, \ x_2\)</span>关于 <span class="math inline">\(\frac{1}{2}\)</span> 对称，那么存在<span class="math inline">\(x_1 = \frac{1}{2} - \varepsilon^\ast ，x_2 =\frac{1}{2} + \varepsilon^\ast, \ \varepsilon^\ast &gt; 0\)</span>。</p><p>根据题设条件 <span class="math inline">\(f^{\prime} &gt; 0\)</span>， <span class="math inline">\(f(0) = 0, \ f(1) = 1\)</span> ， <span class="math inline">\(f\)</span> 在 <span class="math inline">\([0,1]\)</span> 是<strong>单调递增</strong>的光滑函数，那么 <span class="math inline">\(f(x_2) &gt; f(x_1) &gt; 0\)</span>，故<strong>存在性</strong>得证。</p><p>下面来证明<strong>唯一性</strong>，由公式 <span class="math inline">\(\eqref{7.1.5}\)</span> ，可得： <span class="math inline">\(f(1 - d^\ast) - f(d^\ast) = \varepsilon\)</span>。</p><p>令函数 <span class="math inline">\(g(x) = f(1 - x) - f(x), \ x \in(0,1)\)</span> ，对 <span class="math inline">\(g(x)\)</span> 求导：</p><p><span class="math display">\[\begin{equation}g^{\prime}(x) = - f^{\prime}(1 - x) - f^{\prime}(x) &lt; 0 , \ x \in(0,1)      \end{equation}\]</span></p><p><span class="math inline">\(g(x)\)</span> 单调递减， <span class="math inline">\(g(0) = 1, \ g(\frac{1}{2}) = 0\)</span> ，<span class="math inline">\(g(x)\)</span>连续，故<strong>有且仅存在一个</strong> <span class="math inline">\(x\in (0, \frac{1}{2})\)</span> ，使得 <span class="math inline">\(g(x) =\varepsilon\)</span> ，所以<strong>唯一性</strong>得证。</p><p>故存在某个特定的初始距离 <span class="math inline">\(d_0 =d^\ast\)</span> ，使得小红和小绿永远不相遇。</p><p>下面来证明 <span class="math inline">\(d_0 \ne d^\ast\)</span>的情况，这里也可以分为 <span class="math inline">\(2\)</span>种情况讨论，<span class="math inline">\(0 &lt; d_0 &lt; d^\ast\)</span>和 <span class="math inline">\(d^\ast &lt; d_0 &lt; 1\)</span> 。</p><p><span class="math display">\[\phi_{n+1}=g\left(g\left(\phi_n\right)\right)=1-\left(g\left(\phi_n\right)+K\left(g\left(\phi_n\right)\right)\right)=\phi_n+K\left(\phi_n\right)-K\left(g\left(\phi_n\right)\right)&lt;\phi_n\]</span> , also <span class="math inline">\(g\left(\phi_{n+1}\right)&gt;g\left(\phi_n\right)\)</span>.Then</p><p><span class="math display">\[\phi_{n+1}-\phi_{n+2}=K\left(g\left(\phi_{n+1}\right)\right)-K\left(\phi_{n+1}\right)&gt;K\left(g\left(\phi_n\right)\right)-K\left(\phi_n\right)=\phi_n-\phi_{n+1}\]</span></p><p>, showing that</p><p><span class="math display">\[d_k = d_0 - (d_0 - d_1) - (d_1 - d_2) - \cdots - (d_{k-1} - d_k) \leqd_0 - k(d_0 - d_1)\]</span></p><p>故所求上界 <span class="math inline">\(k = \left \lceil\frac{d_0}{d_0 - d_1} \right \rceil\)</span> ，使得 <span class="math inline">\(d_k \leq 0\)</span> ，小红和小绿终将相遇。</p><p><span class="math display">\[d_k = d_0 + (d_0 - d_1) + (d_1 - d_2) + \cdots + (d_{k-1} - d_k) \ge d_0+ k(d_0 - d_1)\]</span></p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Poisson_point_process">泊松过程</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://en.wikipedia.org/wiki/Poisson_distribution">泊松分布</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Binomial_distribution">二项分布</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Binomial_theorem">二项式定理</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Multinomial_theorem">多项式定理</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://www.zhihu.com/question/652949289/answer/3466235067">Fiddie的试题解答</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://zhuanlan.zhihu.com/p/692476253">喵喵的试题解答</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://damo.alibaba.com/?language=zh&quot;&gt;阿里巴巴达摩院&lt;/a&gt; 从
2018
年开始每年都会举办一届全球数学竞赛，之前一方面自己数学水平比较弱，另外一方面也没有报名，但一直很仰慕那些数学大神的风采。今年是第一次报名参加
&lt;a href=&quot;https://damo.alibaba.com/alibaba-global-mathematics-competition?language=zh&quot;&gt;2024阿里巴巴全球数学竞赛&lt;/a&gt;
，上周末参加了预选赛，但遗憾的是，全部 &lt;span class=&quot;math inline&quot;&gt;&#92;(7&#92;)&lt;/span&gt; 道题中只有第 &lt;span class=&quot;math inline&quot;&gt;&#92;(1, 2, 6&#92;)&lt;/span&gt; 题会做，这里分享下我的解答：&lt;/p&gt;
&lt;h1 id=&quot;problem-1&quot;&gt;Problem 1&lt;/h1&gt;
&lt;p&gt;几位同学假期组成一个小组去某市旅游. 该市有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 座塔，它们的位置分别为 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D, E, F&#92;)&lt;/span&gt;
。同学们自由行动一段时间后，每位同学都发现，自己在所在的位置只能看到位于
&lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D&#92;)&lt;/span&gt; 处的四座塔，而看不到位于
&lt;span class=&quot;math inline&quot;&gt;&#92;(E&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; 的塔。已知：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;同学们的位置和塔的位置均视为同一平面上的点，且这些点彼此不重合；&lt;/li&gt;
&lt;li&gt;塔中任意 &lt;span class=&quot;math inline&quot;&gt;&#92;(3&#92;)&lt;/span&gt; 点不共线；&lt;/li&gt;
&lt;li&gt;看不到塔的唯一可能就是视线被其它的塔所阻挡，例如，如果某位同学所在的位置
&lt;span class=&quot;math inline&quot;&gt;&#92;(P&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;(A
, B&#92;)&lt;/span&gt; 共线，且 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; 在线段
&lt;span class=&quot;math inline&quot;&gt;&#92;(PB&#92;)&lt;/span&gt; 上，那么该同学就看不到位于 &lt;span class=&quot;math inline&quot;&gt;&#92;(B&#92;)&lt;/span&gt; 处的塔。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;（5 分）&lt;/strong&gt; 请问 这个旅游小组最多可能有多少名同学？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(A. 3&#92;)&lt;/span&gt;&lt;br&gt;
&lt;span class=&quot;math inline&quot;&gt;&#92;(B. 4&#92;)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;&#92;(C.
6&#92;)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;&#92;(D. 12&#92;)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;这道题选 &lt;span class=&quot;math inline&quot;&gt;&#92;(C&#92;)&lt;/span&gt; ，最多只能有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 名同学。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP] 这道题的解题思路是，从假设只有 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 座塔开始，一直到 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 座塔，找到思路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; ，那么很显然有无数多同学可以看到塔
&lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; ，也可以有无数多同学看不到塔
&lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt;​ ；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B&#92;)&lt;/span&gt; ，那么只有以 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; 为起点的射线 &lt;span class=&quot;math inline&quot;&gt;&#92;(AB&#92;)&lt;/span&gt; 且位于 &lt;span class=&quot;math inline&quot;&gt;&#92;(B&#92;)&lt;/span&gt; 之后的同学无法看到塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; ；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(3&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C&#92;)&lt;/span&gt;
，同理可知存在无数位同学至少可以看见 &lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 座塔；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(4&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D&#92;)&lt;/span&gt;
，同理可知存在无数位同学至少可以看见 &lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 座塔；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D, E, F&#92;)&lt;/span&gt; ，如果每位同学都无法看见
&lt;span class=&quot;math inline&quot;&gt;&#92;(E, F&#92;)&lt;/span&gt; 塔，如下图1 所示：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/math/2024-alibaba-math-contest-problem1-solution.png&quot; alt=&quot;图1. Solution of Problem 1&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图1. Solution of Problem 1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;所以至多有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 位同学位于 &lt;span class=&quot;math inline&quot;&gt;&#92;(M, N, O, P, R, Q&#92;)&lt;/span&gt; 处，无法看到塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(E, F&#92;)&lt;/span&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Geometry" scheme="https://www.longluo.me/tags/Geometry/"/>
    
    <category term="Algebra" scheme="https://www.longluo.me/tags/Algebra/"/>
    
    <category term="Probability" scheme="https://www.longluo.me/tags/Probability/"/>
    
    <category term="Analysis" scheme="https://www.longluo.me/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>库函数 (libm) 是如何计算三角函数值的？</title>
    <link href="https://www.longluo.me/blog/2024/02/16/sine/"/>
    <id>https://www.longluo.me/blog/2024/02/16/sine/</id>
    <published>2024-02-16T12:32:58.000Z</published>
    <updated>2024-03-04T13:16:46.732Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑！</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the trigonometric sine of an angle.  Special cases:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the</span></span><br><span class="line"><span class="comment"> * result is NaN.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;If the argument is zero, then the result is a zero with the</span></span><br><span class="line"><span class="comment"> * same sign as the argument.&lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The computed result must be within 1 ulp of the exact result.</span></span><br><span class="line"><span class="comment"> * Results must be semi-monotonic.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   a   an angle, in radians.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the sine of the argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> a)</span> {</span><br><span class="line">    <span class="keyword">return</span> StrictMath.sin(a); <span class="comment">// default impl. delegates to StrictMath</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the trigonometric sine of an angle. Special cases:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the</span></span><br><span class="line"><span class="comment"> * result is NaN.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;If the argument is zero, then the result is a zero with the</span></span><br><span class="line"><span class="comment"> * same sign as the argument.&lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   a   an angle, in radians.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the sine of the argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> a)</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @(#)k_sin.c 1.3 95/01/18 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ====================================================</span></span><br><span class="line"><span class="comment"> * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Developed at SunSoft, a Sun Microsystems, Inc. business.</span></span><br><span class="line"><span class="comment"> * Permission to use, copy, modify, and distribute this</span></span><br><span class="line"><span class="comment"> * software is freely granted, provided that this notice</span></span><br><span class="line"><span class="comment"> * is preserved.</span></span><br><span class="line"><span class="comment"> * ====================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* __kernel_sin( x, y, iy)</span></span><br><span class="line"><span class="comment"> * kernel sin function on [-pi/4, pi/4], pi/4 ~ 0.7854</span></span><br><span class="line"><span class="comment"> * Input x is assumed to be bounded by ~pi/4 in magnitude.</span></span><br><span class="line"><span class="comment"> * Input y is the tail of x.</span></span><br><span class="line"><span class="comment"> * Input iy indicates whether y is 0. (if iy=0, y assume to be 0). </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Algorithm</span></span><br><span class="line"><span class="comment"> *1. Since sin(-x) = -sin(x), we need only to consider positive x. </span></span><br><span class="line"><span class="comment"> *2. if x &lt; 2^-27 (hx&lt;0x3e400000 0), return x with inexact if x!=0.</span></span><br><span class="line"><span class="comment"> *3. sin(x) is approximated by a polynomial of degree 13 on</span></span><br><span class="line"><span class="comment"> *   [0,pi/4]</span></span><br><span class="line"><span class="comment"> *           3            13</span></span><br><span class="line"><span class="comment"> *   sin(x) ~ x + S1*x + ... + S6*x</span></span><br><span class="line"><span class="comment"> *   where</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * |sin(x)         2     4     6     8     10     12  |     -58</span></span><br><span class="line"><span class="comment"> * |----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| &lt;= 2</span></span><br><span class="line"><span class="comment"> * |  x            | </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *4. sin(x+y) = sin(x) + sin'(x')*y</span></span><br><span class="line"><span class="comment"> *    ~ sin(x) + (1-x*x/2)*y</span></span><br><span class="line"><span class="comment"> *   For better accuracy, let </span></span><br><span class="line"><span class="comment"> *     3      2      2      2      2</span></span><br><span class="line"><span class="comment"> *r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))</span></span><br><span class="line"><span class="comment"> *   then                   3    2</span></span><br><span class="line"><span class="comment"> *sin(x) = x + (S1*x + (x *(r-y/2)+y))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FDLIBM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fdlibm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> __kernel_sin(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">int</span> iy)</span><br><span class="line">{</span><br><span class="line"><span class="type">double</span> z, r, v;</span><br><span class="line"><span class="type">int32_t</span> ix;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> half = <span class="number">5.00000000000000000000e-01</span>;<span class="comment">/* 0x3FE00000, 0x00000000 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S1 = <span class="number">-1.66666666666666324348e-01</span>;<span class="comment">/* 0xBFC55555, 0x55555549 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S2 = <span class="number">8.33333333332248946124e-03</span>;<span class="comment">/* 0x3F811111, 0x1110F8A6 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S3 = <span class="number">-1.98412698298579493134e-04</span>;<span class="comment">/* 0xBF2A01A0, 0x19C161D5 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S4 = <span class="number">2.75573137070700676789e-06</span>;<span class="comment">/* 0x3EC71DE3, 0x57B1FE7D */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S5 = <span class="number">-2.50507602534068634195e-08</span>;<span class="comment">/* 0xBE5AE5E6, 0x8A2B9CEB */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S6 = <span class="number">1.58969099521155010221e-10</span>;<span class="comment">/* 0x3DE5D93A, 0x5ACFD57C */</span></span><br><span class="line"></span><br><span class="line">GET_HIGH_WORD(ix, x);</span><br><span class="line">ix &amp;= IC(<span class="number">0x7fffffff</span>);<span class="comment">/* high word of x */</span></span><br><span class="line"><span class="keyword">if</span> (ix &lt; IC(<span class="number">0x3e400000</span>))<span class="comment">/* |x| &lt; 2**-27 */</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int32_t</span>) x == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x;<span class="comment">/* generate inexact */</span></span><br><span class="line">}</span><br><span class="line">z = x * x;</span><br><span class="line">v = z * x;</span><br><span class="line">r = S2 + z * (S3 + z * (S4 + z * (S5 + z * S6)));</span><br><span class="line"><span class="keyword">if</span> (iy == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x + v * (S1 + z * r);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> x - ((z * (half * y - v * r) - y) - v * S1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="math display">\[\sin (x_0 + \Delta x) \approx \sin (x_0) + \sin'(x_0) \frac {\Deltax}{1!} + \sin''(x_0) \frac { \Delta x^2}{2!} +\sin'''(x_0) \frac {\Delta x^3}{3!} + \cdots\]</span></p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/C_mathematical_functions">Cmathematical functions</a></li><li><a href="https://en.wikipedia.org/wiki/Sine_and_cosine">Sine andcosine</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑！&lt;/h1&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>切比雪夫滤波器</title>
    <link href="https://www.longluo.me/blog/2024/02/03/chebyshev-filters/"/>
    <id>https://www.longluo.me/blog/2024/02/03/chebyshev-filters/</id>
    <published>2024-02-03T02:17:19.000Z</published>
    <updated>2024-06-28T12:33:12.169Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><span id="more"></span><h1 id="characteristics-of-chebyshev-filters">1. Characteristics ofChebyshev filters</h1><h2 id="a.-introduction-to-chebyshev-filter">a. Introduction toChebyshev Filter</h2><p>Like the <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a>, the Chebyshev filter is an all-pole filter that is primarilydesigned for low-pass filter design.</p><p>As described in the previous post about the <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a>, this post will also focus on the design of low-pass filtersusing Chebyshev filters.</p><p>In general, the Chebyshev filter can be considered the closest to anideal filter when compared to other types of filters, excluding ellipticfilters. This is because for the same filter order (<span class="math inline">\(N\)</span>) and specification requirements, thetransition band is the narrowest and the transition slope is thesteepest.</p><p>Note that elliptic filters can only be created using numericalmethods. Therefore, excluding elliptic filters, the Chebyshev filter isthe most optimal type of filter that can be determined throughmathematical equations.</p><h2 id="b.-shape-of-chebyshev-filters">b. Shape of ChebyshevFilters</h2><p>So let’s take a look at the rough shape of the Chebyshev filter.</p><p align="center"><img width="400" src="https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-09-27-Chebyshev/pic1.png"><br> Figure 1. Rough form of Chebyshev filter <br><a href="https://en.wikipedia.org/wiki/Chebyshev_filter"> Source:Wikipedia Chevyshev filter</a></p><p>The most notable characteristic visible from its appearance is theripple within the passband.</p><p>To list some of the characteristics of the Chebyshev filter in moredetail:</p><p>① It is not a monotonic filter.</p><p>② It has equal ripple (Equi-Ripple).</p><p>In Type I Chebyshev filters, there is ripple within the passband, butthe stopband shows a monotonic trend. In contrast, Type II shows theopposite trend, and Type II can be obtained by reversing Type I.However, Type I is preferred because Type II is vulnerable tounnecessary signal removal in the role of a lowpass filter.</p><p>As for the reason for ②, it will be explained in more detail later,but there is a difference between the ripple shape in the figure and theactual periodic ripple that exists, and there is also a formula for theripple. The equation that determines the shape and period of the rippleis called the Chebyshev Polynomial and is denoted by <span class="math inline">\(C_N(x)\)</span>.</p><h2 id="c.-what-can-we-learn-from-the-equations">c.&nbsp;What can we learnfrom the equations?</h2><p>The Chebyshev filter is defined by the following equation:</p><p><span class="math display">\[|H_a(j\Omega)|^2 = A^2 / \left\lbrace1+\epsilon^2C_N\left(\frac{\Omega}{\Omega_p}\right)\right\rbrace\]</span></p><p>or</p><p><span class="math display">\[|H_a(j\Omega)| = A / \sqrt{ 1+\epsilon^2C_N\left(\frac{\Omega}{\Omega_p}\right)}\]</span></p><p>Here, A is the gain factor. Typically, if you don’t wantamplification at the passband frequency, set A to 1.</p><p>If we take a closer look at this equation, we can see thecharacteristics of the Chebyshev filter. When compared specifically tothe <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a>, it can help us to gain a more intuitive understanding. Theequation for the <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a> is as follows:</p><p><span class="math display">\[|H_a(j\Omega)|^2 = 1/\left\lbrace1+\left(\frac{\Omega}{\Omega_c}\right)\right\rbrace\]</span></p><p>In other words, the equation for the Chebyshev filter containselements that are not present in the equation for the <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a>, namely <span class="math inline">\(\epsilon\)</span> and<span class="math inline">\(C_N(x)\)</span>. A minor but importantdifference between the Chebyshev and <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a> is that the Chebyshev filter equation includes <span class="math inline">\(\Omega_p\)</span>, while the <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a> includes <span class="math inline">\(\Omega_c\)</span>. Thismeans that when implementing the Chebyshev filter, we do not directlyneed <span class="math inline">\(\Omega_c\)</span>.</p><p><span class="math inline">\(\epsilon\)</span> determines the size ofthe ripple, while <span class="math inline">\(C_N(x)\)</span> determinesthe shape of the ripple based on the order N of the filter. <span class="math inline">\(C_N(x)\)</span> is defined as follows:</p><p><span class="math display">\[C_N(x) =\begin{cases}\cos(N\cos^{-1}(x)) &amp;&amp; \text{ for } |x| \leq 1\\\cosh(N\cosh^{-1}(x)) &amp;&amp; \text{ for } |x| \gt1\end{cases}\]</span></p><p>If we examine this equation closely, we can see why the range of<span class="math inline">\(x\)</span> is defined around 1. This isbecause the function <span class="math inline">\(cos^{-1}(x)\)</span> isdefined for <span class="math inline">\(\|x\|\leq 1\)</span>, and thevalues of <span class="math inline">\(C_N(x)\)</span> are different when<span class="math inline">\(\Omega\)</span> is greater than or less than<span class="math inline">\(\Omega_p\)</span>. In other words,</p><p>① <span class="math inline">\(cos(N\cos^{-1}(x))\)</span> is a cosinefunction, which means that it will have ripple, and this ripple willhave a period of <span class="math inline">\(N\cos^{-1}(x)/{2\pi}\)</span>.</p><p>② <span class="math inline">\(\cosh(N\cosh^{-1}(x))\)</span> is not aperiodic function. The <span class="math inline">\(\cosh(x)\)</span>function is called the hyperbolic cosine and is defined as follows:</p><p><span class="math display">\[\cosh(x) = \frac{e^x+e^{-x}}{2} =\cos(jx)\]</span></p><p>Therefore, from the equation, we can see that when <span class="math inline">\(\Omega\leq\Omega_p\)</span>, the function hasperiodic ripple, and when <span class="math inline">\(\Omega&gt;\Omega_p\)</span>, it is a monotonicfunction.</p><h2 id="c.-the-shape-of-chebyshev-filter-depending-on-n">c.&nbsp;The Shape ofChebyshev Filter Depending on N</h2><p>Let’s write the formula for the Chebyshev filter again:</p><p><span class="math display">\[|H_a(j\Omega)| = A / \sqrt{ 1+\epsilon^2C_N\left(\frac{\Omega}{\Omega_p}\right)}\]</span></p><p>Here, let’s think about the maximum and minimum values of <span class="math inline">\(\|H_a(j\Omega)\|\)</span> to draw the shape of theChebyshev filter.</p><p><span class="math inline">\(C_N\)</span> oscillates for <span class="math inline">\(0\leq\Omega\leq\Omega_p\)</span> and its valuesatisfies <span class="math inline">\(0\leq C^2_N\leq 1\)</span>.</p><p><span class="math display">\[\frac{A}{\sqrt{1+\epsilon^2}}\leq|H_a(j\Omega)|\leqA \]</span></p><p>If we assume that <span class="math inline">\(A=1\)</span> here,</p><p><span class="math display">\[\frac{1}{\sqrt{1+\epsilon^2}}\leq|H_a(j\Omega)|\leq1 \]</span></p><p>Therefore, for each degree N of the filter, we can see its shape asfollows:</p><p>When <span class="math inline">\(N=1\)</span>,</p><p align="center"><img src="https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-09-27-Chebyshev/pic4.png"><br> Figure 4. The shape of Chebyshev filter for <span class="math inline">\(N=1\)</span></p><p>Since <span class="math inline">\(N\)</span> is odd, <span class="math inline">\(C_1(0)=0\)</span>. Also, <span class="math inline">\(\|H_a(j\Omega)\|_{\Omega = 0}=1\)</span>.</p><p>Therefore, we can see that when N=1, the Chebyshev filter starts at1. Moreover, when N=1, it has a similar appearance to a <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a>. However, depending on the value of <span class="math inline">\(\epsilon\)</span>, it may or may not have the samevalues as a <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a>, so having a similar shape does not necessarily mean that itis the same filter.</p><p>When N=2,</p><p><span class="math display">\[C_2(0)=2\times0^2-1=-1\]</span></p><p>and,</p><p><span class="math display">\[C_2(\Omega_p)=1\]</span></p><p>Therefore,</p><p><span class="math display">\[|H_a(0)|=\frac{1}{\sqrt{1+\epsilon^2}}\]</span></p><p>If we draw the shape of the filter, we get the following:</p><p align="center"><img src="https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-09-27-Chebyshev/pic5.png"><br> Figure 5. Shape of the Chebyshev filter when N=2.</p><p>We can also draw the Chebyshev filter for N=3 and N=4,respectively.</p><p align="center"><img src="https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-09-27-Chebyshev/pic6.png"><br> Figure 6. Shape of the Chebyshev filter when N=3 and N=4,respectively.</p><p>When we look at this point, all Chebyshev filters have one thing incommon, which is that all Chebyshev filters pass through the point</p><p><span class="math display">\[\left(\Omega_p,\frac{1}{\sqrt{1+\epsilon^2}}\right)\]</span></p><p>regardless of the size of <span class="math inline">\(N\)</span>.</p><p>This can be explained by the fact that all Chebyshev Polynomials passthrough <span class="math inline">\((1,1)\)</span>, or that <span class="math inline">\(C_N(x)=\cos(N\cos^{-1}(x))\)</span> and <span class="math inline">\(C_N(x)=\cos(N\cos^{-1}(x))=\cos(N\times2\pi)=1\)</span> can be directly proven. We will be able to calculatethe size of <span class="math inline">\(N\)</span> later using thisfact.</p><p>To summarize a few facts,</p><p>① The number of Maxima &amp; Minima within the Passband = N</p><p>② If <span class="math inline">\(N\)</span> = even, starting point =<span class="math inline">\(1/\sqrt{1+\epsilon^2}\)</span></p><p>else if <span class="math inline">\(N\)</span> = odd, starting point= <span class="math inline">\(1\)</span></p><p>One more thing to consider here is how to find the 3dB frequency (orcutoff frequency). Using the definition of 3dB, it can be expressedas:</p><p><span class="math display">\[|H_a(j\Omega)|^2 =\frac{1}{2}\]</span></p><p>Therefore,</p><p><span class="math display">\[1/\left\lbrace1+\epsilon^2C_N\left(\frac{\Omega_{3dB}}{\Omega_p}\right)\right\rbrace=\frac{1}{2}\]</span></p><p><span class="math display">\[\therefore \epsilon^2C^2_N\left(\frac{\Omega_{3dB}}{\Omega_p}\right)= 1\]</span></p><p><span class="math display">\[C_N\left(\frac{\Omega_{3dB}}{\Omega_p}\right)=\frac{1}{\epsilon}\]</span></p><p>Typically, <span class="math inline">\(\epsilon\)</span> is definedas a “small value,” and because of the characteristics of the Chebyshevfilter, <span class="math inline">\(\epsilon\)</span> must be less than1. Therefore, if we use <span class="math inline">\(C_N(x)=\cosh(N\cosh^{-1}(x))\)</span>, we canobtain:</p><p><span class="math display">\[\cosh\left(N\cosh^{-1}\left(\frac{\Omega_{3dB}}{\Omega_p}\right)\right)=\frac{1}{\epsilon}\]</span></p><p><span class="math display">\[\therefore\Omega_{3dB}=\Omega_p\left\lbrace\cosh\left(\frac{1}{N}\cosh^{-1}(1/\epsilon)\right)\right\rbrace\]</span></p><h1 id="general-transfer-function-of-chebyshev-filter-in-s-domain">3.General transfer function of Chebyshev filter in s-domain</h1><h2 id="a.-finding-poles-of-chebyshev-filter">a. Finding poles ofChebyshev filter</h2><p>According to the definition of a pole, a pole can be said to be avalue of s that satisfies the following equation:</p><p><span class="math display">\[1+\epsilon^2C^2_N\left(\frac{s}{j\Omega_p}\right)= 0\]</span></p><p>However, unfortunately, I couldn’t fully understand the algebraneeded to solve this equation. Therefore, I will omit the explanation ofthe algebra to find poles.</p><p>However, the conclusion is that when we find the poles, they will belocated on an ellipse, unlike the poles of the <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a>. For a detailed explanation, please refer to Wikipedia.</p><h2 id="b.-the-transfer-function-of-chebyshev-filter">b. The transferfunction of Chebyshev filter</h2><p>Like the <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a>, the Chebyshev filter can also be divided into two cases whenthe degree of N is even and odd. As seen in the overall shape of theChebyshev filter according to the degree of N described above, thestarting point differs depending on whether N is even or odd, andtherefore the formula also changes accordingly.</p><p><span class="math inline">\(N\)</span> : odd</p><p align="center"><img src="https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-09-27-Chebyshev/pic_eq_N_odd.png"></p><p><span class="math inline">\(N\)</span> : even</p><p align="center"><img src="https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-09-27-Chebyshev/pic_eq_N_even.png"></p><p>As can be seen from the above equations, when N is even, the startingpoint is <span class="math inline">\(1/\sqrt{1+\epsilon^2}\)</span>,which is multiplied in the numerator. Regarding each constant <span class="math inline">\(c_0\)</span>, <span class="math inline">\(b_k\)</span>, and <span class="math inline">\(c_k\)</span>, we can say that:</p><p><span class="math display">\[c_0 = y_N\]</span></p><p><span class="math display">\[c_k =y^2_N+\cos^2\left(\frac{2k-1}{2N}\pi\right)\]</span></p><p><span class="math display">\[b_k = 2y_N\sin\left(\frac{2k-1}{2N}\pi\right)\]</span></p><p><span class="math display">\[y_N =\frac{1}{2}\left\lbrace  \left(\sqrt{1+\frac{1}{\epsilon^2}}+\frac{1}{\epsilon}\right)^{\frac{1}{N}}-  \left(\sqrt{1+\frac{1}{\epsilon^2}}+\frac{1}{\epsilon}\right)^{-\frac{1}{N}}\right\rbrace\]</span></p><p>Finally, we need to consider how to determine N and <span class="math inline">\(\epsilon\)</span>.</p><h2 id="c.-how-to-determine-n-and-epsilon">c.&nbsp;How to determine <span class="math inline">\(N\)</span> and <span class="math inline">\(\epsilon\)</span></h2><p>When designing a filter, one must be aware of the specificationsreceived, which are <span class="math inline">\(\Omega_p, \Omega_s,\delta_p,\)</span> and <span class="math inline">\(\delta_s\)</span>.These are the requirements that the filter should meet. They are notmathematically determined but are set by the designer or thecustomer.</p><p>Generally, the relationship between specifications can be expressedas follows:</p><p align="center"><img src="https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-09-27-Chebyshev/pic7.png"><br> Figure 7. Specifications given when designing a filter</p><p>As explained earlier, since <span class="math inline">\(\delta_p\)</span> is a given value,</p><p><span class="math display">\[\delta_p =\frac{1}{\sqrt{1+\epsilon^2}}\]</span></p><p><span class="math display">\[\therefore \epsilon =\sqrt{\frac{1}{\delta^2_p-1}}\]</span></p><p>The value of <span class="math inline">\(N\)</span> can be determinedas follows:</p><p>Using the fact that <span class="math inline">\(\delta_s\)</span> isalso a given value,</p><p><span class="math display">\[1/\left\lbrace1+\epsilon^2C_N\left(\frac{\Omega_s}{\Omega_p}\right)\right\rbrace=\delta_s^2\]</span></p><p><span class="math display">\[\therefore\epsilon^2C^2_N\left(\frac{\Omega_s}{\Omega_p}\right)=\frac{1}{\delta_s}-1\]</span></p><p><span class="math display">\[C_N\left(\frac{\Omega_s}{\Omega_p}\right)=\sqrt{\frac{1/\delta_s^2-1}{1/\delta^2_p- 1}}\]</span></p><p>Here,</p><p><span class="math display">\[\left(\frac{\Omega_s}{\Omega_p}\right)\gt1\]</span></p><p>so,</p><p><span class="math display">\[C_N\left(\frac{\Omega_s}{\Omega_p}\right)=\cosh\left(N\cosh^{-1}\left(\frac{\Omega_s}{\Omega_p}\right)\right)= \sqrt{\frac{1/\delta_s^2-1}{1/\delta^2_p - 1}}\]</span></p><p><span class="math display">\[N_C\geq\frac{\cosh^{-1}\left(\sqrt{\frac{1/\delta_s^2-1}{1/\delta^2_p-1}}\right)}{\cosh^{-1}\left(\frac{\Omega_s}{\Omega_p}\right)}\]</span></p><p>we can find <span class="math inline">\(N_C\)</span> that satisfiesthe above equation. (Here, <span class="math inline">\(C\)</span> in<span class="math inline">\(N_C\)</span> stands for Chebyshev.)</p><p>For reference, the order <span class="math inline">\(N_B\)</span> ofthe <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a> was as follows:</p><p><span class="math display">\[N_B\geq\frac{\log_{10}\sqrt{\frac{1/\delta^2_s-1}{1/\delta^2_p-1}}}{\log_{10}\left(\frac{\Omega_s}{\Omega_p}\right)}\]</span></p><p>In the end, we can say that the methods for determining <span class="math inline">\(N\)</span> in Chebyshev and <a href="https://angeloyeo.github.io/2020/09/25/Butterworth_en.html">Butterworthfilter</a> are very similar.</p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Chebyshev_filter">Chebyshevfilter</a></li><li><a href="https://components101.com/articles/different-types-of-chebyshev-filters">ExploringDifferent Types of Chebyshev Filters</a></li><li><a href="https://web.njit.edu/~gilhc/EE494/ee494main.htm">CSpecifyingChebyshev Filters</a></li><li><a href="https://www.electronics-notes.com/articles/radio/rf-filters/what-is-chebychev-filter-basics.php">Whatis a Chebyshev RF Filter - the basics</a></li><li><a href="https://en.wikipedia.org/wiki/Geometric_series">Geometricseries</a></li><li><a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomialcoefficient</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Physics" scheme="https://www.longluo.me/tags/Physics/"/>
    
  </entry>
  
  <entry>
    <title>payne hanek 归约算法</title>
    <link href="https://www.longluo.me/blog/2024/01/22/payne-hanek/"/>
    <id>https://www.longluo.me/blog/2024/01/22/payne-hanek/</id>
    <published>2024-01-22T13:10:50.000Z</published>
    <updated>2024-02-25T12:34:22.666Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/582590074">CodyWaite和Payne-Hanek归约算法的详细解释</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.c</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Argument Reduction" scheme="https://www.longluo.me/tags/Argument-Reduction/"/>
    
    <category term="Computer Arithmetic" scheme="https://www.longluo.me/tags/Computer-Arithmetic/"/>
    
    <category term="参数归约" scheme="https://www.longluo.me/tags/%E5%8F%82%E6%95%B0%E5%BD%92%E7%BA%A6/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
    <category term="Trigonometric" scheme="https://www.longluo.me/tags/Trigonometric/"/>
    
  </entry>
  
  <entry>
    <title>音乐背后的数学</title>
    <link href="https://www.longluo.me/blog/2024/01/12/the-math-of-music/"/>
    <id>https://www.longluo.me/blog/2024/01/12/the-math-of-music/</id>
    <published>2024-01-12T11:18:38.000Z</published>
    <updated>2024-03-11T13:10:24.222Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="声音是什么">声音是什么？</h1><h1 id="什么是和弦">什么是和弦？</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://plus.maths.org/content/magical-mathematics-music">Themagical mathematics of music</a></li><li><a href="https://mp.weixin.qq.com/s/KxePYsQY7sHDnFnaZjP6lA">北大王杰教授：用数学分析动人音乐的奥秘（上）</a></li><li><a href="https://mp.weixin.qq.com/s/BrwDDcIWEXqmCKnq63duvg">北大王杰教授：用数学分析动人音乐的奥秘（下）</a></li><li><a href="https://www.numericana.com/answer/music.htm">MathematicalAspects of Music</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;声音是什么&quot;&gt;声音是什么？&lt;/h1&gt;
&lt;h1 id=&quot;什么是和弦&quot;&gt;什么是和弦？&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Music" scheme="https://www.longluo.me/tags/Music/"/>
    
  </entry>
  
  <entry>
    <title>素描背后的物理</title>
    <link href="https://www.longluo.me/blog/2023/12/30/the-physics-behind-drawings/"/>
    <id>https://www.longluo.me/blog/2023/12/30/the-physics-behind-drawings/</id>
    <published>2023-12-30T14:53:51.000Z</published>
    <updated>2024-03-11T13:15:42.116Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Light">Light</a></li><li><a href="https://en.wikipedia.org/wiki/Diffuse_reflection">Diffusereflection</a></li><li><a href="https://en.wikipedia.org/wiki/Reflection_(physics)">Reflection(physics)</a></li><li><a href="https://en.wikipedia.org/wiki/Bloom_(shader_effect)">Bloom(shader effect)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    <category term="Physics" scheme="https://www.longluo.me/categories/Physics/"/>
    
    
    <category term="Physics" scheme="https://www.longluo.me/tags/Physics/"/>
    
  </entry>
  
  <entry>
    <title>cody waite</title>
    <link href="https://www.longluo.me/blog/2023/12/19/cody-waite/"/>
    <id>https://www.longluo.me/blog/2023/12/19/cody-waite/</id>
    <published>2023-12-19T12:10:19.000Z</published>
    <updated>2024-02-25T12:34:30.747Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/582590074">CodyWaite和Payne-Hanek归约算法的详细解释</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.c</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Argument Reduction" scheme="https://www.longluo.me/tags/Argument-Reduction/"/>
    
    <category term="Computer Arithmetic" scheme="https://www.longluo.me/tags/Computer-Arithmetic/"/>
    
    <category term="参数归约" scheme="https://www.longluo.me/tags/%E5%8F%82%E6%95%B0%E5%BD%92%E7%BA%A6/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
    <category term="Trigonometric" scheme="https://www.longluo.me/tags/Trigonometric/"/>
    
  </entry>
  
  <entry>
    <title>浮点数</title>
    <link href="https://www.longluo.me/blog/2023/12/03/floating-point/"/>
    <id>https://www.longluo.me/blog/2023/12/03/floating-point/</id>
    <published>2023-12-03T14:12:45.000Z</published>
    <updated>2024-05-24T13:17:21.065Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><p>假如你知道浮点数的话，你就知道为什么了！</p><p>按照 IEEE 754 浮点数标准 制定的 浮点数运算法则， float类型的单精度浮点数 的尾数部分有 <span class="math inline">\(\large{23}\)</span> 位二进制数，如下图所示：</p><figure><img src="http://www.longluo.me/assets/blog/images/floating_point/ieee_754_single_floating_point_format.svg" alt="IEEE_754_Single_Floating_Point_Format"><figcaption aria-hidden="true">IEEE_754_Single_Floating_Point_Format</figcaption></figure><p>在十进制下，大致相当于 <span class="math inline">\(\large{\log_{10}{2^{23}} = 23 \cdot \log {2} \approx 23 \times 0.301 \approx6.9}\)</span> ，有效数字大约有 <span class="math inline">\(\large{7}\)</span> 位。</p><p>所以当 <span class="math inline">\(\large {x = 1000001}\)</span>时，我们应该使用 double 类型的双精度浮点数 [^12]，这样才能保证结果有<strong>足够的精度</strong>！</p><p>双精度浮点数的尾数部分有 <span class="math inline">\(\large{52}\)</span> 位，如下图所示：</p><figure><img src="http://www.longluo.me/assets/blog/images/floating_point/ieee_754_double_floating_point_format.svg" alt="IEEE_754_Double_Floating_Point_Format"><figcaption aria-hidden="true">IEEE_754_Double_Floating_Point_Format</figcaption></figure><p>在十进制中大致相当于 <span class="math inline">\(\large{\log_{10}{2^{52}} = 52 \cdot \log {2} \approx 52 \times 0.301 \approx15.6}\)</span> ，也就是说当 <span class="math inline">\(\large{x}\)</span> 有效数字是 <span class="math inline">\(\large {[7,15]}\)</span> 时，我们应该使用 double类型的双精度浮点数可以保证精度！</p><p>但这仍然有个问题，那就是 <span class="math inline">\(\large{x}\)</span> 有效数字 超过 <span class="math inline">\(\large{15}\)</span> 位，应该怎么办？</p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li><li><a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">Floating-pointarithmetic</a></li><li><a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">Single-precisionfloating-point format</a></li><li><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">Double-precisionfloating-point format</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;p&gt;假如你知道浮点数的话，你就知道为什么了！&lt;/p&gt;
&lt;p&gt;按照 IEEE 754 浮点数标准 制定的 浮点数运算法则， float
类型的单精度浮</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>古巴比伦泥板上的神秘数字：根号2背后的4000年数学史</title>
    <link href="https://www.longluo.me/blog/2023/11/10/square-root-of-two/"/>
    <id>https://www.longluo.me/blog/2023/11/10/square-root-of-two/</id>
    <published>2023-11-10T13:26:07.000Z</published>
    <updated>2024-01-26T15:19:06.534Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>（挖坑！）</p><h1 id="a4-纸背后的科学">A4 纸背后的科学</h1><p>A系列纸张尺寸的长短比(宽高比)都是 <span class="math inline">\(1:{\sqrt {2}}\)</span> ，然后舍去到最接近的毫米值。A0</p><h1 id="泥板上的神秘数字">泥板上的神秘数字</h1><h1 id="第一次数学危机">第一次数学危机</h1><h1 id="古巴比伦法求根号-2">古巴比伦法求根号 2</h1><h1 id="牛顿迭代法">牛顿迭代法</h1><h1 id="总结">总结</h1><h1 id="参考文献">参考文献</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（挖坑！）&lt;/p&gt;
&lt;h1 id=&quot;a4-纸背后的科学&quot;&gt;A4 纸背后的科学&lt;/h1&gt;
&lt;p&gt;A系列纸张尺寸的长短比(宽高比)都是 &lt;span class=&quot;math inline&quot;&gt;</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Square Root" scheme="https://www.longluo.me/tags/Square-Root/"/>
    
  </entry>
  
  <entry>
    <title>Remez Algorithm</title>
    <link href="https://www.longluo.me/blog/2023/10/07/remez-algorithm/"/>
    <id>https://www.longluo.me/blog/2023/10/07/remez-algorithm/</id>
    <published>2023-10-06T23:08:37.000Z</published>
    <updated>2024-03-11T13:17:35.339Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Remez_algorithm">Remezalgorithm</a></li><li><a href="https://mathworld.wolfram.com/RemezAlgorithm.html">RemezAlgorithm</a></li><li><a href="https://blog.csdn.net/m0_66201040/article/details/123955780">8.2雷米兹算法</a></li><li><a href="https://valelab4.ucsf.edu/svn/3rdpartypublic/boost/libs/math/doc/sf_and_dist/html/math_toolkit/backgrounders/remez.html">TheRemez Method</a></li><li><a href="https://en.wikipedia.org/wiki/Geometric_series">Geometricseries</a></li><li><a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomialcoefficient</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Calculus" scheme="https://www.longluo.me/tags/Calculus/"/>
    
    <category term="Taylor Series" scheme="https://www.longluo.me/tags/Taylor-Series/"/>
    
  </entry>
  
  <entry>
    <title>切比雪夫多项式</title>
    <link href="https://www.longluo.me/blog/2023/10/03/chebyshev-polynomials/"/>
    <id>https://www.longluo.me/blog/2023/10/03/chebyshev-polynomials/</id>
    <published>2023-10-03T00:52:21.000Z</published>
    <updated>2024-06-28T12:33:12.170Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><p><span class="math display">\[\begin{aligned}T_0(x) &amp;= 1 \\T_1(x) &amp;= x \\T_n(x) &amp;= 2xT_{n-1}(x) - T_{n-2}(x)\end{aligned}\]</span></p><span id="more"></span><h1 id="chebyshev-polynomial-c_nx">2. Chebyshev polynomial <span class="math inline">\((C_N(x))\)</span></h1><h2 id="a.-definition-of-chebyshev-polynomial">a. Definition ofChebyshev polynomial</h2><p>Once again, the definition of Chebyshev Polynomial is as follows:</p><p><span class="math display">\[C_N(x) =\begin{cases}\cos(N\cos^{-1}(x)) &amp;&amp; \text{ for } |x| \leq 1\\\cosh(N\cosh^{-1}(x)) &amp;&amp; \text{ for } |x| \gt1\end{cases}\]</span></p><p>We want to emphasize that we are interested in <span class="math inline">\(C_N(x)\)</span> when <span class="math inline">\(\|x\|\leq 1\)</span>. This is important becausethe properties of <span class="math inline">\(C_N(x)\)</span> determinethe shape of the Chebyshev filter.</p><h2 id="b.-analyzing-chebyshev-polynomial">b. Analyzing Chebyshevpolynomial</h2><p>First, let’s revisit the interpretation of <span class="math inline">\(C_N(x)=\cos(N\cos^{-1}(x))\)</span>. We want toanalyze the shape of <span class="math inline">\(C_N(x)\)</span> as<span class="math inline">\(N\)</span> varies. This is because the maindetermining factors of the Chebyshev filter are the filter order <span class="math inline">\(N\)</span> and the ripple size factor <span class="math inline">\(\epsilon\)</span>.</p><p><span class="math display">\[C_0(x) = 1\]</span></p><p><span class="math display">\[C_1(x) = \cos(1\times \cos^{-1}(x)) =x\]</span></p><p>To find <span class="math inline">\(C_2(x)\)</span>, we need to use alittle bit of algebra.</p><p><span class="math display">\[C_2(x) =\cos(2\cos^{-1}(x))\]</span></p><p>Let’s call <span class="math inline">\(\cos^{-1}(x)=\theta\)</span>.Then <span class="math inline">\(x=\cos(\theta)\)</span>. Therefore,</p><p><span class="math display">\[C_2(x) = \cos(2\theta) = 2\cos^2\theta -1  = 2x^2 - 1\]</span></p><p>We can also find <span class="math inline">\(C_3(x)\)</span> using asimilar method.</p><p><span class="math display">\[C_3(x) =\cos(3\cos^{-1}(x))\]</span></p><p>Similarly, let’s call <span class="math inline">\(\cos^{-1}(x)=\theta\)</span>. Then <span class="math inline">\(x=\cos(\theta)\)</span>. Therefore,</p><p><span class="math display">\[C_3(x) = \cos(3\theta) = \cos(2\theta +\theta)\]</span></p><p>Here,</p><p><span class="math display">\[\cos(2\theta +\theta)=\cos(2\theta)\cos(\theta) -\sin(2\theta)\sin(\theta)\]</span></p><p><span class="math display">\[=(2\cos^2(\theta)-1)\cos(\theta) -2\sin(\theta)\cos(\theta)\sin(\theta)\]</span></p><p><span class="math display">\[=(2\cos^3(\theta) -\cos(\theta))-2(1-\cos^2(\theta))\cos(\theta)\]</span></p><p><span class="math display">\[=2\cos^3(\theta) - \cos(\theta) -2\cos(\theta) + 2\cos^2(\theta)\]</span></p><p><span class="math display">\[=4\cos^3(\theta)-3\cos(\theta)\]</span></p><p>Therefore, the original <span class="math inline">\(C_3(x)\)</span>is</p><p><span class="math display">\[\Rightarrow C_3(x) =4x^3-3x\]</span></p><p>When we observe the shape of <span class="math inline">\(C_N(x)\)</span>, we can see that the degree of<span class="math inline">\(x\)</span> differs by 2.</p><p>Therefore, by using the following general formula,</p><p><span class="math display">\[\cos(x) + \cos(y) =2\cos\left(\frac{x+y}{2}\right)\cos\left(\frac{x-y}{2}\right)\]</span></p><p>we can obtain</p><p><span class="math display">\[\cos(N\theta) + \cos((N-2)\theta) =2\cos(\theta)\cos((N-1)\theta)\]</span></p><p>and, using the equation</p><p><span class="math display">\[\cos^{-1}(x) = \theta, x =\cos(\theta)\]</span></p><p>we can obtain</p><p><span class="math display">\[C_N(x) =\cos(N\cos^{-1}(x))\]</span></p><p>and</p><p><span class="math display">\[C_N(x) = \cos(N\theta)\]</span></p><p>Therefore, we can derive the fact that</p><p><span class="math display">\[C_N(x) = 2xC_{N-1}(x) -C_{N-2}(x)\]</span></p><p>and we can derive the general formula for <span class="math inline">\(C_N(x)\)</span>.</p><p>Hence, For example,</p><p><span class="math display">\[C_3(x) = 2x(2x^2 -1) -x \]</span></p><p><span class="math display">\[= 4x^3 - 3x\]</span></p><p><span class="math display">\[C_4(x) = 2xC_3(x) - C_2(x)\]</span></p><p><span class="math display">\[=2x(4x^3-3x) - (2x^2 - 1)\]</span></p><p><span class="math display">\[=8x^4 - 8x^2 + 1\]</span></p><p>In the same way, we can recursively calculate the value of any <span class="math inline">\(C_N(x)\)</span> regardless of the size of N.</p><p>Let’s take a look at some <span class="math inline">\(C_N(x)\)</span>.</p><p><span class="math display">\[C_0(x) = 1\]</span></p><p><span class="math display">\[C_1(x) = x\]</span></p><p><span class="math display">\[C_2(x) = 2x^2 - 1\]</span></p><p><span class="math display">\[C_3(x) = 4x^3 - 3x\]</span></p><p><span class="math display">\[C_4(x) = 8x^4-8x^2 + 1\]</span></p><p>If we gather <span class="math inline">\(C_N(x)\)</span> like this,we can see that <span class="math inline">\(C_N(0)\)</span> has apeculiar periodicity.</p><p>It is:</p><p><span class="math display">\[C_N(0) = \begin{cases}0 &amp;&amp; N =\text{odd}\\\pm 1 &amp;&amp; N = \text{even}\end{cases}\]</span></p><p>This plays an important role in determining the shape of theChebyshev filter at <span class="math inline">\(\Omega=0\)</span>.</p><p>Also, if we gather the Chebyshev Polynomials <span class="math inline">\(C_N(x)\)</span>, we get:</p><p align="center"><img src="https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-09-27-Chebyshev/pic2.png"><br> Figure 2. Chebyshev Polynomials for various n <br><a href="https://en.wikipedia.org/wiki/Chebyshev_filter"> Source:Wikipedia, Chevyshev filter</a></p><p>For <span class="math inline">\(\|x\|&gt;1\)</span>, we can draw acontinuous line along the respective color. This is because <span class="math inline">\(C_N(x)\)</span> is defined as <span class="math inline">\(C_N(x)=\cosh(\cosh^{-1}(x))\)</span> for <span class="math inline">\(\|x\|&gt;1\)</span>, and as mentioned before, ithas a monotonic shape.</p><p align="center"><img width="400" src="https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-09-27-Chebyshev/pic3.png"><br> Figure 3. The Chebyshev Polynomials extended and plotted forvarious values of n for <span class="math inline">\(\|x\|&gt;1\)</span><br> (Source: EE648 Chebyshev filters / John Stensby / ece.uah.edu)</p><p>Therefore, we can see that the ripple shown in the Chebyshev filteroscillates equally.</p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">ChebyshevPolynomials</a></li><li><a href="https://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html">ChebyshevPolynomial of the First Kind</a></li><li><a href="https://brilliant.org/wiki/chebyshev-polynomials-definition-and-properties/">ChebyshevPolynomials - Definition and Properties</a></li><li><a href="https://blog.csdn.net/m0_66201040/article/details/123954378">8.1切比雪夫近似值求正余弦</a></li><li><a href="https://en.wikipedia.org/wiki/Geometric_series">Geometricseries</a></li><li><a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomialcoefficient</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
T_0(x) &amp;amp;= 1 &#92;&#92;
T_1(x) &amp;amp;= x &#92;&#92;
T_n(x) &amp;amp;= 2xT_{n-1}(x) - T_{n-2}(x)
&#92;end{aligned}
&#92;]&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Calculus" scheme="https://www.longluo.me/tags/Calculus/"/>
    
  </entry>
  
  <entry>
    <title>波是什么？</title>
    <link href="https://www.longluo.me/blog/2023/09/28/wave/"/>
    <id>https://www.longluo.me/blog/2023/09/28/wave/</id>
    <published>2023-09-28T14:10:14.000Z</published>
    <updated>2024-06-28T12:34:29.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="挖坑">挖坑</h1><span id="more"></span><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Wave">Wave</a></li></ol><p>https://github.com/ranocha/SummationByPartsOperators.jl/blob/main/notebooks/Wave_equation.ipynb</p><p>https://github.com/spatialaudio/computational_acoustics/blob/master/FEM_wave_equation.ipynb</p><p>https://tbetcke.github.io/hpc_lecture_notes/wave_equation.html</p><p>https://github.com/tbetcke/hpc_lecture_notes/blob/master/hpc_lecture_notes/wave_equation.ipynb</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;</summary>
    
    
    
    <category term="Physics" scheme="https://www.longluo.me/categories/Physics/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Physics" scheme="https://www.longluo.me/tags/Physics/"/>
    
    <category term="Wave" scheme="https://www.longluo.me/tags/Wave/"/>
    
  </entry>
  
  <entry>
    <title>参数归约算法(Argument Range Reduction)：如何在浮点数环境下计算超大数字的三角函数值？</title>
    <link href="https://www.longluo.me/blog/2023/09/16/argument-range-reduction/"/>
    <id>https://www.longluo.me/blog/2023/09/16/argument-range-reduction/</id>
    <published>2023-09-16T14:05:07.000Z</published>
    <updated>2024-03-03T07:57:11.759Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>之前写过一篇介绍 CORDIC 算法 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 的文章，里面提到 CORDIC算法的 <a href="http://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/#cordic-%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%8D%E8%B6%B3"><strong>不足</strong></a>之处，CORDIC 算法的输入角度范围需要在 <span class="math inline">\([−99.88^{\circ} , 99.88^{\circ}]\)</span>，那么我们不禁要问，如果输入角度 <span class="math inline">\(\large{\theta }\)</span> 很大的话，怎么处理呢？</p><p>这个问题同样存在于 泰勒展开式(Taylor series) <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>中，比如 <span class="math inline">\(\large {\sin (x) }\)</span> 和<span class="math inline">\(\large {\cos (x) }\)</span>的泰勒展开式：</p><p><span class="math display">\[\sin(x) = x - \frac {1}{3!}x^3 + \frac {1}{5!}x^5 - \frac {1}{7!} x^7 +\frac {1}{9!} x^9 + o(x^9) \quad \forall x \subset \mathbb{R}\]</span></p><p><span class="math display">\[\cos(x) = 1 - \frac {1}{2!}x^2 + \frac {1}{4!}x^4 - \frac {1}{6!} x^6 +\frac {1}{8!} x^8 + o(x^8) \quad \forall x \subset \mathbb{R}\]</span></p><p>虽然在整个实数集 <span class="math inline">\(\large {\mathbb{R}}\)</span>都成立，但是在实际应用中因为展开项数限制和浮点数的精度限制， <span class="math inline">\(\large {x}\)</span> 的范围只有在接近 <span class="math inline">\(\large {0}\)</span> 的时候才有比较高的精度。</p><p>但是实际应用中，如果输入 <span class="math inline">\(\large{x}\)</span> 很大的话，比如 <span class="math inline">\(\large {2^{32},10^{10}, 10^{22} \dots }\)</span> 情况下怎么得到足够精确的值呢？</p><p>中学里我们知道三角函数是<strong>周期函数</strong>，对于比较大的值，我们可以使用下面的公式将值<strong>归约</strong>到一个比较小的范围内。</p><p><span class="math display">\[x' = x - 2k \pi \quad k \subset \mathbb{Z}\]</span></p><p>这就是我们今天要讲的 <strong>参数归约(Argument Reduction)</strong>算法。</p><h1 id="从小学计算题开始">从小学计算题开始</h1><p><strong>参数归约</strong>听起来就很唬人，什么是参数啊，什么归约啊，都是些高大上的名词，听起来云里雾里的！</p><p>为了不让大家产生厌倦和畏难心理，我们先从一道小学数学计算题开始：</p><p>不借助计算器，计算 <span class="math inline">\(\large {66600 \times666000}\)</span> 的值！</p><p>对于这道题，大家可能会列出下列算术：</p><p><span class="math display">\[66600 \times 666000 = 666 \times 666 \times 100000 = 44355600000\]</span></p><p>但其实呢，我们也可以使用下面的方法：</p><p><span class="math display">\[\begin{aligned}66600 \times 666000 &amp;= 111^2 \times 4 \times 9 \times 10^5\\&amp;= 444 \times 999 \times 10^5\\&amp;= 444 \times (1000 - 1) \times 10^5\\&amp;= 4443556 \times 10^5    \end{aligned}\]</span></p><p>如果我说上面这 <span class="math inline">\(\large {2}\)</span>种方法都用到了<strong>参数归约</strong>的思想，你可能会感到震惊，什么？这种小学计算题也用到了参数归约算法吗？</p><span id="more"></span><h1 id="什么是参数归约-argument-reduction">什么是参数归约 ArgumentReduction ？</h1><p>上一章计算 <span class="math inline">\(\large {66600 \times666000}\)</span> 时，我们将 <span class="math inline">\(\large {666\times 666}\)</span> 化简为 <span class="math inline">\(\large {444\times (1000 - 1)}\)</span> ，再在结果后面直接加上 <span class="math inline">\(\large {5}\)</span> 个 <span class="math inline">\(\large {0}\)</span>，那么你有没有想过这背后隐含了什么数学思想吗？</p><p>下面我们正式进入今天的课题：<strong>参数归约(ArgumentReduction)</strong> 。</p><p>为了提高数学函数的计算效率，将初始问题转变或者说缩小到函数更容易计算的域内，这就是参数归约。</p><p>已知函数 <span class="math inline">\(\large {f}\)</span> ，求 <span class="math inline">\(\large {y = f(x)}\)</span> 的值，可以通过以下<span class="math inline">\(\large {3}\)</span> 个步骤进行计算：</p><ol type="1"><li>将 <span class="math inline">\(\large {x}\)</span> 转换为缩小的参数<span class="math inline">\(\large {x'}\)</span> ；</li><li>计算 <span class="math inline">\(\large {y' =f(x')}\)</span> ；</li><li>使用函数恒等式从 <span class="math inline">\(\large{f(x')}\)</span> 计算出 <span class="math inline">\(\large{f(x)}\)</span> 。</li></ol><p>现在回到上一节的小学数学计算题，我们实际上用到了 <span class="math inline">\(\large {2}\)</span> 种参数归约：</p><ol type="1"><li>指数/对数 运算公式</li></ol><p><span class="math display">\[exp(x + y) = \exp(x) \exp(y)\]</span></p><p><span class="math display">\[\log (xy) = \log (x) + \log (y)\]</span></p><ol start="2" type="1"><li>相加公式。不过上面小学数学题用的非常简单的分配律和结合律，实际上我们用的更复杂的公式，比如各种三角恒等式：</li></ol><p><span class="math display">\[\sin (x + y) = \sin(x) \cos (y) + \cos (x) \sin (y)\]</span></p><p><span class="math display">\[\tan (x + y) = \frac {\tan (x) + \tan (y)}{1 - \tan (x) \tan (y)}\]</span></p><p>实际上为了让幂级数更快地收敛，通常我们取 <span class="math inline">\(\large {x = y}\)</span> 以获得双倍公式，比如 <span class="math inline">\(\large {e^ {2x} = (e^x)^2}\)</span> ，比如快速幂算法(Exponentiation by squaring) <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ,其具体实现可参考这篇文章： <a href="http://www.longluo.me/blog/2022/01/02/Leetcode-powx-n/">Fast PowerAlgorithm: Binary Exponentiation</a> 。</p><p>而计算器中也常用到三倍角公式 <span class="math inline">\(\large {\sin(3x) = 3 \sin (x) - 4 \sin ^3(x)}\)</span>去计算三角函数值，具体可参考这个视频： <a href="https://www.bilibili.com/video/BV1AW4y1A7HN">计算器是如何计算出三角函数和对数的？</a>。</p><p>可能有同学会问，那二倍角公式 <span class="math inline">\(\large {\sin(2x) = 2 \sin(x) \cos (x)}\)</span>就不用了吗？这个谜底待后续章节介绍。</p><h1 id="如何对参数进行归约">如何对参数进行归约？</h1><p>这一章我们来讲如何进行参数归约，通常我们区分 <span class="math inline">\(\large {2}\)</span> 种参数归约：</p><ol type="1"><li>加法参数归约： <span class="math inline">\(\large {x' = x -kC}\)</span> ，其中 <span class="math inline">\(\large {C}\)</span>是实常数， <span class="math inline">\(\large {k}\)</span> 是整数。</li></ol><p>这种归约可以应用在 <span class="math inline">\(\large {f(x)}\)</span>是周期函数的情况，比如三角函数，此时 <span class="math inline">\(\large{C = 2 \pi}\)</span> ；也可以应用于其他函数，比如小学数学我们知道计算<span class="math inline">\(\large { \frac {a}{b}}\)</span>就是看有多少个 <span class="math inline">\(\large {b}\)</span>相加小于等于 <span class="math inline">\(\large {a}\)</span>，具体可参考这篇文章：<a href="http://www.longluo.me/blog/2022/05/30/leetcode-divide-two-integers-en/">29.Divide Two Integers</a> 。</p><ol start="2" type="1"><li>乘法参数归约：<span class="math inline">\(\large {x' =\frac{x}{kC}}\)</span>，其中 <span class="math inline">\(\large{C}\)</span> 是实常数， <span class="math inline">\(\large {k}\)</span>是整数。</li></ol><p>应用于计算指数函数 <span class="math inline">\(\large {\exp(x)}\)</span> 时，其中 <span class="math inline">\(\large {C =2}\)</span> 。</p><p>值得注意的是，对于给定的函数，两种参数归约方式都可能使用。例如，对于<span class="math inline">\(\large {\sin (x) }\)</span>，我们既可以使用三倍角公式 <span class="math inline">\(\large {\sin (3x)= 3 \sin (x) - 4 \sin^3 (x)}\)</span> 化简，也可以使用加法归约 <span class="math inline">\(\large {\sin (x + 2 k \pi) = \sin (x)}\)</span>。</p><h1 id="数值分析-numerical-analysis">数值分析 Numerical Analysis</h1><p>通过上面的分析，现在让我们去计算任意输入 <span class="math inline">\(\large {x}\)</span> 的 <span class="math inline">\(\large { \sin (x)}\)</span> 、 <span class="math inline">\(\large {\cos (x)}\)</span> 的值，可以分为下面<span class="math inline">\(\large {2}\)</span> 种情况：</p><ol type="1"><li><span class="math inline">\(\large {0 &lt; x \leq \frac{\pi}{2}}\)</span> ，使用泰勒展开或者 CORDIC 算法；</li><li><span class="math inline">\(\large {x &gt; \frac {\pi}{2}}\)</span>，先将 <span class="math inline">\(\large {x}\)</span> 归约到 <span class="math inline">\(\large {x' = x + k \frac {\pi}{2}}\)</span>，再回到第一步计算。</li></ol><p>听起来似乎很简单，但事实上远远没有这么容易！</p><p>我们的电脑是基于 <strong>二进制(Binary)</strong> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>的，本质只是高电平和低电平在电路上切换运行而已。因为 CPU 种的逻辑运算单元(Arithmetic logic unit) <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>只能做加法和移位操作，因此而诞生了 计算机算术(Computer Arithmetic) <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> 这门学科！</p><p>数学中有一门学科 数值分析(Numerical Analysis) <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>就是专门研究各种计算的！</p><p>虽然三角函数的周棋是 <span class="math inline">\(\large {2\pi}\)</span> ，但实际上我们只用归约到 <span class="math inline">\(\large {[-\frac {\pi}{4},\frac {\pi}{4}]}\)</span>即可，这里大家可以想想为什么？</p><p>之前我以为数值运算对于 <span class="math inline">\(\large {[-\frac{\pi}{2},\frac {\pi}{2}]}\)</span> 的参数，会使用 CORDIC算法，但实际上我看了一些数值计算库，发现对于 <span class="math inline">\(\large {[-\frac {\pi}{2},\frac {\pi}{2}]}\)</span>还是使用泰勒(Taylor Series) <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>逼近，当然里面用了很多技巧，大家可以看看库函数的具体实现即可解惑（这里先挖个坑，等我彻底看懂了再来这里填坑！）。</p><p>那对于 <span class="math inline">\(\large {x &gt; \frac{\pi}{2}}\)</span> ，如何计算呢？</p><h1 id="cody-waite-归约算法">Cody-Waite 归约算法</h1><p>我们可以使用下列公式将 <span class="math inline">\(\large{x}\)</span> 归约到 <span class="math inline">\(\large {[-\frac{\pi}{4},\frac {\pi}{4}]}\)</span> ：</p><p><span class="math display">\[x' = x - \lfloor  \frac {x}{\frac {\pi}{2}} \rfloor \times \frac{\pi}{2}\]</span></p><p>我们可以很容易按照上述思想写出对应的代码，这就是 Cody &amp; Waite提出的 Cody-Waite 归约算法<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> 。</p><p>但是如果你认为这样就高枕无忧了的话，就太早了！</p><p>假如输入 <span class="math inline">\(\large {x = 1000001}\)</span>的话，上面的方法就会失效！想一想为什么？</p><h1 id="payne-hanek-归约算法">Payne-Hanek 归约算法</h1><p>上一章提出了一个问题，有效数字 超过 <span class="math inline">\(\large {15}\)</span>位的超大数字该如何计算呢？针对这个问题， Payne 与 Hanek <a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>提出把浮点运算转换为大整数运算，来解决超大数字的浮点数归约问题。</p><p>要弄懂 Payne-Hanek归约算法，需要对数学有比较深的理解，下面一步一步来分析！</p><p>对于输入 <span class="math inline">\(\large {x}\)</span> ：</p><p><span class="math display">\[x = k \cdot (\frac {\pi}{2}) + r \quad k \subset \mathbb{Z}, r \subset[-\frac {\pi}{4},\frac {\pi}{4}]\]</span></p><p>两边同乘 <span class="math inline">\(\large {\frac{2}{\pi }}\)</span>，可得：</p><p><span class="math display">\[x \cdot ( \frac{2}{\pi }) = k + r \cdot (\frac{2}{\pi })\]</span></p><p>因为 <span class="math inline">\(\left| r \right | \leq \frac{\pi}{4}\)</span> ， <span class="math inline">\(r \cdot (\frac {2}{\pi}) \leq 0.5\)</span> ，也就是说：</p><p><span class="math display">\[y = x \cdot (\frac {2}{\pi })\]</span></p><p>即：</p><p><span class="math display">\[k = \left \lfloor y \right \rfloor\]</span></p><p>那么所求浮点数的尾数部分：</p><p><span class="math display">\[f = y − k\]</span></p><p>最终可得到归约之后的结果 <span class="math inline">\(\large{r}\)</span> ：</p><p><span class="math display">\[r = f \cdot (\frac {\pi }{2})\]</span></p><p>回到我们的目标，我们需要知道 <span class="math inline">\(\large{k}\)</span> 的值 和 <span class="math inline">\(\large {r}\)</span>的值！</p><p>那我们能直接用上述公式计算吗？</p><p>我们知道 <span class="math inline">\(\large {\pi}\)</span>是超越数，是无法用二进制表示的，在计算机里只能去近似。我们最终要求得的三角函数的误差取决于下面几个方面：</p><ol type="1"><li>使用多少位数的 <span class="math inline">\(\large {\pi}\)</span>近似值；</li><li>参数归约时产生的误差；</li><li>计算参数归约之后的三角函数时的误差。</li></ol><p>对于输入参数 <span class="math inline">\(\large {x}\)</span>不是很大的情况，误差主要由参数归约时产生的误差决定，而当输入参数 <span class="math inline">\(\large {x}\)</span>很大的情况，参数归约产生的误差就不再是主要因素了！</p><h2 id="计算-large-k">计算 <span class="math inline">\(\large{k}\)</span></h2><p>由之前的推导，我们知道：</p><p><span class="math display">\[k = \left \lfloor y \right \rfloor = x \cdot (\frac {2}{\pi })\]</span></p><p>但是由于浮点数的精度限制，我们知道对于 <span class="math inline">\(\large {x}\)</span>很大情况，我们不能直接去计算！</p><p>由三角函数关系可知，我们实际上只需要计算 <span class="math inline">\(\large {k \% 4}\)</span>的值即可，也就是说只需要知道 <span class="math inline">\(\large{k}\)</span> 的最后 <span class="math inline">\(\large {2}\)</span> 个二进制位值即可，这样就可以节省大量运算了！</p><p>让我们回到 浮点数标准 <a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> ，以 <span class="math inline">\(\large {32}\)</span>位单精度浮点数为例，其值可以表示为：</p><p><span class="math display">\[x = (-1)^{b_{31}} \times 2^{(b_{30}b_{29}\dots b_{23})_{2} - 127} \times(1.b_{22}b_{21}\dots b_{0})_{2}\]</span></p><p>即为：</p><p><span class="math display">\[\text {value} = (-1)^{\text {sign}} \times 2^{(E - 127)} \times \left (1+ \sum _{i=1}^{23}b_{23-i} 2^{-i} \right)\]</span></p><p>(原始论文和数值分析具体实现代码太难看懂了，这篇文章写了快 1个月了！:-( )</p><h1 id="小结">小结</h1><p>这是目前我对<strong>参数归约(Argument Reduction)</strong>算法的理解，后续有新的发现、感悟都会更新此文章。</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="http://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/">CORDIC算法：一种高效计算三角函数值的方法</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="http://www.longluo.me/blog/2023/04/26/Taylor-Series/">泰勒展开式(Taylorseries)</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">Exponentiationby squaring</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Binary_number">Binary number</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">Arithmeticlogic unit</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://zh.wikipedia.org/wiki/Category:%E8%A8%88%E7%AE%97%E6%A9%9F%E7%AE%97%E8%A1%93">计算机算术</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://en.wikipedia.org/wiki/Numerical_analysis">NumericalAnalysis</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p><a href="http://www.longluo.me/blog/2023/04/26/Taylor-Series/">泰勒展开式(Taylorseries)</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn9"><p>W. Cody and W. Waite, Software Manual for the ElementaryFunctions, Prentice-Hall, Englewood Cliffs, N.J., 1980.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn10"><p><a href="https://dl.acm.org/doi/pdf/10.1145/1057600.1057602">M. Payne andR. Hanek, “Radian Reduction for Trigonometric Functions”, Signum,p19-24, Jan 1983.</a><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn11"><p><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE754</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前写过一篇介绍 CORDIC 算法 &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 的文章，里面提到 CORDIC
算法的 &lt;a href=&quot;http://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/#cordic-%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%8D%E8%B6%B3&quot;&gt;&lt;strong&gt;不足&lt;/strong&gt;&lt;/a&gt;
之处，CORDIC 算法的输入角度范围需要在 &lt;span class=&quot;math inline&quot;&gt;&#92;([−99.88^{&#92;circ} , 99.88^{&#92;circ}]&#92;)&lt;/span&gt;
，那么我们不禁要问，如果输入角度 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large
{&#92;theta }&#92;)&lt;/span&gt; 很大的话，怎么处理呢？&lt;/p&gt;
&lt;p&gt;这个问题同样存在于 泰勒展开式(Taylor series) &lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;
中，比如 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {&#92;sin (x) }&#92;)&lt;/span&gt; 和
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {&#92;cos (x) }&#92;)&lt;/span&gt;
的泰勒展开式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sin(x) = x - &#92;frac {1}{3!}x^3 + &#92;frac {1}{5!}x^5 - &#92;frac {1}{7!} x^7 +
&#92;frac {1}{9!} x^9 + o(x^9) &#92;quad &#92;forall x &#92;subset &#92;mathbb{R}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;cos(x) = 1 - &#92;frac {1}{2!}x^2 + &#92;frac {1}{4!}x^4 - &#92;frac {1}{6!} x^6 +
&#92;frac {1}{8!} x^8 + o(x^8) &#92;quad &#92;forall x &#92;subset &#92;mathbb{R}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然在整个实数集 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {
&#92;mathbb{R}}&#92;)&lt;/span&gt;
都成立，但是在实际应用中因为展开项数限制和浮点数的精度限制， &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {x}&#92;)&lt;/span&gt; 的范围只有在接近 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {0}&#92;)&lt;/span&gt; 的时候才有比较高的精度。&lt;/p&gt;
&lt;p&gt;但是实际应用中，如果输入 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large
{x}&#92;)&lt;/span&gt; 很大的话，比如 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {2^{32},
10^{10}, 10^{22} &#92;dots }&#92;)&lt;/span&gt; 情况下怎么得到足够精确的值呢？&lt;/p&gt;
&lt;p&gt;中学里我们知道三角函数是&lt;strong&gt;周期函数&lt;/strong&gt;，对于比较大的值，我们可以使用下面的公式将值&lt;strong&gt;归约&lt;/strong&gt;到一个比较小的范围内。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
x&#39; = x - 2k &#92;pi &#92;quad k &#92;subset &#92;mathbb{Z}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这就是我们今天要讲的 &lt;strong&gt;参数归约(Argument Reduction)&lt;/strong&gt;
算法。&lt;/p&gt;
&lt;h1 id=&quot;从小学计算题开始&quot;&gt;从小学计算题开始&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;参数归约&lt;/strong&gt;
听起来就很唬人，什么是参数啊，什么归约啊，都是些高大上的名词，听起来云里雾里的！&lt;/p&gt;
&lt;p&gt;为了不让大家产生厌倦和畏难心理，我们先从一道小学数学计算题开始：&lt;/p&gt;
&lt;p&gt;不借助计算器，计算 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {66600 &#92;times
666000}&#92;)&lt;/span&gt; 的值！&lt;/p&gt;
&lt;p&gt;对于这道题，大家可能会列出下列算术：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
66600 &#92;times 666000 = 666 &#92;times 666 &#92;times 100000 = 44355600000
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但其实呢，我们也可以使用下面的方法：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
66600 &#92;times 666000 &amp;amp;= 111^2 &#92;times 4 &#92;times 9 &#92;times 10^5
&#92;&#92;&amp;amp;= 444 &#92;times 999 &#92;times 10^5
&#92;&#92;&amp;amp;= 444 &#92;times (1000 - 1) &#92;times 10^5
&#92;&#92;&amp;amp;= 4443556 &#92;times 10^5    
&#92;end{aligned}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果我说上面这 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {2}&#92;)&lt;/span&gt;
种方法都用到了&lt;strong&gt;参数归约&lt;/strong&gt;的思想，你可能会感到震惊，什么？这种小学计算题也用到了参数归约算法吗？&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Argument Reduction" scheme="https://www.longluo.me/tags/Argument-Reduction/"/>
    
    <category term="Computer Arithmetic" scheme="https://www.longluo.me/tags/Computer-Arithmetic/"/>
    
    <category term="参数归约" scheme="https://www.longluo.me/tags/%E5%8F%82%E6%95%B0%E5%BD%92%E7%BA%A6/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
    <category term="Trigonometric" scheme="https://www.longluo.me/tags/Trigonometric/"/>
    
  </entry>
  
  <entry>
    <title>频率之美：探索振动的神奇语言</title>
    <link href="https://www.longluo.me/blog/2023/08/21/oscillation/"/>
    <id>https://www.longluo.me/blog/2023/08/21/oscillation/</id>
    <published>2023-08-21T13:17:43.000Z</published>
    <updated>2024-06-29T09:22:00.910Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><p><span class="math display">\[m \frac {d^2x}{dt^2} = -kx\]</span></p><p><span class="math display">\[m \frac{d^2x}{dt^2} = -k \cdot x = k \cdot A \sin \left( \omega t -\Delta \varphi \right)\]</span></p><p><span class="math display">\[m \frac{d^2x}{dt^2} + m r \frac{dx}{dt} + kx = F(t)\]</span></p><span id="more"></span><p>这张图是从stein书中截取，也是经典物理中简谐运动的简单模型，其中 <span class="math inline">\(m\)</span> 是物体质量， <span class="math inline">\(k\)</span>是弹力系数。根据运动牛顼运动定律和胡党定律可以得到简单的力学等式:</p><p><span class="math display">\[-k y(t)=m y^{\prime \prime}(t),\]</span></p><p>而这是一个典型的微分方程，目的是求解出 <span class="math inline">\(y(t)\)</span>，也就是物体位置和时间的关系。先做一下形式上的整理，令 <span class="math inline">\(c=\sqrt{k / m}\)</span>, 则如上等式可以写成:</p><p><span class="math display">\[y^{\prime \prime}(t)+c^2 y(t)=0 .\]</span></p><p>现在的问题是，如何求解这个微分方程?通常来说，会直接给出一个通解形式，即:</p><p><span class="math display">\[y(t)=a \cos c t+b \sin c t,\]</span></p><p>但是在这里可以給出一个有说服力的恩路。蚟如同求普通方程一样，得到的结果是一个数字。也就是说，在求解实数普通方程时，是从实数域中那无穷多个实数中找到了满足普通等式的那一个或几个数字。只不过在求解微分方程时，目标域不再是实数，而是无穷多个函数组成的函数域。那么问题来了，我们怎么知道这个函数域中有嘶些函数呢?</p><p>对于这个问题，数学家决定加上一些约束条件来帮助他们找到答宛。他们雩䤚，这个函数域中的函数都是性质良好的。在这里我特意把“希旺”和“性质良好”标注成再点。首先解䉽一下为什么“希望”如此如此雨要，这是为了强调数学工作是需要确立方向的，换句话说可能有许许多多奇奇怪怪的函数都能满足这个微分方程，但是数学家们只想关注那些性质良好的（在你求解一些普通方程时，是否胺海中也浮现过，要是答案是数数就好了这样的常望？）。第二要解释</p><p><span class="math display">\[f(x)=a_0+a_1 x+a_2 x^2+\cdots\]</span></p><p>这样的函数之所以性质良好，一是可以无限次求导且求导方便，而来求其数值解也非常简单，回到正题，也就是说，数学家们现在要解决的问题是，是否存在一个函数能满足那个微分方程，同时它还具有多项式的形式?此时问题已经变成清析了很多。</p><p>那么该如何解决这个问题呢? 思路也是简单的，那就是反向思维.如果一个多项式能满足这个微分方程等式，那么会出现什么情况呢?</p><p>不妨假设 <span class="math inline">\(f(x)=a_0+a_1 x+a_2x^2+\cdots\)</span> 就是微分方程的解，那么带入其中会发现:</p><p><span class="math display">\[\begin{gathered}f(x)=a_0+a_1 x+a_2 x^2+a_3 x^3+a_4 x^4+a_5 x^5+\cdots \\f^{\prime}(x)=a_1+2 a_2 x+3 a_3 x^2+4 a_4 x^3+5 a_5 x^4+\cdots \\f^{\prime \prime}(x)=2 a_2+3 \cdot 2 a_3 x+4 \cdot 3 a_4 x^2+5 \cdot 4a_5 x^3+\cdots\end{gathered}\]</span></p><p>要满足等式，则有 <span class="math inline">\(f^{\prime \prime}(x)+c^2f(x)=0\)</span>, 则有</p><p><span class="math display">\[\left(2 a_2+c^2 a_0\right)+\left(3 \cdot 2 a_3+c^2 a_1\right) x+\left(4\cdot 3 a_4+c^2 a_2\right) x^2+\left(5 \cdot 4 a_5+c^2 a_3\right)x^3+\cdots=0\]</span></p><p>要使得对所有 <span class="math inline">\(x\)</span> 都使等式为 0 ,则所有项必须都为 0 , 于量就有如下结论:</p><p><span class="math display">\[\left\{\begin{array}{l}2 a_2+c^2 a_0=0 \\3 \cdot 2 a_3+c^2 a_1=0 \\4 \cdot 3 a_4+c^2 a_2=0 \\5 \cdot 4 a_5+c^2 a_3=0 \\6 \cdot 5 a_6+c^2 a_4=0 \\7 \cdot 6 a_7+c^2 a_5=0 \\\vdots\end{array}\right.\]</span></p><p>我们对如上一些列的简单等式进行求解可知: <span class="math display">\[\left\{\begin{array}{l}a_2=\frac{-c^2 a_0}{2} \\a_3=\frac{-c^2 a_1}{3 \cdot 2} \\a_4=\frac{-c^2 a_2}{4.3}=\frac{\left(-c^2\right)^2 a_0}{4!} \\a_5=\frac{-c^2 a_3}{5 \cdot 4}=\frac{\left(-c^2\right)^2 a_1}{5!} \\a_6=\frac{-c^2 a_4}{6.5}=\frac{\left(-c^2\right)^3 a_0}{6!} \\\vdots\end{array}\right.\]</span></p><p>那么 <span class="math inline">\(a_0\)</span> 和 <span class="math inline">\(a_1\)</span> 是什么呢?我们井不知道，这就是所谓的“初始条件”，从如上求解的列表可以看到这两个初始冬件始终贯穿有的系数项，那么至此我们已经求出了微分方程的一个解:<span class="math display">\[y=a_0+a_1 x+\frac{-c^2 a_0}{2} x^2+\frac{-c^2 a_1}{3!}x^3+\frac{\left(-c^2\right)^2 a_0}{4!} x^4+\frac{\left(-c^2\right)^2a_1}{5!} x^5+\frac{\left(-c^2\right)^3 a_0}{6!}x^6+\frac{\left(-c^2\right)^3 a_1}{7!}+\cdots\]</span></p><p>将指数的奇数项和偶数项分开我们会得到: <span class="math display">\[\begin{aligned}y= &amp; a_0+\frac{-c^2 a_0}{2} x^2+\frac{\left(-c^2\right)^2 a_0}{4!}x^4+\frac{\left(-c^2\right)^3 a_0}{6!} x^6+\cdots \\&amp; + \\&amp; a_1 x+\frac{-c^2 a_1}{3!} x^3+\frac{\left(-c^2\right)^2 a_1}{5!}x^5+\frac{\left(-c^2\right)^3 a_1}{7!}+\cdots\end{aligned}\]</span> <span class="math display">\[\begin{aligned}&amp; \sin x-x-\frac{x^3}{3!}+\frac{x^5}{5!}-\cdots+(-1)^n \frac{x^{2n+1}}{(2 n+1)!}+o\left(x^{2 n+2}\right) \\&amp; \cosx=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdots+(-1)^n\frac{x^{2 n}}{(2 n)!}+o\left(x^{2 n+1}\right)_1\end{aligned}\]</span></p><p>虽然他们长得还不是完全一样，不过我们可以做一些整理： <span class="math display">\[\begin{aligned}y= &amp; a_0\left(1-\frac{(c x)^2}{2}+\frac{(c x)^4}{4!}-\frac{(cx)^6}{6!}+\cdots\right) \\&amp; + \\&amp; \frac{a_1}{c}\left(c x-\frac{(c x)^3}{3!}+\frac{(cx)^5}{5!}-\frac{(c x)^7}{7!}+\cdots\right) \\= &amp; a_0 \sin (c x)+\frac{a_1}{c} \cos (c x)\end{aligned}\]</span></p><p>至此我们觫释了为何一开始的那个简谐运动的微分方程的通解长这个形式，可以坧到这个推理的过程比较䑤珖，这也是为何直接记住结论的原因，但是一旦弄清祾其原理，会对倩里叶分析更深刻的理解和认知打下基础。</p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Oscillation">Oscillation</a></li><li><a href="https://en.wikipedia.org/wiki/Simple_harmonic_motion">Simpleharmonic motion</a></li><li><a href="https://en.wikipedia.org/wiki/Electronic_oscillator">Electronicoscillator</a></li><li><a href="https://en.wikipedia.org/wiki/Pendulum">Pendulum</a></li><li><a href="https://en.wikipedia.org/wiki/Galileo_Galilei">GalileoGalilei</a></li><li><a href="https://en.wikipedia.org/wiki/Damping">Damping</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
m &#92;frac {d^2x}{dt^2} = -kx
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
m &#92;frac{d^2x}{dt^2} = -k &#92;cdot x = k &#92;cdot A &#92;sin &#92;left( &#92;omega t -
&#92;Delta &#92;varphi &#92;right)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
m &#92;frac{d^2x}{dt^2} + m r &#92;frac{dx}{dt} + kx = F(t)
&#92;]&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Physics" scheme="https://www.longluo.me/categories/Physics/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Physics" scheme="https://www.longluo.me/tags/Physics/"/>
    
  </entry>
  
  <entry>
    <title>素描背后的数学</title>
    <link href="https://www.longluo.me/blog/2023/08/02/perspective/"/>
    <id>https://www.longluo.me/blog/2023/08/02/perspective/</id>
    <published>2023-08-02T11:15:11.000Z</published>
    <updated>2024-03-11T13:16:44.086Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Sketch_(drawing)">Sketch(drawing)</a></li><li><a href="https://en.wikipedia.org/wiki/Projective_geometry">Projectivegeometry</a></li><li><a href="https://zh.wikipedia.org/zh-cn/%E9%98%BF%E5%B0%94%E5%B8%83%E9%9B%B7%E5%B8%8C%E7%89%B9%C2%B7%E4%B8%A2%E5%8B%92">阿尔布雷希特·丢勒</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%98%82%C2%B7%E5%B7%B4%E8%92%82%E6%96%AF%E5%A1%94%C2%B7%E9%98%BF%E5%B0%94%E4%BC%AF%E8%92%82">莱昂·巴蒂斯塔·阿尔伯蒂</a></li><li><a href="https://book.douban.com/subject/25662171/">论绘画</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Art" scheme="https://www.longluo.me/tags/Art/"/>
    
    <category term="Sketch" scheme="https://www.longluo.me/tags/Sketch/"/>
    
  </entry>
  
  <entry>
    <title>熵是什么? Entropy</title>
    <link href="https://www.longluo.me/blog/2023/07/06/entropy/"/>
    <id>https://www.longluo.me/blog/2023/07/06/entropy/</id>
    <published>2023-07-06T13:35:26.000Z</published>
    <updated>2024-03-14T14:29:16.567Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑！</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Entropy">Entropy</a></li><li><a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">Entropy(information theory)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑！&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.or</summary>
      
    
    
    
    <category term="Physics" scheme="https://www.longluo.me/categories/Physics/"/>
    
    
    <category term="Entropy" scheme="https://www.longluo.me/tags/Entropy/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降法(Gradient Descent)：优化世界中的魔法箭头</title>
    <link href="https://www.longluo.me/blog/2023/06/20/gradient-descent/"/>
    <id>https://www.longluo.me/blog/2023/06/20/gradient-descent/</id>
    <published>2023-06-20T00:36:02.000Z</published>
    <updated>2023-11-14T14:24:40.449Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="待继续完善">待继续完善</h1><p>引言：</p><p>在机器学习和优化算法的领域中，梯度下降法被广泛应用于解决各种问题，从训练神经网络到参数优化。这种强大的优化算法通过不断迭代更新参数，以最小化目标函数或最大化收益函数。本文将介绍梯度下降法的数学原理，探讨其在实际应用中的广泛应用以及其优点和不足之处。</p><h1 id="数学原理">数学原理：</h1><p>梯度下降法的核心思想是通过计算目标函数的梯度，并沿着梯度的反方向迭代地更新参数，以逐步逼近最优解。具体而言，梯度下降法包括以下步骤：</p><p><span class="math display">\[h_{\theta} (x) = \theta_0 + \theta_1 x + \theta_2 x^2 + \dots + \theta_nx^n\]</span></p><p><span class="math display">\[J(\theta) = \frac{1}{2m} \sum_{i = 1}^{m} (h_{\theta} (x_i) - y_i)^2\]</span></p><p><span class="math display">\[\theta_j = \theta_j - \frac{\alpha}{m} \sum_{i = 1}^{m} (h_{\theta}(x_i) - y_i) \cdot x_j\]</span></p><p>随机初始化参数向量。 计算目标函数在当前参数向量处的梯度。沿着梯度的反方向更新参数向量。</p><p>重复以上步骤，直到满足停止条件（如达到最大迭代次数或参数变化不显著）。</p><span id="more"></span><h1 id="应用实例">应用实例：</h1><p>梯度下降法在各个领域都有广泛的应用，以下是一些常见的应用实例：</p><ul><li>机器学习：梯度下降法是训练神经网络和其他机器学习模型的基本算法，用于调整模型参数以最小化损失函数。</li><li>线性回归：通过最小化损失函数，梯度下降法可以找到最佳的回归系数，从而拟合线性模型。</li><li>特征选择：梯度下降法可以用于选择最相关的特征，以提高模型的预测性能。</li><li>无监督学习：在聚类和降维等无监督学习任务中，梯度下降法可以最大化或最小化相应的目标函数，实现数据的有效表示和结构发现。</li></ul><h1 id="优点与不足">优点与不足</h1><p>梯度下降法具有以下优点：</p><ul><li>强大的全局优化能力：梯度下降法可以在复杂的参数空间中搜索全局最优解。</li><li>广泛适用性：它可以用于不同类型的问题，从线性模型到深度神经网络。</li><li>可扩展性：梯度下降法可以应用于大规模数据集和高维参数空间。</li></ul><p>然而，梯度下降法也存在一些不足之处：</p><ul><li>学习率选择：合适的学习率对梯度下降法的性能至关重要，过小或过大的学习率都可能导致收敛问题。</li><li>局部最优解：在非凸优化问题中，梯度下降法可能会陷入局部最优解，而无法达到全局最优解。</li><li>高计算成本：对于大规模数据集和复杂模型，计算梯度和更新参数的成本较高。</li></ul><h1 id="总结">总结</h1><p>梯度下降法是优化算法中的魔法箭头，它通过迭代更新参数的方式，在机器学习和优化领域取得了巨大成功。虽然存在一些挑战和局限性，但梯度下降法仍然是解决各种实际问题的重要工具，为我们优化世界的探索提供了强大的支持。</p><h1 id="参考文献">参考文献</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;待继续完善&quot;&gt;待继续完善&lt;/h1&gt;
&lt;p&gt;引言：&lt;/p&gt;
&lt;p&gt;在机器学习和优化算法的领域中，梯度下降法被广泛应用于解决各种问题，从训练神经网络到参数优化。这种强大的优化算法通过不断迭代更新参数，以最小化目标函数或最大化收益函数。本文将介绍梯度下降法的数学原理，探讨其在实际应用中的广泛应用以及其优点和不足之处。&lt;/p&gt;
&lt;h1 id=&quot;数学原理&quot;&gt;数学原理：&lt;/h1&gt;
&lt;p&gt;梯度下降法的核心思想是通过计算目标函数的梯度，并沿着梯度的反方向迭代地更新参数，以逐步逼近最优解。具体而言，梯度下降法包括以下步骤：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
h_{&#92;theta} (x) = &#92;theta_0 + &#92;theta_1 x + &#92;theta_2 x^2 + &#92;dots + &#92;theta_n
x^n
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
J(&#92;theta) = &#92;frac{1}{2m} &#92;sum_{i = 1}^{m} (h_{&#92;theta} (x_i) - y_i)^2
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;theta_j = &#92;theta_j - &#92;frac{&#92;alpha}{m} &#92;sum_{i = 1}^{m} (h_{&#92;theta}
(x_i) - y_i) &#92;cdot x_j
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;随机初始化参数向量。 计算目标函数在当前参数向量处的梯度。
沿着梯度的反方向更新参数向量。&lt;/p&gt;
&lt;p&gt;重复以上步骤，直到满足停止条件（如达到最大迭代次数或参数变化不显著）。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="AI" scheme="https://www.longluo.me/tags/AI/"/>
    
    <category term="Gradient Descent" scheme="https://www.longluo.me/tags/Gradient-Descent/"/>
    
  </entry>
  
  <entry>
    <title>发生在计算机内存里的进化：解密遗传算法(Genetic Algorithm)</title>
    <link href="https://www.longluo.me/blog/2023/06/12/genetic-algorithm/"/>
    <id>https://www.longluo.me/blog/2023/06/12/genetic-algorithm/</id>
    <published>2023-06-12T00:32:31.000Z</published>
    <updated>2023-11-14T14:24:40.448Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="这篇文章部分内容还在优化demo-还在继续开发大概还需要-7---8-小时写作时间">这篇文章部分内容还在优化，Demo还在继续开发，大概还需要 7 - 8 小时写作时间。</h1><p>无限猴子定理（英语：Infinite monkey theorem）</p><p>让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。</p><p>在这里，几乎必然是一个有特定含义的数学术语，“猴子”也不是一只真正意义上的猴子，它被用来比喻成一个可以产生无限随机字母序列的抽象设备。这个理论说明把一个很大但有限的数看成无限的推论是错误的。猴子精确地通过键盘敲打出一部完整的作品比如说莎士比亚的哈姆雷特，在宇宙的生命周期中发生的概率也是极其低的，但并不是零。</p><p>遗传算法(Genetic Algorithm) <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>是一种元启发式搜索和优化技术，借鉴了生物进化中的自然选择和遗传机制。它已经在各个领域展示出了强大的应用潜力。本文将介绍遗传算法的发展历史、原理、示例，以及其广泛应用和不足之处。</p><h1 id="发展历史">发展历史</h1><p>遗传算法的发展可以追溯到上世纪60年代的约翰·荷兰德（JohnHolland）和他的同事们的工作。他们首先提出了基因型与表现型之间的映射关系，并通过模拟生物进化过程来解决复杂的优化问题。</p><h1 id="原理">原理</h1><p>遗传算法的核心原理是模拟自然进化的过程。它通过定义适应度函数来评估候选解的质量，并利用遗传操作（选择、交叉和变异）对候选解进行迭代改进。具体而言，算法从一个初始种群开始，通过选择适应度较高的个体作为父代，进行交叉和变异操作产生新的后代个体，然后通过评估适应度来选择出下一代个体。这个过程不断迭代，直到找到满足特定条件的优秀解。</p><p>It’s never too late</p><h1 id="举个例子">举个例子</h1><p>目前参考网络资源写了一个简单的Demo，地址：http://longluo.me/projects/genetic</p><p>这个例子还有待完善！</p><p><a href="http://longluo.me/projects/genetic"><img src="https://user-images.githubusercontent.com/3395062/247012809-febec500-50dd-4d52-a6f6-d5b86aba4132.png" alt="Genetic Algorithm"></a></p><span id="more"></span><h1 id="应用领域">应用领域</h1><p>遗传算法在各个领域都有广泛的应用。它被用于优化问题、机器学习、数据挖掘、调度问题等。例如，在工程设计中，可以使用遗传算法来优化设计参数，以获得更好的性能。在人工智能领域，遗传算法被用于训练神经网络的参数。</p><h1 id="todos">ToDos</h1><ul><li>利用遗传算法优化 <a href="http://www.longluo.me/blog/2023/05/05/pid/">PID</a> ，自动调谐 PID参数，目前开发中…</li><li>利用遗传算法应用于 <a href="http://www.longluo.me/blog/2023/03/03/Neutral-Network/">机器学习</a>，目前还在开发中…</li></ul><h1 id="缺点">缺点</h1><p>遗传算法在应用中存在一些缺点，但可以采取一些方法来规避这些问题。以下是一些常见的遗传算法缺点及其应对措施的例子：</p><p>可能陷入局部最优解：由于遗传算法的随机性质，可能导致算法收敛到局部最优解而无法达到全局最优解。为了规避这个问题，可以采用以下方法：</p><p>多次运行算法：运行遗传算法的多个独立实例，以增加搜索空间的探索性。引入多样性维护机制：通过保留一部分较差个体、增加变异操作的概率或引入新的个体，以增加种群的多样性，避免过早陷入局部最优解。计算复杂度高：遗传算法需要进行大量的计算和评估操作，导致计算复杂度较高。为了降低计算成本，可以尝试以下方法：</p><p>优化评估函数：通过对评估函数进行优化，减少计算成本。使用近似算法：在某些情况下，可以使用近似算法或启发式方法来加速计算过程，以减少计算复杂度。参数选择困难：遗传算法中的参数选择对算法的性能和效果至关重要。不正确的参数选择可能导致算法效果不佳。为了解决这个问题，可以采取以下措施：</p><p>参数调优：通过实验和测试，调整算法的参数，以找到最佳的参数组合。自适应参数调整：引入自适应机制，根据问题的特性和算法的表现，动态调整参数值。举例来说，假设有一个优化问题，需要找到一个函数的最小值。遗传算法被用来解决这个问题，但在初步运行中发现算法很容易陷入局部最优解。为了规避这个问题，可以采取多次运行算法的方法，每次使用不同的初始种群和随机数种子，以增加搜索空间的覆盖度，从而更有可能找到全局最优解。</p><p>另外，遗传算法在每一代选择操作时都会考虑适应度函数的评估，这可能导致计算复杂度的增加。为了降低计算成本，可以对适应度函数进行优化，使用更高效的算法或数据结构进行计算。同时，可以利用并行计算或分布式计算的方法，提高算法的计算效率。</p><p>总之，通过合理的方法和技巧，可以规避遗传算法的一些缺点，并提高算法的效率和性能。根据具体的问题和应用场景，选择适当的策略和方法来克服遗传算法的局限性。</p><h1 id="总结">总结</h1><p>综上所述，遗传算法作为一种强大的优化技术，在解决复杂问题和优化搜索中具有广泛的应用。通过模拟生物进化的机制，它能够发现优秀的解决方案。然而，它也面临局部最优解和计算复杂度高的挑战。随着计算能力和算法改进的不断提升，遗传算法在未来将继续发挥重要作用，并为各个领域的问题提供创新解决方案。</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/George_Gamow">George Gamow</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;这篇文章部分内容还在优化demo-还在继续开发大概还需要-7---8-小时写作时间&quot;&gt;这篇文章部分内容还在优化，Demo
还在继续开发，大概还需要 7 - 8 小时写作时间。&lt;/h1&gt;
&lt;p&gt;无限猴子定理（英语：Infinite monkey theorem）&lt;/p&gt;
&lt;p&gt;让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。&lt;/p&gt;
&lt;p&gt;在这里，几乎必然是一个有特定含义的数学术语，“猴子”也不是一只真正意义上的猴子，它被用来比喻成一个可以产生无限随机字母序列的抽象设备。这个理论说明把一个很大但有限的数看成无限的推论是错误的。猴子精确地通过键盘敲打出一部完整的作品比如说莎士比亚的哈姆雷特，在宇宙的生命周期中发生的概率也是极其低的，但并不是零。&lt;/p&gt;
&lt;p&gt;遗传算法(Genetic Algorithm) &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;
是一种元启发式搜索和优化技术，借鉴了生物进化中的自然选择和遗传机制。它已经在各个领域展示出了强大的应用潜力。本文将介绍遗传算法的发展历史、原理、示例，以及其广泛应用和不足之处。&lt;/p&gt;
&lt;h1 id=&quot;发展历史&quot;&gt;发展历史&lt;/h1&gt;
&lt;p&gt;遗传算法的发展可以追溯到上世纪60年代的约翰·荷兰德（John
Holland）和他的同事们的工作。他们首先提出了基因型与表现型之间的映射关系，并通过模拟生物进化过程来解决复杂的优化问题。&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;&gt;原理&lt;/h1&gt;
&lt;p&gt;遗传算法的核心原理是模拟自然进化的过程。它通过定义适应度函数来评估候选解的质量，并利用遗传操作（选择、交叉和变异）对候选解进行迭代改进。具体而言，算法从一个初始种群开始，通过选择适应度较高的个体作为父代，进行交叉和变异操作产生新的后代个体，然后通过评估适应度来选择出下一代个体。这个过程不断迭代，直到找到满足特定条件的优秀解。&lt;/p&gt;
&lt;p&gt;It’s never too late&lt;/p&gt;
&lt;h1 id=&quot;举个例子&quot;&gt;举个例子&lt;/h1&gt;
&lt;p&gt;目前参考网络资源写了一个简单的Demo，地址：http://longluo.me/projects/genetic&lt;/p&gt;
&lt;p&gt;这个例子还有待完善！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://longluo.me/projects/genetic&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3395062/247012809-febec500-50dd-4d52-a6f6-d5b86aba4132.png&quot; alt=&quot;Genetic Algorithm&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Genetic Algorithm" scheme="https://www.longluo.me/tags/Genetic-Algorithm/"/>
    
    <category term="AI" scheme="https://www.longluo.me/tags/AI/"/>
    
  </entry>
  
</feed>
