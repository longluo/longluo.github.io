<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long Luo&#39;s Life Notes</title>
  
  <subtitle>每一天都是奇迹</subtitle>
  <link href="https://www.longluo.me/atom.xml" rel="self"/>
  
  <link href="https://www.longluo.me/"/>
  <updated>2024-05-27T13:56:18.923Z</updated>
  <id>https://www.longluo.me/</id>
  
  <author>
    <name>Long Luo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024 阿里巴巴全球数学竞赛预选赛 试题解答</title>
    <link href="https://www.longluo.me/blog/2024/04/16/2024-alibaba-global-mathematics-competition-qualifying-round/"/>
    <id>https://www.longluo.me/blog/2024/04/16/2024-alibaba-global-mathematics-competition-qualifying-round/</id>
    <published>2024-04-16T03:13:48.000Z</published>
    <updated>2024-05-27T13:56:18.923Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p><a href="https://damo.alibaba.com/?language=zh">阿里巴巴达摩院</a> 从2018年开始每年都会举办一届全球数学竞赛，之前一方面自己数学水平比较弱，另外一方面也没有报名，但一直很仰慕那些数学大神的风采。今年是第一次报名参加<a href="https://damo.alibaba.com/alibaba-global-mathematics-competition?language=zh">2024阿里巴巴全球数学竞赛</a>，上周末参加了预选赛，但遗憾的是，全部 <span class="math inline">\(7\)</span> 道题中只有第 <span class="math inline">\(1, 2, 6\)</span> 题会做，这里分享下我的解答：</p><h1 id="problem-1">Problem 1</h1><p>几位同学假期组成一个小组去某市旅游. 该市有 <span class="math inline">\(6\)</span> 座塔，它们的位置分别为 <span class="math inline">\(A, B, C, D, E, F\)</span>。同学们自由行动一段时间后，每位同学都发现，自己在所在的位置只能看到位于<span class="math inline">\(A, B, C, D\)</span> 处的四座塔，而看不到位于<span class="math inline">\(E\)</span> 和 <span class="math inline">\(F\)</span> 的塔。已知：</p><ol type="1"><li>同学们的位置和塔的位置均视为同一平面上的点，且这些点彼此不重合；</li><li>塔中任意 <span class="math inline">\(3\)</span> 点不共线；</li><li>看不到塔的唯一可能就是视线被其它的塔所阻挡，例如，如果某位同学所在的位置<span class="math inline">\(P\)</span> 和 <span class="math inline">\(A, B\)</span> 共线，且 <span class="math inline">\(A\)</span> 在线段<span class="math inline">\(PB\)</span> 上，那么该同学就看不到位于 <span class="math inline">\(B\)</span> 处的塔。</li></ol><p><strong>（5 分）</strong> 请问 这个旅游小组最多可能有多少名同学？</p><p><span class="math inline">\(A. 3\)</span><br><span class="math inline">\(B. 4\)</span> <span class="math inline">\(C.6\)</span> <span class="math inline">\(D. 12\)</span></p><h2 id="solution">Solution</h2><p>这道题选 <span class="math inline">\(C\)</span> ，最多只能有 <span class="math inline">\(C_{4}^{2} = 6\)</span> 名同学。</p><blockquote><p>[!TIP] 这道题的解题思路是，从假设只有 <span class="math inline">\(1\)</span> 座塔开始，一直到 <span class="math inline">\(6\)</span> 座塔，找到思路。</p></blockquote><ol type="1"><li><p>假设有 <span class="math inline">\(1\)</span> 座塔 <span class="math inline">\(A\)</span> ，那么很显然有无数多同学可以看到塔<span class="math inline">\(A\)</span> ，也可以有无数多同学看不到塔<span class="math inline">\(A\)</span>​ ；</p></li><li><p>假设有 <span class="math inline">\(2\)</span> 座塔 <span class="math inline">\(A, B\)</span> ，那么只有以 <span class="math inline">\(A\)</span> 为起点的射线 <span class="math inline">\(AB\)</span> 且位于 <span class="math inline">\(B\)</span> 之后的同学无法看到塔 <span class="math inline">\(A\)</span> ；</p></li><li><p>假设有 <span class="math inline">\(3\)</span> 座塔 <span class="math inline">\(A, B, C\)</span>，同理可知存在无数位同学至少可以看见 <span class="math inline">\(2\)</span> 座塔；</p></li><li><p>假设有 <span class="math inline">\(4\)</span> 座塔 <span class="math inline">\(A, B, C, D\)</span>，同理可知存在无数位同学至少可以看见 <span class="math inline">\(2\)</span> 座塔；</p></li><li><p>假设有 <span class="math inline">\(6\)</span> 座塔 <span class="math inline">\(A, B, C, D, E, F\)</span> ，如果每位同学都无法看见<span class="math inline">\(E, F\)</span> 塔，如下图1 所示：</p></li></ol><figure><img src="https://www.longluo.me/assets/blog/images/math/2024-alibaba-math-contest-problem1-solution.png" alt="图1. Solution of Problem 1"><figcaption aria-hidden="true">图1. Solution of Problem 1</figcaption></figure><p>所以至多有 <span class="math inline">\(6\)</span> 位同学位于 <span class="math inline">\(M, N, O, P, R, Q\)</span> 处，无法看到塔 <span class="math inline">\(E, F\)</span> 。</p><span id="more"></span><h1 id="problem-2">Problem 2</h1><p>小明玩战机游戏。初始积分为 <span class="math inline">\(2\)</span>。在游戏进行中，积分会随着时间线性地连续减少 (速率为每单位时间段扣除<span class="math inline">\(1\)</span> )。游戏开始后，每隔一个随机时间段(时长为互相独立的参数为 <span class="math inline">\(1\)</span>的指数分布)，就会有一架敌机出现在屏幕上。当敌机出现时，小明立即进行操作，可以瞬间击落对方，或者瞬间被对方击落。如被敌机击落，则游戏结束。如小明击落敌机，则会获得<span class="math inline">\(1.5\)</span>个积分，并且可以选择在击落该次敌机后立即退出游戏，或者继续游戏。如选择继续游戏，则须等待到下一架敌机出现，中途不能主动退出。游戏的难度不断递增：出现的第<span class="math inline">\(n\)</span> 架敌机，小明击落对方的概率为<span class="math inline">\((0.85)^n\)</span> ，被击落的概率为 <span class="math inline">\(1 - (0.85)^n\)</span>，且与之前的事件独立。在任何时刻，如果积分降到 <span class="math inline">\(0\)</span> ，则游戏自动结束。</p><h2 id="第-1-问">第 1 问</h2><p><strong>小问 1 (5分)</strong>如果游戏中，小明被击落后，其之前的积分保持。那么为了游戏结束时的累积积分的数学期望最大化，小明应该在其击落第几架敌机后主动结束游戏？</p><p><span class="math inline">\(A. 1\)</span> <span class="math inline">\(B. 2\)</span> <span class="math inline">\(C.3\)</span> <span class="math inline">\(D. 4\)</span></p><h3 id="solution-1">Solution</h3><blockquote><p>[!TIP] 这道题考察的就是泊松过程<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，数学好的同学推出其表达式，然后计算可得。需要注意的是泊松分布<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Python 代码可以直接调用 API <a href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.exponential.html"><code>numpy.random.exponential</code></a>。虽然是 <a href="https://en.wikipedia.org/wiki/Exponential_distribution">指数分布</a>，但在 Java 中 需要使用 <code>-Math.log(1 - random.nextDouble())</code>而不是 <code>Math.exp(double a)</code> 。模拟代码如下所示：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarPlaneGame</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getExpectScore</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; planes; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">waitTime</span> <span class="operator">=</span> -Math.log(<span class="number">1</span> - random.nextDouble());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt;= score) {</span><br><span class="line">                score = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            score -= waitTime;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">possonPr</span> <span class="operator">=</span> random.nextDouble();</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">shootDownPr</span> <span class="operator">=</span> Math.pow(<span class="number">0.85</span>, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (possonPr &lt; shootDownPr) {</span><br><span class="line">                score += <span class="number">1.5</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">simulate</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">simulateTimes</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">scoreSum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; simulateTimes; i++) {</span><br><span class="line">            scoreSum += getExpectScore(planes);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> scoreSum / simulateTimes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> simulate(i);</span><br><span class="line">            System.out.println(<span class="string">"Shoot down "</span> + i + <span class="string">" planes, Expect Score: "</span> + result);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shoot down 1 planes, Expect Score: 2.2344824425425442</span><br><span class="line">Shoot down 2 planes, Expect Score: 2.290207012168609</span><br><span class="line">Shoot down 3 planes, Expect Score: 2.2653361024420042</span><br><span class="line">Shoot down 4 planes, Expect Score: 2.187342196221392</span><br></pre></td></tr></tbody></table></figure><p>可以看出击落第 <span class="math inline">\(2\)</span>架敌机后主动结束游戏，期望积分最大，所以答案选 <span class="math inline">\(B\)</span> 。</p><h2 id="第-2-问">第 2 问</h2><p><strong>小问 2 (5分)</strong>如果游戏中，小明被击落后，其之前积累的的积分会清零。那么为了游戏结束时的期望积分最大化，小明也会选择一个最优的时间主动结束游戏。请问在游戏结束时（小明主动结束游戏、或积分减到<span class="math inline">\(0\)</span>），下列哪一个选项最接近游戏结束时小明的期望积分？</p><p><span class="math inline">\(A. 2\)</span><br><span class="math inline">\(B. 4\)</span> <span class="math inline">\(C.6\)</span> <span class="math inline">\(D. 8\)</span></p><h3 id="solution-2">Solution</h3><blockquote><p>[!TIP] 通过第一问，我们知道期望积分是随着次数逐渐递减的。</p></blockquote><p>继续写代码模拟其过程，如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarPlaneGame</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getExpectScore2</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; planes; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">waitTime</span> <span class="operator">=</span> -Math.log(<span class="number">1</span> - random.nextDouble());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt;= score / <span class="number">2</span>) {</span><br><span class="line">                score /= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            score -= waitTime;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">possonPr</span> <span class="operator">=</span> random.nextDouble();</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">shootDownPr</span> <span class="operator">=</span> Math.pow(<span class="number">0.85</span>, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (possonPr &lt; shootDownPr) {</span><br><span class="line">                score += <span class="number">1.5</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                score = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">simulate</span><span class="params">(<span class="type">int</span> planes)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">simulateTimes</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">scoreSum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; simulateTimes; i++) {</span><br><span class="line">            scoreSum += getExpectScore2(planes);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> scoreSum / simulateTimes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) {</span><br><span class="line">            <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> simulate(i);</span><br><span class="line">            System.out.println(<span class="string">"Shoot down "</span> + i + <span class="string">" planes, Expect Score: "</span> + result);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shoot down 1 planes, Expect Score: 2.0230245088842116</span><br><span class="line">Shoot down 2 planes, Expect Score: 1.7658505471404586</span><br><span class="line">Shoot down 3 planes, Expect Score: 1.42047193787333</span><br><span class="line">Shoot down 4 planes, Expect Score: 1.0837167796697962</span><br><span class="line">Shoot down 5 planes, Expect Score: 0.8877915996251725</span><br><span class="line">Shoot down 6 planes, Expect Score: 0.7556905685107955</span><br><span class="line">Shoot down 7 planes, Expect Score: 0.7055539105268976</span><br><span class="line">Shoot down 8 planes, Expect Score: 0.6896372679317954</span><br></pre></td></tr></tbody></table></figure><p>可以看出最大期望积分是 <span class="math inline">\(2.023\)</span>左右，所以答案选 <span class="math inline">\(A\)</span> 。</p><h1 id="problem-3">Problem 3</h1><p>对于实数 <span class="math inline">\(T &gt; 0\)</span> ，称欧式平面<span class="math inline">\(\mathbb{R}^2\)</span> 的子集 <span class="math inline">\(\Gamma\)</span> 为 <span class="math inline">\(T\)</span> -稠密的，如果对任意 <span class="math inline">\(v \in \mathbb{R}^{2}\)</span> ，存在 <span class="math inline">\(w \in \Gamma\)</span> 满足 <span class="math inline">\(\|v-w\| \leqslant T\)</span> . 设 <span class="math inline">\(2\)</span> 阶整方阵 <span class="math inline">\(A\in \mathrm{M}_{2}(\mathbb{Z})\)</span> 满足 <span class="math inline">\(\operatorname{det}(A) \neq 0\)</span> .</p><ol type="1"><li><strong>证明题(10分)</strong> 假设 <span class="math inline">\(\operatorname{tr}(A)=0\)</span> . 证明存在 <span class="math inline">\(C &gt; 0\)</span> ，使得对任意正整数 <span class="math inline">\(n\)</span>​ ，集合</li></ol><p><span class="math display">\[A^{n} \mathbb{Z}^{2}:=\left\{A^{n} v: v \in \mathbb{Z}^{2}\right\}\]</span></p><p>是 <span class="math inline">\(C|\operatorname{det}(A)|^{n /2}\)</span> -稠密的.</p><ol start="2" type="1"><li><strong>证明题 (10分)</strong> 假设 <span class="math inline">\(A\)</span> 的特征多项式在有理数域上不可约.证明与(1)相同的结论.</li></ol><p>注: 这里 <span class="math inline">\(\mathbb{R}^{2}\)</span> 和 <span class="math inline">\(\mathbb{Z}^{2}\)</span> 中的向量约定为列向量,<span class="math inline">\(\mathbb{R}^{2}\)</span> 中的内积为标准内积,即 <span class="math inline">\(\langle v, w\rangle=v^{t} w\)</span> .(提示: 在对(2)的证明中, 可使用如下 <span class="math inline">\(\text{Minkowski}\)</span> 凸体定理的特殊情形：<span class="math inline">\(\mathbb{R}^{2}\)</span>中以原点为中心且面积为 <span class="math inline">\(4\)</span>的任意闭平行四边形中总包含 <span class="math inline">\(\mathbb{Z}^{2}\)</span>​ 中的非零向量.)</p><h2 id="solution-3">Solution</h2><blockquote><p>[!TIP] 先挖坑，等我看懂了大神的解答再来填坑！</p></blockquote><h1 id="problem-4">Problem 4</h1><p>设 <span class="math inline">\(d \geq 0\)</span> 是整数， <span class="math inline">\(V\)</span> 是 <span class="math inline">\(2d+1\)</span> 维复线性空间，有一组基</p><p><span class="math display">\[\left\{v_1, v_2, \cdots, v_{2 d+1}\right\} \text {. }\]</span></p><p>对任一整数 <span class="math inline">\(j\left(0 \leq j \leq\frac{d}{2}\right)\)</span> ，记 <span class="math inline">\(U_j\)</span> 是</p><p><span class="math display">\[v_{2 j+1}, v_{2 j+3}, \cdots, v_{2 d-2 j+1}\]</span></p><p>生成的子空间. 定义线性变换 <span class="math inline">\(f: V\rightarrow V\)</span> 为</p><p><span class="math display">\[f\left(v_i\right)=\frac{(i-1)(2 d+2-i)}{2} v_{i-1}+\frac{1}{2} v_{i+1},1 \leq i \leq 2 d+1 .\]</span></p><p>这里我们约定 <span class="math inline">\(v_0=v_{2d+2}=0\)</span>.</p><ol type="1"><li><p><strong>证明题 (10分)</strong> 证明: <span class="math inline">\(f\)</span> 的全部特征值为 <span class="math inline">\(-d,-d+1, \cdots, d\)</span>.</p></li><li><p><strong>问答题 (5分)</strong> 记 <span class="math inline">\(W\)</span> 是从属于特征值 <span class="math inline">\(-d+2 k(0 \leq k \leq d)\)</span> 的 <span class="math inline">\(f\)</span> 的特征子空间的和. 求 <span class="math inline">\(W \cap U_0\)</span> 的维数.</p></li><li><p><strong>问答题 (5分)</strong> 对任一整数 <span class="math inline">\(j\left(1 \leq j \leq \frac{d}{2}\right)\)</span>，求 <span class="math inline">\(W \cap U_j\)</span>​​​​ 的维数.</p></li></ol><h2 id="solution-4">Solution</h2><blockquote><p>[!TIP] 先挖坑，等我看懂了大神的解答再来填坑！</p></blockquote><h1 id="problem-5">Problem 5</h1><p><strong>证明题 (20分)</strong> 对于 <span class="math inline">\(\mathbb{R}^3\)</span> 中的任何中心对称的凸多面体<span class="math inline">\(V\)</span> ，证明可以找到一个椭球面 <span class="math inline">\(E\)</span> ，把凸多面体包在内部，且 <span class="math inline">\(E\)</span> 的表面积不超过 <span class="math inline">\(V\)</span> 的表面积的 <span class="math inline">\(3\)</span> 倍。</p><h2 id="solution-5">Solution</h2><blockquote><p>[!TIP] 先挖坑，等我看懂了大神的解答再来填坑！</p></blockquote><h1 id="problem-6">Problem 6</h1><h2 id="第-1-问-1">第 1 问</h2><p>假设有一枚硬币，投掷得到正面的概率为 <span class="math inline">\(\frac{1}{3}\)</span> 。独立地投掷该硬币 <span class="math inline">\(n\)</span> 次，记 <span class="math inline">\(X_n\)</span> 为其中得到正面的次数。试求 <span class="math inline">\(X_n\)</span> 为偶数的概率在 <span class="math inline">\(n\)</span> 趋于正无穷时的极限。</p><h3 id="solution-6">Solution</h3><blockquote><p>[!TIP] 当 <span class="math inline">\(n \to \infty\)</span>，直觉告诉我们，偶数次正面出现的概率和奇数次正面出现的概率是一样的，而<strong>奇数</strong>和<strong>偶数</strong>是均匀分布的，答案应该是<span class="math inline">\(\frac{1}{2}\)</span>。但这道题不是选择题也不是填空题，我们需要严谨证明这个结论！</p></blockquote><p>由题意可知，设随机变量 <span class="math inline">\(X_n\)</span>表示在 <span class="math inline">\(n\)</span>次独立投掷中正面出现的次数，每次出现正面的概率为 <span class="math inline">\(p = \frac{1}{3}\)</span> ，则 <span class="math inline">\(X_n\)</span> 服从参数为 <span class="math inline">\(\operatorname{B}(n, p)\)</span> 的二项分布<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ，那么 <span class="math inline">\(n\)</span> 次独立投掷中正面出现 <span class="math inline">\(k\)</span> 次的概率是：</p><p><span class="math display">\[\begin{equation}\operatorname{Pr}(X_n = k) = \binom{n}{k} p^k (1−p)^{n−k}    \tag{6.1.1}\label{6.1.1}\end{equation}\]</span></p><p>要求 <span class="math inline">\(X_n\)</span> 为偶数的概率，即：</p><p><span class="math display">\[\begin{aligned}\operatorname{Pr}(X_n \text { is even}) &amp; = \operatorname{Pr}(X_n =0) + \operatorname{Pr}(X_n = 2) + \cdots + \operatorname{Pr}(X_n = 2k, k= \left \lfloor \frac{n}{2} \right \rfloor ) \\&amp; = \sum_{k=0}^{\left \lfloor \frac{n}{2} \right \rfloor}\binom{n}{2k} p^{2k} (1 − p)^{n − 2k}\end{aligned}\]</span></p><p>带入 <span class="math inline">\(p = \frac{1}{3}\)</span>，可得：</p><p><span class="math display">\[\begin{equation}\operatorname{Pr}(X_n \text { is even}) = \sum_{k=0}^{\left \lfloor\frac{n}{2} \right \rfloor} \binom{n}{2k} (\frac{1}{3})^{2k}(\frac{2}{3})^{n−2k}    \tag{6.1.2} \label{6.1.2}\end{equation}\]</span></p><p>由 二项式定理<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> 可知：</p><p><span class="math display">\[\begin{equation}(x + y)^n = \sum_{k=0}^{n} \binom{n}{k} x^k y^{n−k}    \tag{6.1.3}\label{6.1.3}\end{equation}\]</span></p><p>那么易得共轭表达式：</p><p><span class="math display">\[\begin{align}(x + y)^n + (x − y)^n &amp; = 2 \sum_{k=0}^{\left \lfloor \frac{n}{2}\right \rfloor} x^{2k}y^{n - 2k}   \tag{6.1.4} \label{6.1.4} \\(x + y)^n - (x − y)^n &amp; = 2 \sum_{k=0}^{\left \lfloor \frac{n}{2}\right \rfloor} x^{2k + 1}y^{n - 2k - 1}   \tag{6.1.5} \label{6.1.5}\end{align}\]</span></p><p>可得：</p><p><span class="math display">\[\begin{aligned}\operatorname{Pr}(X_n \text { is even}) &amp; = \sum_{k=0}^{\left\lfloor \frac{n}{2} \right \rfloor} \binom{n}{2k} (\frac{1}{3})^{2k}(\frac{2}{3})^{n−2k} \\&amp; = \frac{1}{2} \left [ \left (\frac{1}{3} + \frac{2}{3} \right )^n+ \left (\frac{1}{3} - \frac{2}{3} \right )^n \right ]  \\&amp; = \frac{1}{2} \left [1 + \frac{1}{3^n} \right ]\end{aligned}\]</span></p><p>故答案为：</p><p><span class="math display">\[\lim_{n \to \infty} \operatorname{Pr}(X_n \text { is even}) = \lim_{n\to \infty} \frac{1}{2} \left (1 + \frac{1}{3^n} \right ) = \frac{1}{2}\]</span></p><blockquote><p>[!TIP] 这道题也可以用 <a href="https://en.wikipedia.org/wiki/Markov_chain">马尔可夫链</a>来做，构建递推关系式，感兴趣的同学可以试试！</p></blockquote><h2 id="第-2-问-1">第 2 问</h2><p>某人在过年期间参加了集五福活动，在这项活动中此人每扫描一次福字，可以随机地得到五张福卡中的一张。假设其每次扫福得到五福之一的概率固定，分别为<span class="math inline">\(p_i \in (0, 1) , i = 1, 2, \cdots ,5\)</span> 且 <span class="math inline">\(\sum_{i = 1}^{5} p_i =1\)</span> ，并假设其每次扫描得到的结果相互独立。在进行了 <span class="math inline">\(n\)</span> 次扫福之后，记 <span class="math inline">\(X^{i}_n, i =1, 2, \cdots, 5\)</span>为其得到每种福卡的张数。那么求极限 <span class="math inline">\(\lim _{n\to \infty} \operatorname{P} \left ( X^{(i)}_{2n}, i = 1, 2, \cdots, 5\text { 全部为偶数} \right )\)</span> 。</p><h3 id="solution-7">Solution</h3><blockquote><p>[!TIP] 直觉告诉我们，当 <span class="math inline">\(n \to\infty\)</span>时，五种福卡每种都是偶数的事件是<strong>相互独立</strong>的。通过第一问，我们已经知道答案是<span class="math inline">\(\frac{1}{2}\)</span>，那么五种福卡每种福卡的张数都是偶数的概率就是 <span class="math inline">\(\frac{1}{2^5} = \frac{1}{32}\)</span> ，而 <span class="math inline">\(2n\)</span> 次扫福卡的概率就是 <span class="math inline">\(\frac{1}{16}\)</span>。这个猜测对不对呢？下面我们就来证明下。</p></blockquote><p>由多项式定理<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> ：</p><p><span class="math display">\[\left (x_{1} + x_{2} + \cdots + x_{m} \right)^{n} = \sum_{\begin{array}{c} \alpha _{1} + \alpha _{2} + \cdots + \alpha _{m} = n\\ \alpha _{1},\alpha _{2},\cdots ,\alpha _{m} \geq 0 \end {array}}{\frac {n!}{\alpha _{1}! \dots \alpha _{m}!}}x_{1}^{\alpha _{1}} \dotsx_{m}^{\alpha _{m}}    \tag{6.2.1} \label{6.2.1}\]</span></p><p>设 <span class="math inline">\(k_i, i = 1,2, \cdots ,5\)</span>表示是 <span class="math inline">\(n\)</span> 次独立扫描福卡中得到第<span class="math inline">\(i\)</span> 种福卡的张数，则其概率为：</p><p><span class="math display">\[\begin{align}\operatorname{Pr} \left (X_{n}^{(i)} = k_i, i=1,2, \cdots ,5 \right)&amp;= \binom {n}{k_1, k_2, \cdots, k_5} p_1^{k_1} p_2^{k_2} \cdotsp_5^{k_5}   \nonumber  \\&amp; = \frac {n!}{k_1!k_2! \cdots k_5!} p_1^{k_1} p_2^{k_2} \cdotsp_5^{k_5}     \tag{6.2.2} \label{6.2.2}\end{align}\]</span></p><p>观察上式可知，所求概率为多项式 <span class="math inline">\(\left (p_1+ p_2 + p_3 + p_4 + p_5 \right )^{n}\)</span> 的 <span class="math inline">\(p_1^{k_1} p_2^{k_2} \cdots p_5^{k_5}\)</span>​项，<span class="math inline">\(\binom {n}{k_1, k_2, \cdots ,k_5}\)</span> 为其系数。</p><p>和问题 <span class="math inline">\(1\)</span>的共轭表达式类似，我们给不同福卡添加符号位，考虑如下求和表达式：</p><p><span class="math display">\[S_{2n} = \frac{1}{2^{5}} \sum_{\beta_{i} = \pm 1} \left (\beta_{1} p_{1}+ \beta_{2} p_{2} +\cdots + \beta_{5} p_{5}\right)^{2n}       \tag{6.2.3} \label{6.2.3}\]</span></p><p>对上式进行多项式展开，可得：</p><p><span class="math display">\[\begin{aligned}S_{2n} &amp; = \frac{1}{2^{5}} \sum_{\substack {\beta_{i} = \pm 1 \\x_{1} + x_{2} + \cdots + x_{5} = 2n}} \frac{(2n)!}{x_{1}!x_{2}! \cdotsx_{5}!} \beta{1}^{x_{1}} \beta_{2}^{x_{2}} \cdots \beta_{5}^{x_{5}}p_{1}^{x_{1}} p_{2}^{x_{2}} \cdots p_{5}^{x_{5}} \\&amp; = \frac{1}{2^{5}} \sum_{x_{1} + x_{2} + \cdots + x_{5} = 2n}\frac{(2n)!}{x_{1}!x_{2}! \cdots x_{5}!} p_{1}^{x_{1}} p_{2}^{x_{2}}\cdots p_{5}^{x_{5}} \sum_{\beta_{i} = \pm 1} \beta_{1}^{x_{1}}\beta_{2}^{x_{2}} \cdots \beta_{5}^{x_{5}}\end{aligned}\]</span></p><p>考虑 <span class="math inline">\(\sum _{\substack {\beta_{i} = \pm 1\\x_{1} + x_{2} + \cdots + x_{5} = 2n}} \beta_{1}^{x_{1}}\beta_{2}^{x_{2}} \cdots \beta_{5}^{x_{5}}\)</span> ，如果存在 $k $ 使得<span class="math inline">\(x_{k}\)</span>为<strong>奇数</strong>的话，那么：</p><p><span class="math display">\[\sum_{\beta_{i} = \pm 1} \beta_{1}^{x_{1}} \beta_{2}^{x_{2}} \cdots\beta_{5}^{x_{5}} = \sum_{\substack {\beta_{i}= \pm 1 \\ i \neq k}}\left[\left (1^{x_{k}} + (-1)^{x_{k}} \right) \prod_ {i \neq k}\beta_{i}^{x_{i}} \right ]=0\]</span></p><p>由于<strong>奇数项</strong>最终都会消去，只有偶数项 <span class="math inline">\(x_{i}\)</span> 才会留下来，故有：</p><p><span class="math display">\[\sum_{\beta_{i} = \pm 1} \beta_{1}^{x_{1}} \beta_{2}^{x_{2}} \cdots\beta_{k}^{x_{k}} = 2^{k}\]</span></p><p>那么求和表达式为：</p><p><span class="math display">\[\begin{aligned}S_{2n} &amp; = \sum_{\substack{x_{1} + x_{2} + \cdots + x_{k} = 2 n \\x_{i} \text { is even }}} \frac{(2 n)!}{x_{1}!x_{2}! \cdots x_{k}!}p_{1}^{x_{1}} p_{2}^{x_{2}} \cdots p_{k}^{x_{k}} \\&amp; = \operatorname{Pr} \left \{ X_{2 n}^{(i)} \text { is all even }\right\}\end{aligned}\]</span></p><p>因此，所求问题转化为在 <span class="math inline">\(X_{2n}^{(i)}\)</span> 均为偶数情况下，当 $n $ 时，其极限为：</p><p><span class="math display">\[\lim _{n \to \infty} \operatorname{Pr}\left \{X_{2 n}^{(i)} \text { isall even } \right\} = \lim _{n \to \infty} S_{2 n}\]</span></p><p>因为 <span class="math inline">\(\left | \beta_{1} p_{1} + \beta_{2}p_{2} + \cdots + \beta_{5} p_{5} \right | \leq 1\)</span> , 所以当 <span class="math inline">\(n \to \infty\)</span> 时，只有 <span class="math inline">\(\beta_i\)</span> 全为 <span class="math inline">\(1\)</span> 或者 <span class="math inline">\(-1\)</span> 情况下，</p><p><span class="math display">\[\left | \sum_{i=1}^{5} \beta_{i} p_{i} \right | = 1\]</span></p><p>因此，我们可以得到答案：</p><p><span class="math display">\[\lim _{n \to \infty} \operatorname{Pr} \left \{X_{2n}^{(i)} \text { isall even } \right \} = \frac{1}{2^{5}} \left [ (+1)^{2n} + (-1)^{2n}\right ] = \frac{1}{16}\]</span></p><h1 id="problem-7">Problem 7</h1><p>有这么一个音乐盒，它上面有一个圆形的轨道，轨道上的一点处还有一棵开花的树。当音乐盒处于开启模式时，音乐盒会发出音乐，轨道会按照顺时针匀速转动。</p><p>你可以在轨道上放置象征恋人的两颗棋子，我们不妨称它们为小红和小绿。当小红和小绿没有到达树下时，它们就会在轨道上各自移动。当某一颗棋子到达树下时，它就会在树下原地等待一段时间。此段时间内，如果另外一颗棋子也达到了树下，那么两颗棋子就会相遇，之后在它们将随即一起顺着轨道移动，不再分开；否则，等待时间结束，两颗棋子将各自顺着轨道继续移动。</p><p>考虑这个音乐盒的数学模型。我们把这个圆形轨道参数化成一个周长为 <span class="math inline">\(1\)</span>的圆环，我们认为棋子和树都可以用圆环上点表示。具体来说，我们用 <span class="math inline">\(X(t) \in [0, 1]\)</span> 和 <span class="math inline">\(Y(t) \in [0, 1]\)</span> 分别表示 <span class="math inline">\(t\)</span>时刻小红和小绿的在轨道上的位置坐标，而树的坐标是 <span class="math inline">\(\phi = 1\)</span> ，或者，等价地， <span class="math inline">\(\phi = 0\)</span> 。</p><p>当他们都没有抵达树下时 (见左图) ，他们的位置变化规律满足</p><p><span class="math display">\[\frac{\mathrm{d}}{\mathrm{d} t} X(t)=1, \quad\frac{\mathrm{d}}{\mathrm{d} t} Y(t) = 1\]</span></p><p>假设在 <span class="math inline">\(t_0\)</span>时刻，小绿到达了树下（见中图），即 <span class="math inline">\(Y \left(t_0 \right) = 1\)</span> ，它就会至多等待</p><p><span class="math display">\[\tau = K \left (X \left( t_0 \right ) \right)\]</span></p><p>的时间，换句话说，最长等待时间依赖于小红的当时的位置。</p><p>在等待期间，小绿不动，小红继续移动。如果等待期间的某时刻 <span class="math inline">\(t^\ast \in \left(t_0, t_0+\tau\right]\)</span>，小红也达到了树下，即 <span class="math inline">\(X\left (t^\ast\right) = 1\)</span>，那么两棋子相遇。如果等待时间结束时（见右图），小红仍没有到达树下，那么它们俩继续移动，此时他们的位置分别是</p><p><span class="math display">\[X \left(t_0 + \tau \right) = X \left(t_0 \right) + \tau, \quad Y\left(t_0 + \tau \right) = 0 .\]</span></p><p>注意，虽然小绿的坐标被重置了，但是它在圆环上的位置并没有变。</p><p>如果在某时刻小红到达树下，它也会按照相同的规则等待，最长等待时间取决于此时小绿的位置。显然，小红小绿的命运取决于最长等待时间函数<span class="math inline">\(K(\phi)\)</span> 的形式。</p><figure><img src="https://www.longluo.me/assets/blog/images/math/2024-alibaba-math-contest-problem7.png" alt="图2. Problem 7"><figcaption aria-hidden="true">图2. Problem 7</figcaption></figure><ol type="1"><li><strong>证明题 (10分)</strong> 我们设 <span class="math inline">\(f:\mathbb{R} \to \mathbb{R}\)</span> 是一个光滑函数， 满足</li></ol><p><span class="math display">\[f^{\prime} &gt; 0, \quad f^{\prime \prime} &lt; 0, \quad f(0)=0, \quadf(1) = 1 .\]</span></p><p>并设 <span class="math inline">\(\varepsilon\)</span>是一个充分小的正的常数。我们定义等待时间函数</p><p><span class="math display">\[K(\phi ) = f^{-1}(f(\phi ) + \epsilon ) - \phi .\]</span></p><p>证明除了唯一的例外（特定的初始距离）之外，无论小红和小绿的初始距离如何，他们最终会相遇的。</p><ol start="2" type="1"><li><strong>问答题 (10分)</strong> 我们考虑一个如下形式的 <span class="math inline">\(f\)</span> 函数</li></ol><p><span class="math display">\[f(\phi ) = \frac {1}{b} \ln \left (1 + \left (e^b - 1 \right ) \phi\right )\]</span></p><p>这里 <span class="math inline">\(b&gt;0\)</span> 是一个常数。当 <span class="math inline">\(b \ll 1, \varepsilon \ll 1\)</span>时，请估算出相遇之前小红小绿走过的圈数的数量级。</p><h2 id="solution-8">Solution</h2><blockquote><p>[!TIP] 这道题考试的时候没做出来，最近几天看了知乎上关于这次考试的讨论<a href="https://www.zhihu.com/question/652949289">如何评价2024阿里巴巴数学竞赛预选赛试题?</a>，看了大神们的解答，发现这道题不难，不要以为它是压轴题就觉得很难。这道题的关键在于找到小红和小绿的距离递推关系式，然后对这个关系式进行分析。下面的解法参考了知乎Fiddie 的解答<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> ，<a href="https://www.zhihu.com/people/s7gp3x">喵喵</a> 的解答<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>，我综合他们的解题思路自己推了一遍。</p></blockquote><p>由题设条件，我们知道当小红和小绿都没有在树下时，都随着圆形轨道顺时针匀速转动，也因此小红和小绿<strong>只可能</strong>在树下相遇。</p><p>不妨设<strong>最初条件</strong>为小红在小绿的前方，两者的距离为 <span class="math inline">\(d_0, \ d_0 \in (0, 1)\)</span> ， <span class="math inline">\(d_0 \le 0\)</span> 或 <span class="math inline">\(d_0 \ge 1\)</span> 两者相遇无需讨论。</p><p>当小红来到树下，此时小绿距离树下还有一段距离，小红将在树下等待一段时间。假设在小红等待时间结束之前，小绿都没能赶到树下，那么在等待时间结束时，记为<span class="math inline">\(t_{k}\)</span> 时刻。在 <span class="math inline">\(t_{k}\)</span> 时小绿距离树下还有 <span class="math inline">\(d_k\)</span> 的距离，即 <span class="math inline">\(X(t_k) = 0, \ Y(t_k) = 1 - d_k\)</span> 。</p><p>小红继续出发，在 <span class="math inline">\(d_k\)</span> 时之后，即<span class="math inline">\(t_k + d_k\)</span>时小绿将到达树下。此时小红已经出发了 <span class="math inline">\(d_k\)</span> 的距离，即 <span class="math inline">\(X(t_k) = d_k, \ Y(t_k) = 1\)</span> 。</p><p>小绿将在树下等待小红 <span class="math inline">\(\tau = K \left (X\left (d_{k} \right ) \right )\)</span> 的时间，即：</p><p><span class="math display">\[\begin{equation}\tau = K \left (X \left (d_{k} \right ) \right ) = f^{-1}(f(d_k) +\varepsilon) - d_k   \tag{7.1.1} \label{7.1.1}\end{equation}\]</span></p><p>分析 <span class="math inline">\(\eqref{7.1.1}\)</span> 可知：</p><ol type="1"><li><p>如果 <span class="math inline">\(f^{-1}(f(d_k) + \varepsilon) \ge1\)</span>，则小红将在等待时间结束之前到达树下，小红和小绿相遇，结束分析。</p></li><li><p>如果 <span class="math inline">\(f^{-1}(f(d_k) + \varepsilon)&lt; 1\)</span>，那么在小绿等待时间结束之前，小红没能赶到树下。</p></li></ol><p>在小绿等待时间结束那一刻，我们记为 <span class="math inline">\(t_{k+1}\)</span> 时刻，此时 <span class="math inline">\(X(t_{k+1}) = f^{-1}(f(d_k) + \varepsilon), \Y(t_{k+1}) = 0\)</span> ，两者距离为：</p><p><span class="math display">\[\begin{equation}d_{k+1} = 1 - f^{-1}(f(d_k) + \varepsilon)    \tag{7.1.2} \label{7.1.2}\end{equation}\]</span></p><p>至此我们找到了小红与小绿之间的<strong>距离递推关系式</strong>。</p><p>设两者之间<strong>距离数列</strong> ${ d_n } $表示一个人刚要从树下出发，另外一个距离树下的距离，那么问题转化为：对于任意初值<span class="math inline">\(d_0 \in (0, 1)\)</span>，除了某个特定的初始距离值之外，都存在某个 <span class="math inline">\(k\in \mathrm{Z^+}\)</span> ，使得数列 <span class="math inline">\(d_k \le0\)</span> 或者 <span class="math inline">\(d_k \ge 1\)</span> 。</p><p>这里我们需要证明 <span class="math inline">\(2\)</span> 种情况：</p><ol type="1"><li>存在某个特定的初始距离，使得小红和小绿永远不相遇；</li><li>除了某个特定的初始距离之外，小红和小绿总会相遇。</li></ol><p>考虑函数 <span class="math inline">\(g(x)\)</span>表示两者之间距离，函数 <span class="math inline">\(h(x)\)</span>表示前后时刻（ <span class="math inline">\(t_{k}\)</span> 和 <span class="math inline">\(t_{k+1}\)</span>）两者之间的<strong>距离变化</strong>，即 <span class="math inline">\(\Delta d = d_{k+1} - d_k = 1 - f^{-1}(f(d_k) +\varepsilon) - d_k\)</span> 。</p><p>则有：</p><p><span class="math display">\[\begin{equation}g(x) = 1 - f^{-1}(f(x) + \varepsilon) , \ x \in (0, 1)     \tag{7.1.3}\label{7.1.3}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}h(x) = g(x) - x = 1 - f^{-1}(f(x) + \varepsilon) - x     \tag{7.1.4}\label{7.1.4}\end{equation}\]</span></p><p>对 <span class="math inline">\(g(x) , \ h(x)\)</span> 求导可得：</p><p><span class="math display">\[\begin{equation}g^{\prime}(x) = \frac{\mathrm{d} g(x)}{\mathrm{d} x} = -\frac{f^{\prime}(x)} {f^{\prime}\left(f^{-1}(f(x) +\varepsilon)\right)}  \tag{7.1.5} \label{7.1.5}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}h^{\prime}(x) = \frac{\mathrm{d} h(x)}{\mathrm{d} x} = -1 -\frac{f^{\prime}(x)} {f^{\prime}\left(f^{-1}(f(x) +\varepsilon)\right)}  \tag{7.1.6} \label{7.1.6}\end{equation}\]</span></p><p>因为 <span class="math inline">\(f^{\prime}&gt;0 , f^{\prime \prime}&lt; 0\)</span> ，所以 <span class="math inline">\((f^{-1})^{\prime}&gt;0\)</span> , <span class="math inline">\(\left(f^{-1}\right)^{\prime \prime}&gt;0\)</span>，</p><p>又 <span class="math inline">\(h(0) = 1 - f^{-1}(\varepsilon) &gt;0\)</span> ， <span class="math inline">\(h(1) = - f^{-1}(f(1) +\varepsilon) &lt; 0\)</span> ，所以 <span class="math inline">\(h(x)\)</span> 在</p><p>针对第 <span class="math inline">\(1\)</span>种情况，需要证明：<strong>存在性</strong>和<strong>唯一性</strong>。</p><p>设距离数列 ${ d_n } $ 存在某个初值 <span class="math inline">\(d_0 =d^\ast\)</span> 满足公式 <span class="math inline">\(\eqref{7.1.2}\)</span> 使得 <span class="math inline">\(d_k = d^\ast , k = 0, 1, \cdots , n\)</span>，所以：</p><p><span class="math display">\[\begin{equation}d_{k+1} = d_k \Leftrightarrow d^\ast = 1 - f^{-1} \left (f(d^\ast) +\varepsilon \right )  \end{equation}\]</span></p><p>进一步化简可得：</p><p><span class="math display">\[\begin{equation}f(1 - d^\ast) = f(d^\ast) + \varepsilon         \end{equation}\]</span></p><p>设 <span class="math inline">\(x_1 = d^\ast, \ x_2 = 1 -d^\ast\)</span> ，那么 <span class="math inline">\(x_1, \ x_2\)</span>关于 <span class="math inline">\(\frac{1}{2}\)</span> 对称，那么存在<span class="math inline">\(x_1 = \frac{1}{2} - \varepsilon^\ast ，x_2 =\frac{1}{2} + \varepsilon^\ast, \ \varepsilon^\ast &gt; 0\)</span>。</p><p>根据题设条件 <span class="math inline">\(f^{\prime} &gt; 0\)</span>， <span class="math inline">\(f(0) = 0, \ f(1) = 1\)</span> ， <span class="math inline">\(f\)</span> 在 <span class="math inline">\([0,1]\)</span> 是<strong>单调递增</strong>的光滑函数，那么 <span class="math inline">\(f(x_2) &gt; f(x_1) &gt; 0\)</span>，故<strong>存在性</strong>得证。</p><p>下面来证明<strong>唯一性</strong>，由公式 <span class="math inline">\(\eqref{7.1.5}\)</span> ，可得： <span class="math inline">\(f(1 - d^\ast) - f(d^\ast) = \varepsilon\)</span>。</p><p>令函数 <span class="math inline">\(g(x) = f(1 - x) - f(x), \ x \in(0,1)\)</span> ，对 <span class="math inline">\(g(x)\)</span> 求导：</p><p><span class="math display">\[\begin{equation}g^{\prime}(x) = - f^{\prime}(1 - x) - f^{\prime}(x) &lt; 0 , \ x \in(0,1)      \end{equation}\]</span></p><p><span class="math inline">\(g(x)\)</span> 单调递减， <span class="math inline">\(g(0) = 1, \ g(\frac{1}{2}) = 0\)</span> ，<span class="math inline">\(g(x)\)</span>连续，故<strong>有且仅存在一个</strong> <span class="math inline">\(x\in (0, \frac{1}{2})\)</span> ，使得 <span class="math inline">\(g(x) =\varepsilon\)</span> ，所以<strong>唯一性</strong>得证。</p><p>故存在某个特定的初始距离 <span class="math inline">\(d_0 =d^\ast\)</span> ，使得小红和小绿永远不相遇。</p><p>下面来证明 <span class="math inline">\(d_0 \ne d^\ast\)</span>的情况，这里也可以分为 <span class="math inline">\(2\)</span>种情况讨论，<span class="math inline">\(0 &lt; d_0 &lt; d^\ast\)</span>和 <span class="math inline">\(d^\ast &lt; d_0 &lt; 1\)</span> 。</p><p><span class="math display">\[\phi_{n+1}=g\left(g\left(\phi_n\right)\right)=1-\left(g\left(\phi_n\right)+K\left(g\left(\phi_n\right)\right)\right)=\phi_n+K\left(\phi_n\right)-K\left(g\left(\phi_n\right)\right)&lt;\phi_n\]</span> , also <span class="math inline">\(g\left(\phi_{n+1}\right)&gt;g\left(\phi_n\right)\)</span>.Then</p><p><span class="math display">\[\phi_{n+1}-\phi_{n+2}=K\left(g\left(\phi_{n+1}\right)\right)-K\left(\phi_{n+1}\right)&gt;K\left(g\left(\phi_n\right)\right)-K\left(\phi_n\right)=\phi_n-\phi_{n+1}\]</span></p><p>, showing that</p><p><span class="math display">\[d_k = d_0 - (d_0 - d_1) - (d_1 - d_2) - \cdots - (d_{k-1} - d_k) \leqd_0 - k(d_0 - d_1)\]</span></p><p>故所求上界 <span class="math inline">\(k = \left \lceil\frac{d_0}{d_0 - d_1} \right \rceil\)</span> ，使得 <span class="math inline">\(d_k \leq 0\)</span> ，小红和小绿终将相遇。</p><p><span class="math display">\[d_k = d_0 + (d_0 - d_1) + (d_1 - d_2) + \cdots + (d_{k-1} - d_k) \ge d_0+ k(d_0 - d_1)\]</span></p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Poisson_point_process">泊松过程</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://en.wikipedia.org/wiki/Poisson_distribution">泊松分布</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Binomial_distribution">二项分布</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Binomial_theorem">二项式定理</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Multinomial_theorem">多项式定理</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://www.zhihu.com/question/652949289/answer/3466235067">Fiddie的试题解答</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://zhuanlan.zhihu.com/p/692476253">喵喵的试题解答</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://damo.alibaba.com/?language=zh&quot;&gt;阿里巴巴达摩院&lt;/a&gt; 从
2018
年开始每年都会举办一届全球数学竞赛，之前一方面自己数学水平比较弱，另外一方面也没有报名，但一直很仰慕那些数学大神的风采。今年是第一次报名参加
&lt;a href=&quot;https://damo.alibaba.com/alibaba-global-mathematics-competition?language=zh&quot;&gt;2024阿里巴巴全球数学竞赛&lt;/a&gt;
，上周末参加了预选赛，但遗憾的是，全部 &lt;span class=&quot;math inline&quot;&gt;&#92;(7&#92;)&lt;/span&gt; 道题中只有第 &lt;span class=&quot;math inline&quot;&gt;&#92;(1, 2, 6&#92;)&lt;/span&gt; 题会做，这里分享下我的解答：&lt;/p&gt;
&lt;h1 id=&quot;problem-1&quot;&gt;Problem 1&lt;/h1&gt;
&lt;p&gt;几位同学假期组成一个小组去某市旅游. 该市有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 座塔，它们的位置分别为 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D, E, F&#92;)&lt;/span&gt;
。同学们自由行动一段时间后，每位同学都发现，自己在所在的位置只能看到位于
&lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D&#92;)&lt;/span&gt; 处的四座塔，而看不到位于
&lt;span class=&quot;math inline&quot;&gt;&#92;(E&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;(F&#92;)&lt;/span&gt; 的塔。已知：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;同学们的位置和塔的位置均视为同一平面上的点，且这些点彼此不重合；&lt;/li&gt;
&lt;li&gt;塔中任意 &lt;span class=&quot;math inline&quot;&gt;&#92;(3&#92;)&lt;/span&gt; 点不共线；&lt;/li&gt;
&lt;li&gt;看不到塔的唯一可能就是视线被其它的塔所阻挡，例如，如果某位同学所在的位置
&lt;span class=&quot;math inline&quot;&gt;&#92;(P&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;(A
, B&#92;)&lt;/span&gt; 共线，且 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; 在线段
&lt;span class=&quot;math inline&quot;&gt;&#92;(PB&#92;)&lt;/span&gt; 上，那么该同学就看不到位于 &lt;span class=&quot;math inline&quot;&gt;&#92;(B&#92;)&lt;/span&gt; 处的塔。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;（5 分）&lt;/strong&gt; 请问 这个旅游小组最多可能有多少名同学？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(A. 3&#92;)&lt;/span&gt;&lt;br&gt;
&lt;span class=&quot;math inline&quot;&gt;&#92;(B. 4&#92;)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;&#92;(C.
6&#92;)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;&#92;(D. 12&#92;)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;这道题选 &lt;span class=&quot;math inline&quot;&gt;&#92;(C&#92;)&lt;/span&gt; ，最多只能有 &lt;span class=&quot;math inline&quot;&gt;&#92;(C_{4}^{2} = 6&#92;)&lt;/span&gt; 名同学。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP] 这道题的解题思路是，从假设只有 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 座塔开始，一直到 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 座塔，找到思路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; ，那么很显然有无数多同学可以看到塔
&lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; ，也可以有无数多同学看不到塔
&lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt;​ ；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B&#92;)&lt;/span&gt; ，那么只有以 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; 为起点的射线 &lt;span class=&quot;math inline&quot;&gt;&#92;(AB&#92;)&lt;/span&gt; 且位于 &lt;span class=&quot;math inline&quot;&gt;&#92;(B&#92;)&lt;/span&gt; 之后的同学无法看到塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A&#92;)&lt;/span&gt; ；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(3&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C&#92;)&lt;/span&gt;
，同理可知存在无数位同学至少可以看见 &lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 座塔；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(4&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D&#92;)&lt;/span&gt;
，同理可知存在无数位同学至少可以看见 &lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 座塔；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 座塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(A, B, C, D, E, F&#92;)&lt;/span&gt; ，如果每位同学都无法看见
&lt;span class=&quot;math inline&quot;&gt;&#92;(E, F&#92;)&lt;/span&gt; 塔，如下图1 所示：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.longluo.me/assets/blog/images/math/2024-alibaba-math-contest-problem1-solution.png&quot; alt=&quot;图1. Solution of Problem 1&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;图1. Solution of Problem 1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;所以至多有 &lt;span class=&quot;math inline&quot;&gt;&#92;(6&#92;)&lt;/span&gt; 位同学位于 &lt;span class=&quot;math inline&quot;&gt;&#92;(M, N, O, P, R, Q&#92;)&lt;/span&gt; 处，无法看到塔 &lt;span class=&quot;math inline&quot;&gt;&#92;(E, F&#92;)&lt;/span&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Geometry" scheme="https://www.longluo.me/tags/Geometry/"/>
    
    <category term="Algebra" scheme="https://www.longluo.me/tags/Algebra/"/>
    
    <category term="Probability" scheme="https://www.longluo.me/tags/Probability/"/>
    
    <category term="Analysis" scheme="https://www.longluo.me/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>如何证明泰勒公式?</title>
    <link href="https://www.longluo.me/blog/2024/02/24/taylor/"/>
    <id>https://www.longluo.me/blog/2024/02/24/taylor/</id>
    <published>2024-02-24T11:52:19.000Z</published>
    <updated>2024-02-25T13:02:43.067Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><p><span class="math display">\[\begin{aligned}f(x) &amp; = f(a) + f(x) - f(a) \\&amp; = f(a) + \int_a^x f'(t) \mathrm{d}t \\&amp; = f(a) - \int_a^x f'(t) \mathrm{d}(x-t) \\&amp; = f(a) - f'(t)(x - t)|_a^x - \frac12 \int_a^x f''(t)\mathrm{d}[(x-t)^2]  \\&amp; = f(a) + f'(a)(x - a) + {f''(a) \over 2}(x - a)^2 - {1\over 3!} \int_a^x f'''(t) \mathrm{d}[(x-t)]^3\end{aligned}\]</span></p><p>不断重复这一过程，可知当 f 的 n+1 阶导数连续时，有：</p><p><span class="math display">\[f(x) = \sum_{k=0}^n {f^{(k)}(a) \over k!}(x-a)^k + R_n(x)\]</span></p><p>其中积分余项 为：</p><p><span class="math display">\[R_n(x) = {1 \over n!} \int_a^x f^{(n + 1)}(t)(x - t)^n \mathrm{d}t\]</span></p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Taylor%27s_theorem">Taylor’stheorem</a></li><li><a href="https://en.wikipedia.org/wiki/Taylor_series">TaylorSeries</a></li><li><a href="https://betterexplained.com/articles/taylor-series/">Intuition forTaylor Series</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
f(x) &amp;amp; = f(a) + f(x) -</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Taylor" scheme="https://www.longluo.me/tags/Taylor/"/>
    
  </entry>
  
  <entry>
    <title>库函数 (libm) 是如何计算三角函数值的？</title>
    <link href="https://www.longluo.me/blog/2024/02/16/sine/"/>
    <id>https://www.longluo.me/blog/2024/02/16/sine/</id>
    <published>2024-02-16T12:32:58.000Z</published>
    <updated>2024-03-04T13:16:46.732Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑！</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the trigonometric sine of an angle.  Special cases:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the</span></span><br><span class="line"><span class="comment"> * result is NaN.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;If the argument is zero, then the result is a zero with the</span></span><br><span class="line"><span class="comment"> * same sign as the argument.&lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The computed result must be within 1 ulp of the exact result.</span></span><br><span class="line"><span class="comment"> * Results must be semi-monotonic.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   a   an angle, in radians.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the sine of the argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> a)</span> {</span><br><span class="line">    <span class="keyword">return</span> StrictMath.sin(a); <span class="comment">// default impl. delegates to StrictMath</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the trigonometric sine of an angle. Special cases:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the</span></span><br><span class="line"><span class="comment"> * result is NaN.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;If the argument is zero, then the result is a zero with the</span></span><br><span class="line"><span class="comment"> * same sign as the argument.&lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   a   an angle, in radians.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the sine of the argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> a)</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @(#)k_sin.c 1.3 95/01/18 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ====================================================</span></span><br><span class="line"><span class="comment"> * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Developed at SunSoft, a Sun Microsystems, Inc. business.</span></span><br><span class="line"><span class="comment"> * Permission to use, copy, modify, and distribute this</span></span><br><span class="line"><span class="comment"> * software is freely granted, provided that this notice</span></span><br><span class="line"><span class="comment"> * is preserved.</span></span><br><span class="line"><span class="comment"> * ====================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* __kernel_sin( x, y, iy)</span></span><br><span class="line"><span class="comment"> * kernel sin function on [-pi/4, pi/4], pi/4 ~ 0.7854</span></span><br><span class="line"><span class="comment"> * Input x is assumed to be bounded by ~pi/4 in magnitude.</span></span><br><span class="line"><span class="comment"> * Input y is the tail of x.</span></span><br><span class="line"><span class="comment"> * Input iy indicates whether y is 0. (if iy=0, y assume to be 0). </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Algorithm</span></span><br><span class="line"><span class="comment"> *1. Since sin(-x) = -sin(x), we need only to consider positive x. </span></span><br><span class="line"><span class="comment"> *2. if x &lt; 2^-27 (hx&lt;0x3e400000 0), return x with inexact if x!=0.</span></span><br><span class="line"><span class="comment"> *3. sin(x) is approximated by a polynomial of degree 13 on</span></span><br><span class="line"><span class="comment"> *   [0,pi/4]</span></span><br><span class="line"><span class="comment"> *           3            13</span></span><br><span class="line"><span class="comment"> *   sin(x) ~ x + S1*x + ... + S6*x</span></span><br><span class="line"><span class="comment"> *   where</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * |sin(x)         2     4     6     8     10     12  |     -58</span></span><br><span class="line"><span class="comment"> * |----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| &lt;= 2</span></span><br><span class="line"><span class="comment"> * |  x            | </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *4. sin(x+y) = sin(x) + sin'(x')*y</span></span><br><span class="line"><span class="comment"> *    ~ sin(x) + (1-x*x/2)*y</span></span><br><span class="line"><span class="comment"> *   For better accuracy, let </span></span><br><span class="line"><span class="comment"> *     3      2      2      2      2</span></span><br><span class="line"><span class="comment"> *r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))</span></span><br><span class="line"><span class="comment"> *   then                   3    2</span></span><br><span class="line"><span class="comment"> *sin(x) = x + (S1*x + (x *(r-y/2)+y))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FDLIBM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fdlibm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> __kernel_sin(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">int</span> iy)</span><br><span class="line">{</span><br><span class="line"><span class="type">double</span> z, r, v;</span><br><span class="line"><span class="type">int32_t</span> ix;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> half = <span class="number">5.00000000000000000000e-01</span>;<span class="comment">/* 0x3FE00000, 0x00000000 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S1 = <span class="number">-1.66666666666666324348e-01</span>;<span class="comment">/* 0xBFC55555, 0x55555549 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S2 = <span class="number">8.33333333332248946124e-03</span>;<span class="comment">/* 0x3F811111, 0x1110F8A6 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S3 = <span class="number">-1.98412698298579493134e-04</span>;<span class="comment">/* 0xBF2A01A0, 0x19C161D5 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S4 = <span class="number">2.75573137070700676789e-06</span>;<span class="comment">/* 0x3EC71DE3, 0x57B1FE7D */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S5 = <span class="number">-2.50507602534068634195e-08</span>;<span class="comment">/* 0xBE5AE5E6, 0x8A2B9CEB */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> S6 = <span class="number">1.58969099521155010221e-10</span>;<span class="comment">/* 0x3DE5D93A, 0x5ACFD57C */</span></span><br><span class="line"></span><br><span class="line">GET_HIGH_WORD(ix, x);</span><br><span class="line">ix &amp;= IC(<span class="number">0x7fffffff</span>);<span class="comment">/* high word of x */</span></span><br><span class="line"><span class="keyword">if</span> (ix &lt; IC(<span class="number">0x3e400000</span>))<span class="comment">/* |x| &lt; 2**-27 */</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int32_t</span>) x == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x;<span class="comment">/* generate inexact */</span></span><br><span class="line">}</span><br><span class="line">z = x * x;</span><br><span class="line">v = z * x;</span><br><span class="line">r = S2 + z * (S3 + z * (S4 + z * (S5 + z * S6)));</span><br><span class="line"><span class="keyword">if</span> (iy == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x + v * (S1 + z * r);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> x - ((z * (half * y - v * r) - y) - v * S1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="math display">\[\sin (x_0 + \Delta x) \approx \sin (x_0) + \sin'(x_0) \frac {\Deltax}{1!} + \sin''(x_0) \frac { \Delta x^2}{2!} +\sin'''(x_0) \frac {\Delta x^3}{3!} + \cdots\]</span></p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/C_mathematical_functions">Cmathematical functions</a></li><li><a href="https://en.wikipedia.org/wiki/Sine_and_cosine">Sine andcosine</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑！&lt;/h1&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>切比雪夫滤波器</title>
    <link href="https://www.longluo.me/blog/2024/02/03/chebyshev-filters/"/>
    <id>https://www.longluo.me/blog/2024/02/03/chebyshev-filters/</id>
    <published>2024-02-03T02:17:19.000Z</published>
    <updated>2024-02-25T13:27:25.492Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Chebyshev_filter">Chebyshevfilter</a></li><li><a href="https://components101.com/articles/different-types-of-chebyshev-filters">ExploringDifferent Types of Chebyshev Filters</a></li><li><a href="https://web.njit.edu/~gilhc/EE494/ee494main.htm">CSpecifyingChebyshev Filters</a></li><li><a href="https://www.electronics-notes.com/articles/radio/rf-filters/what-is-chebychev-filter-basics.php">Whatis a Chebyshev RF Filter - the basics</a></li><li><a href="https://en.wikipedia.org/wiki/Geometric_series">Geometricseries</a></li><li><a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomialcoefficient</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Physics" scheme="https://www.longluo.me/tags/Physics/"/>
    
  </entry>
  
  <entry>
    <title>payne hanek 归约算法</title>
    <link href="https://www.longluo.me/blog/2024/01/22/payne-hanek/"/>
    <id>https://www.longluo.me/blog/2024/01/22/payne-hanek/</id>
    <published>2024-01-22T13:10:50.000Z</published>
    <updated>2024-02-25T12:34:22.666Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/582590074">CodyWaite和Payne-Hanek归约算法的详细解释</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.c</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Argument Reduction" scheme="https://www.longluo.me/tags/Argument-Reduction/"/>
    
    <category term="Computer Arithmetic" scheme="https://www.longluo.me/tags/Computer-Arithmetic/"/>
    
    <category term="参数归约" scheme="https://www.longluo.me/tags/%E5%8F%82%E6%95%B0%E5%BD%92%E7%BA%A6/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
    <category term="Trigonometric" scheme="https://www.longluo.me/tags/Trigonometric/"/>
    
  </entry>
  
  <entry>
    <title>音乐背后的数学</title>
    <link href="https://www.longluo.me/blog/2024/01/12/the-math-of-music/"/>
    <id>https://www.longluo.me/blog/2024/01/12/the-math-of-music/</id>
    <published>2024-01-12T11:18:38.000Z</published>
    <updated>2024-03-11T13:10:24.222Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="声音是什么">声音是什么？</h1><h1 id="什么是和弦">什么是和弦？</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://plus.maths.org/content/magical-mathematics-music">Themagical mathematics of music</a></li><li><a href="https://mp.weixin.qq.com/s/KxePYsQY7sHDnFnaZjP6lA">北大王杰教授：用数学分析动人音乐的奥秘（上）</a></li><li><a href="https://mp.weixin.qq.com/s/BrwDDcIWEXqmCKnq63duvg">北大王杰教授：用数学分析动人音乐的奥秘（下）</a></li><li><a href="https://www.numericana.com/answer/music.htm">MathematicalAspects of Music</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;声音是什么&quot;&gt;声音是什么？&lt;/h1&gt;
&lt;h1 id=&quot;什么是和弦&quot;&gt;什么是和弦？&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Music" scheme="https://www.longluo.me/tags/Music/"/>
    
  </entry>
  
  <entry>
    <title>素描背后的物理</title>
    <link href="https://www.longluo.me/blog/2023/12/30/the-physics-behind-drawings/"/>
    <id>https://www.longluo.me/blog/2023/12/30/the-physics-behind-drawings/</id>
    <published>2023-12-30T14:53:51.000Z</published>
    <updated>2024-03-11T13:15:42.116Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Light">Light</a></li><li><a href="https://en.wikipedia.org/wiki/Diffuse_reflection">Diffusereflection</a></li><li><a href="https://en.wikipedia.org/wiki/Reflection_(physics)">Reflection(physics)</a></li><li><a href="https://en.wikipedia.org/wiki/Bloom_(shader_effect)">Bloom(shader effect)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    <category term="Physics" scheme="https://www.longluo.me/categories/Physics/"/>
    
    
    <category term="Physics" scheme="https://www.longluo.me/tags/Physics/"/>
    
  </entry>
  
  <entry>
    <title>cody waite</title>
    <link href="https://www.longluo.me/blog/2023/12/19/cody-waite/"/>
    <id>https://www.longluo.me/blog/2023/12/19/cody-waite/</id>
    <published>2023-12-19T12:10:19.000Z</published>
    <updated>2024-02-25T12:34:30.747Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/582590074">CodyWaite和Payne-Hanek归约算法的详细解释</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.c</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Argument Reduction" scheme="https://www.longluo.me/tags/Argument-Reduction/"/>
    
    <category term="Computer Arithmetic" scheme="https://www.longluo.me/tags/Computer-Arithmetic/"/>
    
    <category term="参数归约" scheme="https://www.longluo.me/tags/%E5%8F%82%E6%95%B0%E5%BD%92%E7%BA%A6/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
    <category term="Trigonometric" scheme="https://www.longluo.me/tags/Trigonometric/"/>
    
  </entry>
  
  <entry>
    <title>浮点数</title>
    <link href="https://www.longluo.me/blog/2023/12/03/floating-point/"/>
    <id>https://www.longluo.me/blog/2023/12/03/floating-point/</id>
    <published>2023-12-03T14:12:45.000Z</published>
    <updated>2024-05-24T13:17:21.065Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><p>假如你知道浮点数的话，你就知道为什么了！</p><p>按照 IEEE 754 浮点数标准 制定的 浮点数运算法则， float类型的单精度浮点数 的尾数部分有 <span class="math inline">\(\large{23}\)</span> 位二进制数，如下图所示：</p><figure><img src="http://www.longluo.me/assets/blog/images/floating_point/ieee_754_single_floating_point_format.svg" alt="IEEE_754_Single_Floating_Point_Format"><figcaption aria-hidden="true">IEEE_754_Single_Floating_Point_Format</figcaption></figure><p>在十进制下，大致相当于 <span class="math inline">\(\large{\log_{10}{2^{23}} = 23 \cdot \log {2} \approx 23 \times 0.301 \approx6.9}\)</span> ，有效数字大约有 <span class="math inline">\(\large{7}\)</span> 位。</p><p>所以当 <span class="math inline">\(\large {x = 1000001}\)</span>时，我们应该使用 double 类型的双精度浮点数 [^12]，这样才能保证结果有<strong>足够的精度</strong>！</p><p>双精度浮点数的尾数部分有 <span class="math inline">\(\large{52}\)</span> 位，如下图所示：</p><figure><img src="http://www.longluo.me/assets/blog/images/floating_point/ieee_754_double_floating_point_format.svg" alt="IEEE_754_Double_Floating_Point_Format"><figcaption aria-hidden="true">IEEE_754_Double_Floating_Point_Format</figcaption></figure><p>在十进制中大致相当于 <span class="math inline">\(\large{\log_{10}{2^{52}} = 52 \cdot \log {2} \approx 52 \times 0.301 \approx15.6}\)</span> ，也就是说当 <span class="math inline">\(\large{x}\)</span> 有效数字是 <span class="math inline">\(\large {[7,15]}\)</span> 时，我们应该使用 double类型的双精度浮点数可以保证精度！</p><p>但这仍然有个问题，那就是 <span class="math inline">\(\large{x}\)</span> 有效数字 超过 <span class="math inline">\(\large{15}\)</span> 位，应该怎么办？</p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li><li><a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">Floating-pointarithmetic</a></li><li><a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">Single-precisionfloating-point format</a></li><li><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">Double-precisionfloating-point format</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;p&gt;假如你知道浮点数的话，你就知道为什么了！&lt;/p&gt;
&lt;p&gt;按照 IEEE 754 浮点数标准 制定的 浮点数运算法则， float
类型的单精度浮</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>古巴比伦泥板上的神秘数字：根号2背后的4000年数学史</title>
    <link href="https://www.longluo.me/blog/2023/11/10/square-root-of-two/"/>
    <id>https://www.longluo.me/blog/2023/11/10/square-root-of-two/</id>
    <published>2023-11-10T13:26:07.000Z</published>
    <updated>2024-01-26T15:19:06.534Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>（挖坑！）</p><h1 id="a4-纸背后的科学">A4 纸背后的科学</h1><p>A系列纸张尺寸的长短比(宽高比)都是 <span class="math inline">\(1:{\sqrt {2}}\)</span> ，然后舍去到最接近的毫米值。A0</p><h1 id="泥板上的神秘数字">泥板上的神秘数字</h1><h1 id="第一次数学危机">第一次数学危机</h1><h1 id="古巴比伦法求根号-2">古巴比伦法求根号 2</h1><h1 id="牛顿迭代法">牛顿迭代法</h1><h1 id="总结">总结</h1><h1 id="参考文献">参考文献</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（挖坑！）&lt;/p&gt;
&lt;h1 id=&quot;a4-纸背后的科学&quot;&gt;A4 纸背后的科学&lt;/h1&gt;
&lt;p&gt;A系列纸张尺寸的长短比(宽高比)都是 &lt;span class=&quot;math inline&quot;&gt;</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Square Root" scheme="https://www.longluo.me/tags/Square-Root/"/>
    
  </entry>
  
  <entry>
    <title>Remez Algorithm</title>
    <link href="https://www.longluo.me/blog/2023/10/07/remez-algorithm/"/>
    <id>https://www.longluo.me/blog/2023/10/07/remez-algorithm/</id>
    <published>2023-10-06T23:08:37.000Z</published>
    <updated>2024-03-11T13:17:35.339Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Remez_algorithm">Remezalgorithm</a></li><li><a href="https://mathworld.wolfram.com/RemezAlgorithm.html">RemezAlgorithm</a></li><li><a href="https://blog.csdn.net/m0_66201040/article/details/123955780">8.2雷米兹算法</a></li><li><a href="https://valelab4.ucsf.edu/svn/3rdpartypublic/boost/libs/math/doc/sf_and_dist/html/math_toolkit/backgrounders/remez.html">TheRemez Method</a></li><li><a href="https://en.wikipedia.org/wiki/Geometric_series">Geometricseries</a></li><li><a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomialcoefficient</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Calculus" scheme="https://www.longluo.me/tags/Calculus/"/>
    
    <category term="Taylor Series" scheme="https://www.longluo.me/tags/Taylor-Series/"/>
    
  </entry>
  
  <entry>
    <title>切比雪夫多项式</title>
    <link href="https://www.longluo.me/blog/2023/10/03/chebyshev-polynomials/"/>
    <id>https://www.longluo.me/blog/2023/10/03/chebyshev-polynomials/</id>
    <published>2023-10-03T00:52:21.000Z</published>
    <updated>2024-03-11T13:09:29.886Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><p><span class="math display">\[\begin{aligned}T_0(x) &amp;= 1 \\T_1(x) &amp;= x \\T_n(x) &amp;= 2xT_{n-1}(x) - T_{n-2}(x)\end{aligned}\]</span></p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">ChebyshevPolynomials</a></li><li><a href="https://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html">ChebyshevPolynomial of the First Kind</a></li><li><a href="https://brilliant.org/wiki/chebyshev-polynomials-definition-and-properties/">ChebyshevPolynomials - Definition and Properties</a></li><li><a href="https://blog.csdn.net/m0_66201040/article/details/123954378">8.1切比雪夫近似值求正余弦</a></li><li><a href="https://en.wikipedia.org/wiki/Geometric_series">Geometricseries</a></li><li><a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomialcoefficient</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
T_0(x) &amp;amp;= 1 &#92;&#92;
T_1(x) </summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Calculus" scheme="https://www.longluo.me/tags/Calculus/"/>
    
  </entry>
  
  <entry>
    <title>波是什么？</title>
    <link href="https://www.longluo.me/blog/2023/09/28/wave/"/>
    <id>https://www.longluo.me/blog/2023/09/28/wave/</id>
    <published>2023-09-28T14:10:14.000Z</published>
    <updated>2024-03-16T04:39:30.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Wave">Wave</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Wave&quot;&gt;Wave&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    <category term="Physics" scheme="https://www.longluo.me/categories/Physics/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Physics" scheme="https://www.longluo.me/tags/Physics/"/>
    
    <category term="Wave" scheme="https://www.longluo.me/tags/Wave/"/>
    
  </entry>
  
  <entry>
    <title>参数归约算法(Argument Range Reduction)：如何在浮点数环境下计算超大数字的三角函数值？</title>
    <link href="https://www.longluo.me/blog/2023/09/16/argument-range-reduction/"/>
    <id>https://www.longluo.me/blog/2023/09/16/argument-range-reduction/</id>
    <published>2023-09-16T14:05:07.000Z</published>
    <updated>2024-03-03T07:57:11.759Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>之前写过一篇介绍 CORDIC 算法 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 的文章，里面提到 CORDIC算法的 <a href="http://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/#cordic-%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%8D%E8%B6%B3"><strong>不足</strong></a>之处，CORDIC 算法的输入角度范围需要在 <span class="math inline">\([−99.88^{\circ} , 99.88^{\circ}]\)</span>，那么我们不禁要问，如果输入角度 <span class="math inline">\(\large{\theta }\)</span> 很大的话，怎么处理呢？</p><p>这个问题同样存在于 泰勒展开式(Taylor series) <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>中，比如 <span class="math inline">\(\large {\sin (x) }\)</span> 和<span class="math inline">\(\large {\cos (x) }\)</span>的泰勒展开式：</p><p><span class="math display">\[\sin(x) = x - \frac {1}{3!}x^3 + \frac {1}{5!}x^5 - \frac {1}{7!} x^7 +\frac {1}{9!} x^9 + o(x^9) \quad \forall x \subset \mathbb{R}\]</span></p><p><span class="math display">\[\cos(x) = 1 - \frac {1}{2!}x^2 + \frac {1}{4!}x^4 - \frac {1}{6!} x^6 +\frac {1}{8!} x^8 + o(x^8) \quad \forall x \subset \mathbb{R}\]</span></p><p>虽然在整个实数集 <span class="math inline">\(\large {\mathbb{R}}\)</span>都成立，但是在实际应用中因为展开项数限制和浮点数的精度限制， <span class="math inline">\(\large {x}\)</span> 的范围只有在接近 <span class="math inline">\(\large {0}\)</span> 的时候才有比较高的精度。</p><p>但是实际应用中，如果输入 <span class="math inline">\(\large{x}\)</span> 很大的话，比如 <span class="math inline">\(\large {2^{32},10^{10}, 10^{22} \dots }\)</span> 情况下怎么得到足够精确的值呢？</p><p>中学里我们知道三角函数是<strong>周期函数</strong>，对于比较大的值，我们可以使用下面的公式将值<strong>归约</strong>到一个比较小的范围内。</p><p><span class="math display">\[x' = x - 2k \pi \quad k \subset \mathbb{Z}\]</span></p><p>这就是我们今天要讲的 <strong>参数归约(Argument Reduction)</strong>算法。</p><h1 id="从小学计算题开始">从小学计算题开始</h1><p><strong>参数归约</strong>听起来就很唬人，什么是参数啊，什么归约啊，都是些高大上的名词，听起来云里雾里的！</p><p>为了不让大家产生厌倦和畏难心理，我们先从一道小学数学计算题开始：</p><p>不借助计算器，计算 <span class="math inline">\(\large {66600 \times666000}\)</span> 的值！</p><p>对于这道题，大家可能会列出下列算术：</p><p><span class="math display">\[66600 \times 666000 = 666 \times 666 \times 100000 = 44355600000\]</span></p><p>但其实呢，我们也可以使用下面的方法：</p><p><span class="math display">\[\begin{aligned}66600 \times 666000 &amp;= 111^2 \times 4 \times 9 \times 10^5\\&amp;= 444 \times 999 \times 10^5\\&amp;= 444 \times (1000 - 1) \times 10^5\\&amp;= 4443556 \times 10^5    \end{aligned}\]</span></p><p>如果我说上面这 <span class="math inline">\(\large {2}\)</span>种方法都用到了<strong>参数归约</strong>的思想，你可能会感到震惊，什么？这种小学计算题也用到了参数归约算法吗？</p><span id="more"></span><h1 id="什么是参数归约-argument-reduction">什么是参数归约 ArgumentReduction ？</h1><p>上一章计算 <span class="math inline">\(\large {66600 \times666000}\)</span> 时，我们将 <span class="math inline">\(\large {666\times 666}\)</span> 化简为 <span class="math inline">\(\large {444\times (1000 - 1)}\)</span> ，再在结果后面直接加上 <span class="math inline">\(\large {5}\)</span> 个 <span class="math inline">\(\large {0}\)</span>，那么你有没有想过这背后隐含了什么数学思想吗？</p><p>下面我们正式进入今天的课题：<strong>参数归约(ArgumentReduction)</strong> 。</p><p>为了提高数学函数的计算效率，将初始问题转变或者说缩小到函数更容易计算的域内，这就是参数归约。</p><p>已知函数 <span class="math inline">\(\large {f}\)</span> ，求 <span class="math inline">\(\large {y = f(x)}\)</span> 的值，可以通过以下<span class="math inline">\(\large {3}\)</span> 个步骤进行计算：</p><ol type="1"><li>将 <span class="math inline">\(\large {x}\)</span> 转换为缩小的参数<span class="math inline">\(\large {x'}\)</span> ；</li><li>计算 <span class="math inline">\(\large {y' =f(x')}\)</span> ；</li><li>使用函数恒等式从 <span class="math inline">\(\large{f(x')}\)</span> 计算出 <span class="math inline">\(\large{f(x)}\)</span> 。</li></ol><p>现在回到上一节的小学数学计算题，我们实际上用到了 <span class="math inline">\(\large {2}\)</span> 种参数归约：</p><ol type="1"><li>指数/对数 运算公式</li></ol><p><span class="math display">\[exp(x + y) = \exp(x) \exp(y)\]</span></p><p><span class="math display">\[\log (xy) = \log (x) + \log (y)\]</span></p><ol start="2" type="1"><li>相加公式。不过上面小学数学题用的非常简单的分配律和结合律，实际上我们用的更复杂的公式，比如各种三角恒等式：</li></ol><p><span class="math display">\[\sin (x + y) = \sin(x) \cos (y) + \cos (x) \sin (y)\]</span></p><p><span class="math display">\[\tan (x + y) = \frac {\tan (x) + \tan (y)}{1 - \tan (x) \tan (y)}\]</span></p><p>实际上为了让幂级数更快地收敛，通常我们取 <span class="math inline">\(\large {x = y}\)</span> 以获得双倍公式，比如 <span class="math inline">\(\large {e^ {2x} = (e^x)^2}\)</span> ，比如快速幂算法(Exponentiation by squaring) <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ,其具体实现可参考这篇文章： <a href="http://www.longluo.me/blog/2022/01/02/Leetcode-powx-n/">Fast PowerAlgorithm: Binary Exponentiation</a> 。</p><p>而计算器中也常用到三倍角公式 <span class="math inline">\(\large {\sin(3x) = 3 \sin (x) - 4 \sin ^3(x)}\)</span>去计算三角函数值，具体可参考这个视频： <a href="https://www.bilibili.com/video/BV1AW4y1A7HN">计算器是如何计算出三角函数和对数的？</a>。</p><p>可能有同学会问，那二倍角公式 <span class="math inline">\(\large {\sin(2x) = 2 \sin(x) \cos (x)}\)</span>就不用了吗？这个谜底待后续章节介绍。</p><h1 id="如何对参数进行归约">如何对参数进行归约？</h1><p>这一章我们来讲如何进行参数归约，通常我们区分 <span class="math inline">\(\large {2}\)</span> 种参数归约：</p><ol type="1"><li>加法参数归约： <span class="math inline">\(\large {x' = x -kC}\)</span> ，其中 <span class="math inline">\(\large {C}\)</span>是实常数， <span class="math inline">\(\large {k}\)</span> 是整数。</li></ol><p>这种归约可以应用在 <span class="math inline">\(\large {f(x)}\)</span>是周期函数的情况，比如三角函数，此时 <span class="math inline">\(\large{C = 2 \pi}\)</span> ；也可以应用于其他函数，比如小学数学我们知道计算<span class="math inline">\(\large { \frac {a}{b}}\)</span>就是看有多少个 <span class="math inline">\(\large {b}\)</span>相加小于等于 <span class="math inline">\(\large {a}\)</span>，具体可参考这篇文章：<a href="http://www.longluo.me/blog/2022/05/30/leetcode-divide-two-integers-en/">29.Divide Two Integers</a> 。</p><ol start="2" type="1"><li>乘法参数归约：<span class="math inline">\(\large {x' =\frac{x}{kC}}\)</span>，其中 <span class="math inline">\(\large{C}\)</span> 是实常数， <span class="math inline">\(\large {k}\)</span>是整数。</li></ol><p>应用于计算指数函数 <span class="math inline">\(\large {\exp(x)}\)</span> 时，其中 <span class="math inline">\(\large {C =2}\)</span> 。</p><p>值得注意的是，对于给定的函数，两种参数归约方式都可能使用。例如，对于<span class="math inline">\(\large {\sin (x) }\)</span>，我们既可以使用三倍角公式 <span class="math inline">\(\large {\sin (3x)= 3 \sin (x) - 4 \sin^3 (x)}\)</span> 化简，也可以使用加法归约 <span class="math inline">\(\large {\sin (x + 2 k \pi) = \sin (x)}\)</span>。</p><h1 id="数值分析-numerical-analysis">数值分析 Numerical Analysis</h1><p>通过上面的分析，现在让我们去计算任意输入 <span class="math inline">\(\large {x}\)</span> 的 <span class="math inline">\(\large { \sin (x)}\)</span> 、 <span class="math inline">\(\large {\cos (x)}\)</span> 的值，可以分为下面<span class="math inline">\(\large {2}\)</span> 种情况：</p><ol type="1"><li><span class="math inline">\(\large {0 &lt; x \leq \frac{\pi}{2}}\)</span> ，使用泰勒展开或者 CORDIC 算法；</li><li><span class="math inline">\(\large {x &gt; \frac {\pi}{2}}\)</span>，先将 <span class="math inline">\(\large {x}\)</span> 归约到 <span class="math inline">\(\large {x' = x + k \frac {\pi}{2}}\)</span>，再回到第一步计算。</li></ol><p>听起来似乎很简单，但事实上远远没有这么容易！</p><p>我们的电脑是基于 <strong>二进制(Binary)</strong> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>的，本质只是高电平和低电平在电路上切换运行而已。因为 CPU 种的逻辑运算单元(Arithmetic logic unit) <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>只能做加法和移位操作，因此而诞生了 计算机算术(Computer Arithmetic) <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> 这门学科！</p><p>数学中有一门学科 数值分析(Numerical Analysis) <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>就是专门研究各种计算的！</p><p>虽然三角函数的周棋是 <span class="math inline">\(\large {2\pi}\)</span> ，但实际上我们只用归约到 <span class="math inline">\(\large {[-\frac {\pi}{4},\frac {\pi}{4}]}\)</span>即可，这里大家可以想想为什么？</p><p>之前我以为数值运算对于 <span class="math inline">\(\large {[-\frac{\pi}{2},\frac {\pi}{2}]}\)</span> 的参数，会使用 CORDIC算法，但实际上我看了一些数值计算库，发现对于 <span class="math inline">\(\large {[-\frac {\pi}{2},\frac {\pi}{2}]}\)</span>还是使用泰勒(Taylor Series) <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>逼近，当然里面用了很多技巧，大家可以看看库函数的具体实现即可解惑（这里先挖个坑，等我彻底看懂了再来这里填坑！）。</p><p>那对于 <span class="math inline">\(\large {x &gt; \frac{\pi}{2}}\)</span> ，如何计算呢？</p><h1 id="cody-waite-归约算法">Cody-Waite 归约算法</h1><p>我们可以使用下列公式将 <span class="math inline">\(\large{x}\)</span> 归约到 <span class="math inline">\(\large {[-\frac{\pi}{4},\frac {\pi}{4}]}\)</span> ：</p><p><span class="math display">\[x' = x - \lfloor  \frac {x}{\frac {\pi}{2}} \rfloor \times \frac{\pi}{2}\]</span></p><p>我们可以很容易按照上述思想写出对应的代码，这就是 Cody &amp; Waite提出的 Cody-Waite 归约算法<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> 。</p><p>但是如果你认为这样就高枕无忧了的话，就太早了！</p><p>假如输入 <span class="math inline">\(\large {x = 1000001}\)</span>的话，上面的方法就会失效！想一想为什么？</p><h1 id="payne-hanek-归约算法">Payne-Hanek 归约算法</h1><p>上一章提出了一个问题，有效数字 超过 <span class="math inline">\(\large {15}\)</span>位的超大数字该如何计算呢？针对这个问题， Payne 与 Hanek <a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>提出把浮点运算转换为大整数运算，来解决超大数字的浮点数归约问题。</p><p>要弄懂 Payne-Hanek归约算法，需要对数学有比较深的理解，下面一步一步来分析！</p><p>对于输入 <span class="math inline">\(\large {x}\)</span> ：</p><p><span class="math display">\[x = k \cdot (\frac {\pi}{2}) + r \quad k \subset \mathbb{Z}, r \subset[-\frac {\pi}{4},\frac {\pi}{4}]\]</span></p><p>两边同乘 <span class="math inline">\(\large {\frac{2}{\pi }}\)</span>，可得：</p><p><span class="math display">\[x \cdot ( \frac{2}{\pi }) = k + r \cdot (\frac{2}{\pi })\]</span></p><p>因为 <span class="math inline">\(\left| r \right | \leq \frac{\pi}{4}\)</span> ， <span class="math inline">\(r \cdot (\frac {2}{\pi}) \leq 0.5\)</span> ，也就是说：</p><p><span class="math display">\[y = x \cdot (\frac {2}{\pi })\]</span></p><p>即：</p><p><span class="math display">\[k = \left \lfloor y \right \rfloor\]</span></p><p>那么所求浮点数的尾数部分：</p><p><span class="math display">\[f = y − k\]</span></p><p>最终可得到归约之后的结果 <span class="math inline">\(\large{r}\)</span> ：</p><p><span class="math display">\[r = f \cdot (\frac {\pi }{2})\]</span></p><p>回到我们的目标，我们需要知道 <span class="math inline">\(\large{k}\)</span> 的值 和 <span class="math inline">\(\large {r}\)</span>的值！</p><p>那我们能直接用上述公式计算吗？</p><p>我们知道 <span class="math inline">\(\large {\pi}\)</span>是超越数，是无法用二进制表示的，在计算机里只能去近似。我们最终要求得的三角函数的误差取决于下面几个方面：</p><ol type="1"><li>使用多少位数的 <span class="math inline">\(\large {\pi}\)</span>近似值；</li><li>参数归约时产生的误差；</li><li>计算参数归约之后的三角函数时的误差。</li></ol><p>对于输入参数 <span class="math inline">\(\large {x}\)</span>不是很大的情况，误差主要由参数归约时产生的误差决定，而当输入参数 <span class="math inline">\(\large {x}\)</span>很大的情况，参数归约产生的误差就不再是主要因素了！</p><h2 id="计算-large-k">计算 <span class="math inline">\(\large{k}\)</span></h2><p>由之前的推导，我们知道：</p><p><span class="math display">\[k = \left \lfloor y \right \rfloor = x \cdot (\frac {2}{\pi })\]</span></p><p>但是由于浮点数的精度限制，我们知道对于 <span class="math inline">\(\large {x}\)</span>很大情况，我们不能直接去计算！</p><p>由三角函数关系可知，我们实际上只需要计算 <span class="math inline">\(\large {k \% 4}\)</span>的值即可，也就是说只需要知道 <span class="math inline">\(\large{k}\)</span> 的最后 <span class="math inline">\(\large {2}\)</span> 个二进制位值即可，这样就可以节省大量运算了！</p><p>让我们回到 浮点数标准 <a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> ，以 <span class="math inline">\(\large {32}\)</span>位单精度浮点数为例，其值可以表示为：</p><p><span class="math display">\[x = (-1)^{b_{31}} \times 2^{(b_{30}b_{29}\dots b_{23})_{2} - 127} \times(1.b_{22}b_{21}\dots b_{0})_{2}\]</span></p><p>即为：</p><p><span class="math display">\[\text {value} = (-1)^{\text {sign}} \times 2^{(E - 127)} \times \left (1+ \sum _{i=1}^{23}b_{23-i} 2^{-i} \right)\]</span></p><p>(原始论文和数值分析具体实现代码太难看懂了，这篇文章写了快 1个月了！:-( )</p><h1 id="小结">小结</h1><p>这是目前我对<strong>参数归约(Argument Reduction)</strong>算法的理解，后续有新的发现、感悟都会更新此文章。</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="http://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/">CORDIC算法：一种高效计算三角函数值的方法</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="http://www.longluo.me/blog/2023/04/26/Taylor-Series/">泰勒展开式(Taylorseries)</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">Exponentiationby squaring</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Binary_number">Binary number</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">Arithmeticlogic unit</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://zh.wikipedia.org/wiki/Category:%E8%A8%88%E7%AE%97%E6%A9%9F%E7%AE%97%E8%A1%93">计算机算术</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p><a href="https://en.wikipedia.org/wiki/Numerical_analysis">NumericalAnalysis</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p><a href="http://www.longluo.me/blog/2023/04/26/Taylor-Series/">泰勒展开式(Taylorseries)</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn9"><p>W. Cody and W. Waite, Software Manual for the ElementaryFunctions, Prentice-Hall, Englewood Cliffs, N.J., 1980.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn10"><p><a href="https://dl.acm.org/doi/pdf/10.1145/1057600.1057602">M. Payne andR. Hanek, “Radian Reduction for Trigonometric Functions”, Signum,p19-24, Jan 1983.</a><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn11"><p><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE754</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前写过一篇介绍 CORDIC 算法 &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 的文章，里面提到 CORDIC
算法的 &lt;a href=&quot;http://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/#cordic-%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%8D%E8%B6%B3&quot;&gt;&lt;strong&gt;不足&lt;/strong&gt;&lt;/a&gt;
之处，CORDIC 算法的输入角度范围需要在 &lt;span class=&quot;math inline&quot;&gt;&#92;([−99.88^{&#92;circ} , 99.88^{&#92;circ}]&#92;)&lt;/span&gt;
，那么我们不禁要问，如果输入角度 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large
{&#92;theta }&#92;)&lt;/span&gt; 很大的话，怎么处理呢？&lt;/p&gt;
&lt;p&gt;这个问题同样存在于 泰勒展开式(Taylor series) &lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;
中，比如 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {&#92;sin (x) }&#92;)&lt;/span&gt; 和
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {&#92;cos (x) }&#92;)&lt;/span&gt;
的泰勒展开式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sin(x) = x - &#92;frac {1}{3!}x^3 + &#92;frac {1}{5!}x^5 - &#92;frac {1}{7!} x^7 +
&#92;frac {1}{9!} x^9 + o(x^9) &#92;quad &#92;forall x &#92;subset &#92;mathbb{R}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;cos(x) = 1 - &#92;frac {1}{2!}x^2 + &#92;frac {1}{4!}x^4 - &#92;frac {1}{6!} x^6 +
&#92;frac {1}{8!} x^8 + o(x^8) &#92;quad &#92;forall x &#92;subset &#92;mathbb{R}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然在整个实数集 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {
&#92;mathbb{R}}&#92;)&lt;/span&gt;
都成立，但是在实际应用中因为展开项数限制和浮点数的精度限制， &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {x}&#92;)&lt;/span&gt; 的范围只有在接近 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {0}&#92;)&lt;/span&gt; 的时候才有比较高的精度。&lt;/p&gt;
&lt;p&gt;但是实际应用中，如果输入 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large
{x}&#92;)&lt;/span&gt; 很大的话，比如 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {2^{32},
10^{10}, 10^{22} &#92;dots }&#92;)&lt;/span&gt; 情况下怎么得到足够精确的值呢？&lt;/p&gt;
&lt;p&gt;中学里我们知道三角函数是&lt;strong&gt;周期函数&lt;/strong&gt;，对于比较大的值，我们可以使用下面的公式将值&lt;strong&gt;归约&lt;/strong&gt;到一个比较小的范围内。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
x&#39; = x - 2k &#92;pi &#92;quad k &#92;subset &#92;mathbb{Z}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这就是我们今天要讲的 &lt;strong&gt;参数归约(Argument Reduction)&lt;/strong&gt;
算法。&lt;/p&gt;
&lt;h1 id=&quot;从小学计算题开始&quot;&gt;从小学计算题开始&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;参数归约&lt;/strong&gt;
听起来就很唬人，什么是参数啊，什么归约啊，都是些高大上的名词，听起来云里雾里的！&lt;/p&gt;
&lt;p&gt;为了不让大家产生厌倦和畏难心理，我们先从一道小学数学计算题开始：&lt;/p&gt;
&lt;p&gt;不借助计算器，计算 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {66600 &#92;times
666000}&#92;)&lt;/span&gt; 的值！&lt;/p&gt;
&lt;p&gt;对于这道题，大家可能会列出下列算术：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
66600 &#92;times 666000 = 666 &#92;times 666 &#92;times 100000 = 44355600000
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但其实呢，我们也可以使用下面的方法：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
66600 &#92;times 666000 &amp;amp;= 111^2 &#92;times 4 &#92;times 9 &#92;times 10^5
&#92;&#92;&amp;amp;= 444 &#92;times 999 &#92;times 10^5
&#92;&#92;&amp;amp;= 444 &#92;times (1000 - 1) &#92;times 10^5
&#92;&#92;&amp;amp;= 4443556 &#92;times 10^5    
&#92;end{aligned}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果我说上面这 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;large {2}&#92;)&lt;/span&gt;
种方法都用到了&lt;strong&gt;参数归约&lt;/strong&gt;的思想，你可能会感到震惊，什么？这种小学计算题也用到了参数归约算法吗？&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Arithmetic" scheme="https://www.longluo.me/tags/Arithmetic/"/>
    
    <category term="Argument Reduction" scheme="https://www.longluo.me/tags/Argument-Reduction/"/>
    
    <category term="Computer Arithmetic" scheme="https://www.longluo.me/tags/Computer-Arithmetic/"/>
    
    <category term="参数归约" scheme="https://www.longluo.me/tags/%E5%8F%82%E6%95%B0%E5%BD%92%E7%BA%A6/"/>
    
    <category term="Floating-point" scheme="https://www.longluo.me/tags/Floating-point/"/>
    
    <category term="浮点数" scheme="https://www.longluo.me/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
    <category term="Trigonometric" scheme="https://www.longluo.me/tags/Trigonometric/"/>
    
  </entry>
  
  <entry>
    <title>频率之美：探索振动的神奇语言</title>
    <link href="https://www.longluo.me/blog/2023/08/21/oscillation/"/>
    <id>https://www.longluo.me/blog/2023/08/21/oscillation/</id>
    <published>2023-08-21T13:17:43.000Z</published>
    <updated>2024-03-14T14:29:37.330Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><p><span class="math display">\[m \frac {d^2x}{dt^2} = -kx\]</span></p><p><span class="math display">\[m \frac{d^2x}{dt^2} = -k \cdot x = k \cdot A \sin \left( \omega t -\Delta \varphi \right)\]</span></p><p><span class="math display">\[m \frac{d^2x}{dt^2} + m r \frac{dx}{dt} + kx = F(t)\]</span></p><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Oscillation">Oscillation</a></li><li><a href="https://en.wikipedia.org/wiki/Simple_harmonic_motion">Simpleharmonic motion</a></li><li><a href="https://en.wikipedia.org/wiki/Electronic_oscillator">Electronicoscillator</a></li><li><a href="https://en.wikipedia.org/wiki/Pendulum">Pendulum</a></li><li><a href="https://en.wikipedia.org/wiki/Galileo_Galilei">GalileoGalilei</a></li><li><a href="https://en.wikipedia.org/wiki/Damping">Damping</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
m &#92;frac {d^2x}{dt^2} = -kx
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Physics" scheme="https://www.longluo.me/categories/Physics/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Physics" scheme="https://www.longluo.me/tags/Physics/"/>
    
  </entry>
  
  <entry>
    <title>素描背后的数学</title>
    <link href="https://www.longluo.me/blog/2023/08/02/perspective/"/>
    <id>https://www.longluo.me/blog/2023/08/02/perspective/</id>
    <published>2023-08-02T11:15:11.000Z</published>
    <updated>2024-03-11T13:16:44.086Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Sketch_(drawing)">Sketch(drawing)</a></li><li><a href="https://en.wikipedia.org/wiki/Projective_geometry">Projectivegeometry</a></li><li><a href="https://zh.wikipedia.org/zh-cn/%E9%98%BF%E5%B0%94%E5%B8%83%E9%9B%B7%E5%B8%8C%E7%89%B9%C2%B7%E4%B8%A2%E5%8B%92">阿尔布雷希特·丢勒</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%98%82%C2%B7%E5%B7%B4%E8%92%82%E6%96%AF%E5%A1%94%C2%B7%E9%98%BF%E5%B0%94%E4%BC%AF%E8%92%82">莱昂·巴蒂斯塔·阿尔伯蒂</a></li><li><a href="https://book.douban.com/subject/25662171/">论绘画</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Art" scheme="https://www.longluo.me/tags/Art/"/>
    
    <category term="Sketch" scheme="https://www.longluo.me/tags/Sketch/"/>
    
  </entry>
  
  <entry>
    <title>熵是什么? Entropy</title>
    <link href="https://www.longluo.me/blog/2023/07/06/entropy/"/>
    <id>https://www.longluo.me/blog/2023/07/06/entropy/</id>
    <published>2023-07-06T13:35:26.000Z</published>
    <updated>2024-03-14T14:29:16.567Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="挖坑">挖坑！</h1><h1 id="参考文献">参考文献</h1><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Entropy">Entropy</a></li><li><a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">Entropy(information theory)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;挖坑&quot;&gt;挖坑！&lt;/h1&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.or</summary>
      
    
    
    
    <category term="Physics" scheme="https://www.longluo.me/categories/Physics/"/>
    
    
    <category term="Entropy" scheme="https://www.longluo.me/tags/Entropy/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降法(Gradient Descent)：优化世界中的魔法箭头</title>
    <link href="https://www.longluo.me/blog/2023/06/20/gradient-descent/"/>
    <id>https://www.longluo.me/blog/2023/06/20/gradient-descent/</id>
    <published>2023-06-20T00:36:02.000Z</published>
    <updated>2023-11-14T14:24:40.449Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="待继续完善">待继续完善</h1><p>引言：</p><p>在机器学习和优化算法的领域中，梯度下降法被广泛应用于解决各种问题，从训练神经网络到参数优化。这种强大的优化算法通过不断迭代更新参数，以最小化目标函数或最大化收益函数。本文将介绍梯度下降法的数学原理，探讨其在实际应用中的广泛应用以及其优点和不足之处。</p><h1 id="数学原理">数学原理：</h1><p>梯度下降法的核心思想是通过计算目标函数的梯度，并沿着梯度的反方向迭代地更新参数，以逐步逼近最优解。具体而言，梯度下降法包括以下步骤：</p><p><span class="math display">\[h_{\theta} (x) = \theta_0 + \theta_1 x + \theta_2 x^2 + \dots + \theta_nx^n\]</span></p><p><span class="math display">\[J(\theta) = \frac{1}{2m} \sum_{i = 1}^{m} (h_{\theta} (x_i) - y_i)^2\]</span></p><p><span class="math display">\[\theta_j = \theta_j - \frac{\alpha}{m} \sum_{i = 1}^{m} (h_{\theta}(x_i) - y_i) \cdot x_j\]</span></p><p>随机初始化参数向量。 计算目标函数在当前参数向量处的梯度。沿着梯度的反方向更新参数向量。</p><p>重复以上步骤，直到满足停止条件（如达到最大迭代次数或参数变化不显著）。</p><span id="more"></span><h1 id="应用实例">应用实例：</h1><p>梯度下降法在各个领域都有广泛的应用，以下是一些常见的应用实例：</p><ul><li>机器学习：梯度下降法是训练神经网络和其他机器学习模型的基本算法，用于调整模型参数以最小化损失函数。</li><li>线性回归：通过最小化损失函数，梯度下降法可以找到最佳的回归系数，从而拟合线性模型。</li><li>特征选择：梯度下降法可以用于选择最相关的特征，以提高模型的预测性能。</li><li>无监督学习：在聚类和降维等无监督学习任务中，梯度下降法可以最大化或最小化相应的目标函数，实现数据的有效表示和结构发现。</li></ul><h1 id="优点与不足">优点与不足</h1><p>梯度下降法具有以下优点：</p><ul><li>强大的全局优化能力：梯度下降法可以在复杂的参数空间中搜索全局最优解。</li><li>广泛适用性：它可以用于不同类型的问题，从线性模型到深度神经网络。</li><li>可扩展性：梯度下降法可以应用于大规模数据集和高维参数空间。</li></ul><p>然而，梯度下降法也存在一些不足之处：</p><ul><li>学习率选择：合适的学习率对梯度下降法的性能至关重要，过小或过大的学习率都可能导致收敛问题。</li><li>局部最优解：在非凸优化问题中，梯度下降法可能会陷入局部最优解，而无法达到全局最优解。</li><li>高计算成本：对于大规模数据集和复杂模型，计算梯度和更新参数的成本较高。</li></ul><h1 id="总结">总结</h1><p>梯度下降法是优化算法中的魔法箭头，它通过迭代更新参数的方式，在机器学习和优化领域取得了巨大成功。虽然存在一些挑战和局限性，但梯度下降法仍然是解决各种实际问题的重要工具，为我们优化世界的探索提供了强大的支持。</p><h1 id="参考文献">参考文献</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;待继续完善&quot;&gt;待继续完善&lt;/h1&gt;
&lt;p&gt;引言：&lt;/p&gt;
&lt;p&gt;在机器学习和优化算法的领域中，梯度下降法被广泛应用于解决各种问题，从训练神经网络到参数优化。这种强大的优化算法通过不断迭代更新参数，以最小化目标函数或最大化收益函数。本文将介绍梯度下降法的数学原理，探讨其在实际应用中的广泛应用以及其优点和不足之处。&lt;/p&gt;
&lt;h1 id=&quot;数学原理&quot;&gt;数学原理：&lt;/h1&gt;
&lt;p&gt;梯度下降法的核心思想是通过计算目标函数的梯度，并沿着梯度的反方向迭代地更新参数，以逐步逼近最优解。具体而言，梯度下降法包括以下步骤：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
h_{&#92;theta} (x) = &#92;theta_0 + &#92;theta_1 x + &#92;theta_2 x^2 + &#92;dots + &#92;theta_n
x^n
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
J(&#92;theta) = &#92;frac{1}{2m} &#92;sum_{i = 1}^{m} (h_{&#92;theta} (x_i) - y_i)^2
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;theta_j = &#92;theta_j - &#92;frac{&#92;alpha}{m} &#92;sum_{i = 1}^{m} (h_{&#92;theta}
(x_i) - y_i) &#92;cdot x_j
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;随机初始化参数向量。 计算目标函数在当前参数向量处的梯度。
沿着梯度的反方向更新参数向量。&lt;/p&gt;
&lt;p&gt;重复以上步骤，直到满足停止条件（如达到最大迭代次数或参数变化不显著）。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="AI" scheme="https://www.longluo.me/tags/AI/"/>
    
    <category term="Gradient Descent" scheme="https://www.longluo.me/tags/Gradient-Descent/"/>
    
  </entry>
  
  <entry>
    <title>发生在计算机内存里的进化：解密遗传算法(Genetic Algorithm)</title>
    <link href="https://www.longluo.me/blog/2023/06/12/genetic-algorithm/"/>
    <id>https://www.longluo.me/blog/2023/06/12/genetic-algorithm/</id>
    <published>2023-06-12T00:32:31.000Z</published>
    <updated>2023-11-14T14:24:40.448Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><h1 id="这篇文章部分内容还在优化demo-还在继续开发大概还需要-7---8-小时写作时间">这篇文章部分内容还在优化，Demo还在继续开发，大概还需要 7 - 8 小时写作时间。</h1><p>无限猴子定理（英语：Infinite monkey theorem）</p><p>让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。</p><p>在这里，几乎必然是一个有特定含义的数学术语，“猴子”也不是一只真正意义上的猴子，它被用来比喻成一个可以产生无限随机字母序列的抽象设备。这个理论说明把一个很大但有限的数看成无限的推论是错误的。猴子精确地通过键盘敲打出一部完整的作品比如说莎士比亚的哈姆雷特，在宇宙的生命周期中发生的概率也是极其低的，但并不是零。</p><p>遗传算法(Genetic Algorithm) <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>是一种元启发式搜索和优化技术，借鉴了生物进化中的自然选择和遗传机制。它已经在各个领域展示出了强大的应用潜力。本文将介绍遗传算法的发展历史、原理、示例，以及其广泛应用和不足之处。</p><h1 id="发展历史">发展历史</h1><p>遗传算法的发展可以追溯到上世纪60年代的约翰·荷兰德（JohnHolland）和他的同事们的工作。他们首先提出了基因型与表现型之间的映射关系，并通过模拟生物进化过程来解决复杂的优化问题。</p><h1 id="原理">原理</h1><p>遗传算法的核心原理是模拟自然进化的过程。它通过定义适应度函数来评估候选解的质量，并利用遗传操作（选择、交叉和变异）对候选解进行迭代改进。具体而言，算法从一个初始种群开始，通过选择适应度较高的个体作为父代，进行交叉和变异操作产生新的后代个体，然后通过评估适应度来选择出下一代个体。这个过程不断迭代，直到找到满足特定条件的优秀解。</p><p>It’s never too late</p><h1 id="举个例子">举个例子</h1><p>目前参考网络资源写了一个简单的Demo，地址：http://longluo.me/projects/genetic</p><p>这个例子还有待完善！</p><p><a href="http://longluo.me/projects/genetic"><img src="https://user-images.githubusercontent.com/3395062/247012809-febec500-50dd-4d52-a6f6-d5b86aba4132.png" alt="Genetic Algorithm"></a></p><span id="more"></span><h1 id="应用领域">应用领域</h1><p>遗传算法在各个领域都有广泛的应用。它被用于优化问题、机器学习、数据挖掘、调度问题等。例如，在工程设计中，可以使用遗传算法来优化设计参数，以获得更好的性能。在人工智能领域，遗传算法被用于训练神经网络的参数。</p><h1 id="todos">ToDos</h1><ul><li>利用遗传算法优化 <a href="http://www.longluo.me/blog/2023/05/05/pid/">PID</a> ，自动调谐 PID参数，目前开发中…</li><li>利用遗传算法应用于 <a href="http://www.longluo.me/blog/2023/03/03/Neutral-Network/">机器学习</a>，目前还在开发中…</li></ul><h1 id="缺点">缺点</h1><p>遗传算法在应用中存在一些缺点，但可以采取一些方法来规避这些问题。以下是一些常见的遗传算法缺点及其应对措施的例子：</p><p>可能陷入局部最优解：由于遗传算法的随机性质，可能导致算法收敛到局部最优解而无法达到全局最优解。为了规避这个问题，可以采用以下方法：</p><p>多次运行算法：运行遗传算法的多个独立实例，以增加搜索空间的探索性。引入多样性维护机制：通过保留一部分较差个体、增加变异操作的概率或引入新的个体，以增加种群的多样性，避免过早陷入局部最优解。计算复杂度高：遗传算法需要进行大量的计算和评估操作，导致计算复杂度较高。为了降低计算成本，可以尝试以下方法：</p><p>优化评估函数：通过对评估函数进行优化，减少计算成本。使用近似算法：在某些情况下，可以使用近似算法或启发式方法来加速计算过程，以减少计算复杂度。参数选择困难：遗传算法中的参数选择对算法的性能和效果至关重要。不正确的参数选择可能导致算法效果不佳。为了解决这个问题，可以采取以下措施：</p><p>参数调优：通过实验和测试，调整算法的参数，以找到最佳的参数组合。自适应参数调整：引入自适应机制，根据问题的特性和算法的表现，动态调整参数值。举例来说，假设有一个优化问题，需要找到一个函数的最小值。遗传算法被用来解决这个问题，但在初步运行中发现算法很容易陷入局部最优解。为了规避这个问题，可以采取多次运行算法的方法，每次使用不同的初始种群和随机数种子，以增加搜索空间的覆盖度，从而更有可能找到全局最优解。</p><p>另外，遗传算法在每一代选择操作时都会考虑适应度函数的评估，这可能导致计算复杂度的增加。为了降低计算成本，可以对适应度函数进行优化，使用更高效的算法或数据结构进行计算。同时，可以利用并行计算或分布式计算的方法，提高算法的计算效率。</p><p>总之，通过合理的方法和技巧，可以规避遗传算法的一些缺点，并提高算法的效率和性能。根据具体的问题和应用场景，选择适当的策略和方法来克服遗传算法的局限性。</p><h1 id="总结">总结</h1><p>综上所述，遗传算法作为一种强大的优化技术，在解决复杂问题和优化搜索中具有广泛的应用。通过模拟生物进化的机制，它能够发现优秀的解决方案。然而，它也面临局部最优解和计算复杂度高的挑战。随着计算能力和算法改进的不断提升，遗传算法在未来将继续发挥重要作用，并为各个领域的问题提供创新解决方案。</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/George_Gamow">George Gamow</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;这篇文章部分内容还在优化demo-还在继续开发大概还需要-7---8-小时写作时间&quot;&gt;这篇文章部分内容还在优化，Demo
还在继续开发，大概还需要 7 - 8 小时写作时间。&lt;/h1&gt;
&lt;p&gt;无限猴子定理（英语：Infinite monkey theorem）&lt;/p&gt;
&lt;p&gt;让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。&lt;/p&gt;
&lt;p&gt;在这里，几乎必然是一个有特定含义的数学术语，“猴子”也不是一只真正意义上的猴子，它被用来比喻成一个可以产生无限随机字母序列的抽象设备。这个理论说明把一个很大但有限的数看成无限的推论是错误的。猴子精确地通过键盘敲打出一部完整的作品比如说莎士比亚的哈姆雷特，在宇宙的生命周期中发生的概率也是极其低的，但并不是零。&lt;/p&gt;
&lt;p&gt;遗传算法(Genetic Algorithm) &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;
是一种元启发式搜索和优化技术，借鉴了生物进化中的自然选择和遗传机制。它已经在各个领域展示出了强大的应用潜力。本文将介绍遗传算法的发展历史、原理、示例，以及其广泛应用和不足之处。&lt;/p&gt;
&lt;h1 id=&quot;发展历史&quot;&gt;发展历史&lt;/h1&gt;
&lt;p&gt;遗传算法的发展可以追溯到上世纪60年代的约翰·荷兰德（John
Holland）和他的同事们的工作。他们首先提出了基因型与表现型之间的映射关系，并通过模拟生物进化过程来解决复杂的优化问题。&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;&gt;原理&lt;/h1&gt;
&lt;p&gt;遗传算法的核心原理是模拟自然进化的过程。它通过定义适应度函数来评估候选解的质量，并利用遗传操作（选择、交叉和变异）对候选解进行迭代改进。具体而言，算法从一个初始种群开始，通过选择适应度较高的个体作为父代，进行交叉和变异操作产生新的后代个体，然后通过评估适应度来选择出下一代个体。这个过程不断迭代，直到找到满足特定条件的优秀解。&lt;/p&gt;
&lt;p&gt;It’s never too late&lt;/p&gt;
&lt;h1 id=&quot;举个例子&quot;&gt;举个例子&lt;/h1&gt;
&lt;p&gt;目前参考网络资源写了一个简单的Demo，地址：http://longluo.me/projects/genetic&lt;/p&gt;
&lt;p&gt;这个例子还有待完善！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://longluo.me/projects/genetic&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3395062/247012809-febec500-50dd-4d52-a6f6-d5b86aba4132.png&quot; alt=&quot;Genetic Algorithm&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="Genetic Algorithm" scheme="https://www.longluo.me/tags/Genetic-Algorithm/"/>
    
    <category term="AI" scheme="https://www.longluo.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>CORDIC算法：一种高效计算三角函数值的方法</title>
    <link href="https://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/"/>
    <id>https://www.longluo.me/blog/2023/06/07/CORDIC-algorithm/</id>
    <published>2023-06-07T09:11:28.000Z</published>
    <updated>2024-02-25T14:03:27.882Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>By Long Luo</em></strong></p><p>任何一款科学计算器上都可以计算三角函数，三角函数应用于生活工作中的方方面面，但计算机是如何计算三角函数值的呢？</p><p>三角函数本质上是直角三角形的3条边的<strong>比例关系</strong>，计算并没有很直观，那么计算机是如何计算三角函数值的呢？</p><p>在微积分中我们学习过 <a href="http://www.longluo.me/blog/2023/04/26/taylor-series/">泰勒公式</a>，我们知道可以使用泰勒展开式来对某个值求得其近似值，例如：</p><p><span class="math display">\[\sin \angle 18^{\circ} = \frac{\sqrt {5} - 1}{4} \approx 0.3090169943\]</span></p><p>利用泰勒公式，取前 <span class="math inline">\(4\)</span> 项：</p><p><span class="math display">\[\sin x \approx x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!}\]</span></p><p>代入可得：</p><p><span class="math display">\[\sin \angle 18^{\circ} = \sin \frac{\pi}{10} = \frac{\pi}{10} -\frac{1}{6} (\frac{\pi}{10})^3 + \frac{1}{120} (\frac{\pi}{10})^5 -\frac{1}{5040} (\frac{\pi}{10})^7 \approx 0.30903399538\]</span></p><p>可见取前 <span class="math inline">\(4\)</span> 项时精度已经在 <span class="math inline">\(10^{-5}\)</span>之下，对于很多场合精度已经<strong>足够高</strong>了。</p><p>在没有了解 CORDIC(Coordinate Rotation Digital Computer) Algorithm <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>算法之前，我一直以为计算器是利用泰勒公式去求解，最近才了解到原来在计算机中，CORDIC算法<strong>远比</strong>泰勒公式高效。</p><p>下面我们就来了解下泰勒公式的不足之处和 CORDIC 算法是怎么做的。</p><h1 id="泰勒公式的缺点">泰勒公式的缺点</h1><p>上一节我们使用泰勒公式去计算三角函数值时，需要做很多次乘法运算，而计算器中乘法运算是很<strong>昂贵</strong>的，其缺点如下所示：</p><ol type="1"><li>展开过小则会导致展开精度不够，展开过大则会导致计算量过大；</li><li>幂运算需要使用乘法器，存在很多重复计算；</li><li>需要很多变量来存储中间值。</li></ol><p>在之前的文章 <a href="http://www.longluo.me/blog/2019/06/21/strassens-matrix-multiplication-algorithm/">矩阵乘法的Strassen 算法</a>，就是通过<strong>减少乘法，多做加法</strong>，从而大大降低了运算量，那么我们可以用相同的思想来优化运算吗？</p><p>当然可以，让我们请出今天的主角：<strong>CORDIC 算法</strong>。</p><span id="more"></span><h1 id="解析-cordic-算法">解析 CORDIC 算法</h1><p>我们知道单位圆上一点 <span class="math inline">\(P\)</span>，其坐标为：<span class="math inline">\((\cos \theta , \sin \theta)\)</span> ，如下图所示：</p><figure><img src="https://user-images.githubusercontent.com/3395062/245137553-974a4579-cf2f-4fc1-84bd-84600da2fad9.svg" alt="Unit Cycle"><figcaption aria-hidden="true">Unit Cycle</figcaption></figure><p>如果我们接收一个旋转向量 <span class="math inline">\(M_{in}\)</span>逆时针旋转 <span class="math inline">\(\theta\)</span> ，将点 <span class="math inline">\(P(x_{in} , y_{in})\)</span> 旋转到 <span class="math inline">\(P'(x_{R} , y_{R})\)</span> , 如下图所示：</p><figure><img src="https://user-images.githubusercontent.com/3395062/245138071-9b15482b-034a-4517-90c7-db8e302865cf.png" alt="CORDIC"><figcaption aria-hidden="true">CORDIC</figcaption></figure><p>很容易得到如下公式：</p><p><span class="math display">\[x_R = x_{in} cos(\theta) - y_{in} sin(\theta)\]</span></p><p><span class="math display">\[y_R = x_{in} sin(\theta) + y_{in} cos(\theta)\]</span></p><p>实际上由 <a href="http://www.longluo.me/blog/2021/12/29/Fourier-transform/">复数运算</a>，我们知道复数乘法就是<strong>幅角相加，模长相乘</strong>。我们可以将上式写成下列<strong>矩阵运算</strong>形式：</p><p><span class="math display">\[\begin{aligned}\begin{bmatrix} x_{R} \\ y_{R} \end{bmatrix} = \begin{bmatrix} \cos(\theta)  &amp; -\sin (\theta) \\ \sin (\theta) &amp; \cos (\theta )\end{bmatrix} \begin{bmatrix} x_{in} \\ y_{in} \end{bmatrix}\end{aligned}\]</span></p><p>但上式运算时，只是对向量 <span class="math inline">\(v_{in} ={\begin{bmatrix} x_{in} \\ y_{in} \end{bmatrix}}\)</span>进行了<strong>线性变换</strong>，乘以一个旋转向量 <span class="math inline">\(M_{in}\)</span> ，得到了旋转后的结果：向量 <span class="math inline">\(v_{R} = {\begin{bmatrix} x_{R} \\ y_{R}\end{bmatrix}}\)</span> 。</p><p>但是上式仍然需要 <span class="math inline">\(4\)</span> 次乘法和<span class="math inline">\(2\)</span> 次加减法操作，复杂度没有任何降低，那怎么办呢？</p><p><strong><em>当当…当！</em></strong></p><p>通过上述分析，我们已经知道可以使用<strong>有限次旋转</strong>操作来避免复杂的乘法操作，我们修改矩阵运算公式，提取<span class="math inline">\(\cos (\theta )\)</span>，则公式可以修改为：</p><p><span class="math display">\[\begin{bmatrix} x_{R} \\ y_{R} \end{bmatrix} = cos(\theta)\begin{bmatrix} 1 &amp; -tan(\theta) \\ tan(\theta) &amp; 1\end{bmatrix} \begin{bmatrix} x_{in} \\ y_{in} \end{bmatrix}\]</span></p><p>如果我们选择合适的角度值 <span class="math inline">\(\theta_i\)</span>，使得</p><p><span class="math display">\[\tan (\theta_{i}) = 2^{-i} \quad i=0, 1,\dots , n\]</span></p><p>这样和 <span class="math inline">\(\tan (\theta_{i})\)</span>乘法操作就变成了<strong>移位</strong>操作，我们知道计算机中<strong>移位</strong>操作是非常快的，就可以大大加快计算速度了。</p><p>但这里仍然有 <span class="math inline">\(3\)</span>个问题需要解决：</p><ol type="1"><li>对于任意角度，可以通过满足条件的角度累加来得到在数学上相同的结果吗？</li><li>每次旋转得到的结果仍然需要乘以 <span class="math inline">\(\cos(\theta )\)</span>，这部分的计算成本如何？如何计算？</li><li>因为每次旋转角度 <span class="math inline">\(\theta =\arctan(2^{-i})\)</span>，朝着目标角度进行旋转时，可能会出现没有超过目标角度的情况，也会存在超过目标角度的情况，这种情况如何解决呢？</li></ol><figure><img src="https://user-images.githubusercontent.com/3395062/245393710-1977d19d-3b0c-451b-8d40-838c64f979a4.png" alt="CORDIC Expand"><figcaption aria-hidden="true">CORDIC Expand</figcaption></figure><p>对于第一个问题，答案是<strong>否定</strong>的。可以从数学上证明只有<span class="math inline">\(\angle 45^{\circ}\)</span>的倍数角才可以得到完全一致的结果。但是在工程应用中，我们只需要满足<strong>一定精度</strong>即可，可以增加迭代次数无限逼近原始角度，如下所示提高<span class="math inline">\(n\)</span> 值以无限逼近原始角度。</p><p><span class="math display">\[\theta_{d} = \sum_{i=0}^{n} \theta_{i} \quad \forall \tan(\theta_{i}) =2^{-i}\]</span></p><p>对于第二个问题，我们先来个例子，以 <span class="math inline">\(57.535^{\circ}\)</span> 为例来看看求解过程：</p><p><span class="math display">\[57.535^{\circ} = 45^{\circ}+26.565^{\circ}-14.03^{\circ}\]</span></p><p>那么第一次旋转：</p><p><span class="math display">\[\begin{bmatrix} x_{0} \\ y_{0} \end{bmatrix} = cos(45^{\circ})\begin{bmatrix} 1 &amp; -1 \\ 1 &amp; 1 \end{bmatrix} \begin{bmatrix}x_{in} \\ y_{in} \end{bmatrix}\]</span></p><p>第二次旋转：</p><p><span class="math display">\[\begin{bmatrix} x_{1} \\ y_{1} \end{bmatrix} = cos(26.565^{\circ})\begin{bmatrix} 1 &amp; -2^{-1} \\ 2^{-1} &amp; 1 \end{bmatrix}\begin{bmatrix} x_{0} \\ y_{0} \end{bmatrix}\]</span></p><p>第三次旋转：</p><p><span class="math display">\[\begin{bmatrix} x_{2} \\ y_{2} \end{bmatrix} = cos(-14.03^{\circ})\begin{bmatrix} 1 &amp; 2^{-2} \\ -2^{-2} &amp; 1 \end{bmatrix}\begin{bmatrix} x_{1} \\ y_{1} \end{bmatrix}\]</span></p><p>综合可得：</p><p><span class="math display">\[\begin{bmatrix} x_{2} \\ y_{2} \end{bmatrix} = cos(45^{\circ})cos(26.565^{\circ}) cos(-14.03^{\circ}) \begin{bmatrix} 1 &amp; -1 \\ 1&amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; -2^{-1} \\ 2^{-1} &amp; 1\end{bmatrix} \begin{bmatrix} 1 &amp; 2^{-2} \\ -2^{-2} &amp; 1\end{bmatrix} \begin{bmatrix} x_{in} \\ y_{in} \end{bmatrix}\]</span></p><p>因为 <span class="math inline">\(\tan (\theta_{i}) = 2^{-i}\)</span>，由三角公式可以计算出：</p><p><span class="math display">\[\cos(\theta_{i}) = \frac {1}{\sqrt {1 + \tan ^{2}(\theta_{i})}} = \frac{1}{\sqrt {1 + 2^{-2i}}}\]</span></p><p>令 <span class="math inline">\(K_i = \cos(\theta_{i})\)</span>，则当进行 <span class="math inline">\(n\)</span> 次迭代之后：</p><p><span class="math display">\[K(n) = \prod _{i=0}^{n-1}K_{i} = \prod _{i=0}^{n-1}{\frac {1}{\sqrt {1 +2^{-2i}}}}\]</span></p><p>当 <span class="math inline">\(\theta_{i}\)</span> 越来越小时， <span class="math inline">\(\cos \theta\)</span> 也越来越逼近 <span class="math inline">\(1\)</span> ，当迭代次数 <span class="math inline">\(n \to \infty\)</span> ， <span class="math inline">\(K(n)\)</span> 极限存在，求解可得：</p><p><span class="math display">\[K = \lim _{n \to \infty }K(n) \approx 0.6072529350088812561694\]</span></p><p>由 <span class="math inline">\(K\)</span>我们实际上可以得到最终的向量 <span class="math inline">\(v_R\)</span>的模长极限为：</p><p><span class="math display">\[A = {\frac {1}{K}} = \lim _{n \to \infty } \prod _{i=0}^{n - 1}{\sqrt {1+ 2^{-2i}}} \approx 1.64676025812107\]</span></p><p>实际上当迭代次数为 <span class="math inline">\(6\)</span>时，可以计算出缩放比例 <span class="math inline">\(K\)</span>，就已经精确到 <span class="math inline">\(0.6072\)</span>了，如下所示：</p><p><span class="math display">\[K \approx cos(45^{\circ}) cos(26.565^{\circ}) \times \dots \timescos(0.895^{\circ}) = 0.6072\]</span></p><p>实际上，任意角度只要迭代次数超过 <span class="math inline">\(6\)</span> ，我们可以直接使用 <span class="math inline">\(K = 0.6072\)</span> 这个值。</p><p>对于第三个问题，稍微有点复杂，我们在下一节继续讲解！</p><h1 id="角度累加">角度累加</h1><p>上一节遗留的问题是迭代旋转角度时，旋转角度不一定会落在目标角度内，我们需要引入一个角度误差，用来衡量旋转角度和目标角之间距离，如下所示：</p><p><span class="math display">\[\theta_{error} = \theta_d - \sum_{i=0}^{n} \theta_{i}\]</span></p><p>当 <span class="math inline">\(\theta_{error} &gt; 0\)</span>时，我们应该逆时针旋转，而 <span class="math inline">\(\theta_{error}&lt; 0\)</span> ，则顺时针旋转。根据精度需要，当 <span class="math inline">\(\left | \theta_{error} \right | \le\epsilon\)</span> 即可退出迭代。</p><p>同时我们修改之前的公式，引入 <span class="math inline">\(\sigma_{i}\in \left \{ +1, -1 \right \}\)</span> ，于是可以得到最终公式：</p><p><span class="math display">\[x \left [ i+1 \right ] = x \left [ i \right ] - \sigma_{i} 2^{-i} y\left [ i \right ]\]</span></p><p><span class="math display">\[y \left [ i+1 \right ] = y \left [ i \right ] + \sigma_{i} 2^{-i} x\left [ i \right ]\]</span></p><p><span class="math display">\[z \left [ i+1 \right ] = z \left [ i \right ] - \sigma_{i} tan^{-1} (2^{-i} )\]</span></p><h1 id="举个例子">举个例子</h1><p>上面讲了这么多，来个实例吧，练习巩固下知识，看看自己是否真的懂了？</p><p>计算 <span class="math inline">\(\sin 70^{\circ}\)</span> 和 <span class="math inline">\(\cos 70^{\circ}\)</span> 的值。</p><p>从 <span class="math inline">\(x_{in}=1, y_{in} = 0\)</span>开始，迭代 <span class="math inline">\(6\)</span> 次结果如下：</p><table><colgroup><col style="width: 14%"><col style="width: 13%"><col style="width: 23%"><col style="width: 23%"><col style="width: 23%"></colgroup><thead><tr class="header"><th style="text-align: center;">第 <span class="math inline">\(i\)</span> 次迭代</th><th><span class="math inline">\(\sigma_{i}\)</span></th><th><span class="math inline">\(x \left[ i \right ]\)</span></th><th><span class="math inline">\(y \left[ i \right ]\)</span></th><th><span class="math inline">\(z \left[ i \right ]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">-</td><td>-</td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(70^{\circ}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(25^{\circ}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(0.5\)</span></td><td><span class="math inline">\(1.5\)</span></td><td><span class="math inline">\(-1.5651^{\circ}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td><span class="math inline">\(-1\)</span></td><td><span class="math inline">\(0.875\)</span></td><td><span class="math inline">\(1.375\)</span></td><td><span class="math inline">\(12.4711^{\circ}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(0.7031\)</span></td><td><span class="math inline">\(1.4844\)</span></td><td><span class="math inline">\(5.3461^{\circ}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(4\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(0.6103\)</span></td><td><span class="math inline">\(1.5283\)</span></td><td><span class="math inline">\(1.7698^{\circ}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(5\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(0.5625\)</span></td><td><span class="math inline">\(1.5474\)</span></td><td><span class="math inline">\(-0.0201^{\circ}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(6\)</span></td><td><span class="math inline">\(-1\)</span></td><td><span class="math inline">\(0.5867\)</span></td><td><span class="math inline">\(1.5386\)</span></td><td><span class="math inline">\(0.8751^{\circ}\)</span></td></tr></tbody></table><p>迭代到第 <span class="math inline">\(6\)</span>次时，角度误差已经小于 <span class="math inline">\(1^{\circ}\)</span>了， 通过表格可知：</p><p><span class="math display">\[x_{R} = 0.6072 \times 0.5867 = 0.3562\]</span></p><p><span class="math display">\[y_{R} = 0.6072 \times 1.5386 = 0.9342\]</span></p><p>通过计算器可知，<span class="math inline">\(\cos(70^{\circ}) =0.34202\)</span> ，<span class="math inline">\(\sin(70^{\circ}) =0.93969\)</span> ，误差已经在 <span class="math inline">\(\frac{1}{100}\)</span> 之下了，实际应用中我们会迭代 <span class="math inline">\(16\)</span>次，误差会<strong>非常小</strong>。</p><h1 id="在线-cordic-算法demo">在线 CORDIC 算法Demo</h1><p>通过上面分析，我们已经知道了 CORDIC算法的原理，下面就开始编程吧！</p><p>用 JavaScript 写了一个在线互动版本，<a href="http://www.longluo.me/projects/cordic/">传送门 →</a> ：</p><ol type="1"><li>可以调整不同迭代次数，和系统库函数 <span class="math inline">\(\textit{Math.cos}\)</span> ，<span class="math inline">\(\textit{Math.sin}\)</span> 进行比较：</li></ol><p><a href="http://www.longluo.me/projects/cordic/"><img src="https://user-images.githubusercontent.com/3395062/245661590-40c39225-cedf-41b1-94c4-25c526557edb.png" alt="Cordic Results"></a></p><ol start="2" type="1"><li>可以查看每次迭代的结果，掌握 Cordic 算法迭代原理：</li></ol><p><a href="http://www.longluo.me/projects/cordic/"><img src="https://user-images.githubusercontent.com/3395062/245661581-1ecbc272-8d70-4d3a-84ba-47c98c1bfacd.png" alt="Cordic Iteration Results"></a></p><h1 id="cordic-算法的优点">CORDIC 算法的优点</h1><p>CORDIC 算法相比其他算法的优点，体现在以下几个方面：</p><ol type="1"><li>简化运算：CORDIC算法主要使用位移、加法和减法等简单的运算，避免了复杂的乘法操作，从而提高了计算速度；</li><li>并行计算：CORDIC算法的迭代操作是相互独立的，可以进行并行计算，利用现代计算机的多核优势，进一步提升计算效率；</li><li>硬件优化：CORDIC算法适用于硬件实现，可以通过专用硬件电路（如FPGA）进行加速，极大地提高计算速度；</li><li>低存储需求：CORDIC算法只需存储一小组预先计算好的旋转角度，节省了存储空间；</li><li>迭代控制：通过控制迭代次数，可以平衡计算精度和计算速度，根据需求进行调整。</li></ol><h1 id="cordic-算法的不足">CORDIC 算法的不足</h1><p>几个月这篇文章发布之后，陆陆续续得到了不少读者的宝贵意见，有读者反馈说没有写CORDIC算法的<strong>缺点</strong>，也有读者反馈在他在嵌入式处理器STM32上还不如<a href="http://www.longluo.me/blog/2023/04/26/Taylor-Series/">泰勒展开式(TaylorSeries)</a> 快。</p><p>对于这 <span class="math inline">\(\large {2}\)</span>个问题，我又查阅了一些 CORDIC 算法<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 的资料，可以回答下这<span class="math inline">\(\large {2}\)</span> 个问题。</p><p>CORDIC 算法的不足之处在于下面几点：</p><h2 id="收敛速度慢">收敛速度慢</h2><p>CORDIC 算法的收敛速度较慢，比如当输入值 <span class="math inline">\(\large {\theta }\)</span> 很接近 <span class="math inline">\(\large {0}\)</span> 或 <span class="math inline">\(\large {\frac {\pi}{2}}\)</span>时，这个时候就需要进行<strong>多轮迭代</strong>才能达到足够的精度。</p><p>当 <span class="math inline">\(\large {\theta \approx 0 }\)</span>时，实际上只需要取前 <span class="math inline">\(\large {2}\)</span>项就有足够精度了，而且收敛速度快多了！</p><p><span class="math display">\[\sin(x) = x - \frac {1}{3!}x^3\]</span></p><p><span class="math display">\[\cos(x) = 1 - \frac {1}{2!}x^2\]</span></p><h2 id="精度">精度</h2><p>如上一小节，当输入值 <span class="math inline">\(\large {\theta}\)</span> 是小角度或者大角度的情况时，CORDIC算法的固定迭代次数可能也无法提供足够的精度。</p><h2 id="输入参数范围">输入参数范围</h2><p>CORDIC 算法在实际应用中需要考虑<strong>输入参数的限制</strong>，特别是幅值和角度范围，这是因为 CORDIC算法是一种<strong>迭代</strong>算法，对于较大的角度，需要更多的迭代次数才能达到所需的精度，从而导致计算效率的下降。</p><p>CORDIC算法适用于处理相对<strong>较小范围</strong>的角度，<strong>确切</strong>来说是在<span class="math inline">\([−99.88^{\circ} , 99.88^{\circ}]\)</span>的范围内表现最佳，下面我们来证明下：</p><p>由 CORDIC 算法计算过程可知：</p><p><span class="math display">\[\left | z[i] \right | \leq \sum_{j=i}^{\infty } \arctan 2^{-j}\]</span></p><p>那么可得：</p><p><span class="math display">\[\theta_{max} = z[0]_{max} = \sum_{j=0}^{\infty } \arctan 2^{-j} \approx1.7429(99.88^{\circ}) \quad \quad \sigma_j = 1, z[j] &gt; 0\]</span></p><p>假设 <span class="math inline">\(\large {\theta &lt;\theta_{max}}\)</span> ， 则有：</p><p><span class="math display">\[\left | z[i] \right | \leq \arctan (2^{−(i−1)})\]</span></p><p>因此</p><p><span class="math display">\[\arctan (2^{−i}) \leq \sum_{j=i+1}^{\infty } \arctan (2^{−j}) \quad\forall i\]</span></p><p>所以 CORDIC算法的输入范围是：<span class="math inline">\([−99.88^{\circ} , 99.88^{\circ}]\)</span> 。</p><h2 id="cordic-算法的fpga实现">CORDIC 算法的FPGA实现</h2><p>对于第 <span class="math inline">\(\large {2}\)</span>个问题，我不太清楚那位读者是如何测试的！如之前所述，在某些情况下，泰勒展开式是<strong>优于</strong>CORDIC 算法的！</p><p>CORDIC 算法是在硬件中实现的，是 FPGA 设计<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>中的经典例题。</p><h1 id="总结">总结</h1><p>CORDIC算法是一种高效计算三角函数值的方法。相比传统的泰勒展开式，它具有简单高效、低存储需求和迭代控制等优势。在需要计算三角函数值的应用中，CORDIC算法更快速、更节省资源。</p><h1 id="参考文献">参考文献</h1><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/CORDIC">CORDIC</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://en.wikibooks.org/wiki/Digital_Circuits/CORDIC">DigitalCircuits/CORDIC</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://zipcpu.com/dsp/2017/08/30/cordic.html">Using a CORDIC tocalculate sines and cosines in an FPGA</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;By Long Luo&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何一款科学计算器上都可以计算三角函数，三角函数应用于生活工作中的方方面面，但计算机是如何计算三角函数值的呢？&lt;/p&gt;
&lt;p&gt;三角函数本质上是直角三角形的3条边的&lt;strong&gt;比例关系&lt;/strong&gt;，计算并没有很直观，那么计算机是如何计算三角函数值的呢？&lt;/p&gt;
&lt;p&gt;在微积分中我们学习过 &lt;a href=&quot;http://www.longluo.me/blog/2023/04/26/taylor-series/&quot;&gt;泰勒公式&lt;/a&gt;
，我们知道可以使用泰勒展开式来对某个值求得其近似值，例如：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sin &#92;angle 18^{&#92;circ} = &#92;frac{&#92;sqrt {5} - 1}{4} &#92;approx 0.3090169943
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;利用泰勒公式，取前 &lt;span class=&quot;math inline&quot;&gt;&#92;(4&#92;)&lt;/span&gt; 项：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sin x &#92;approx x - &#92;frac{x^3}{3!} + &#92;frac{x^5}{5!} - &#92;frac{x^7}{7!}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代入可得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sin &#92;angle 18^{&#92;circ} = &#92;sin &#92;frac{&#92;pi}{10} = &#92;frac{&#92;pi}{10} -
&#92;frac{1}{6} (&#92;frac{&#92;pi}{10})^3 + &#92;frac{1}{120} (&#92;frac{&#92;pi}{10})^5 -
&#92;frac{1}{5040} (&#92;frac{&#92;pi}{10})^7 &#92;approx 0.30903399538
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可见取前 &lt;span class=&quot;math inline&quot;&gt;&#92;(4&#92;)&lt;/span&gt; 项时精度已经在 &lt;span class=&quot;math inline&quot;&gt;&#92;(10^{-5}&#92;)&lt;/span&gt;
之下，对于很多场合精度已经&lt;strong&gt;足够高&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;在没有了解 CORDIC(Coordinate Rotation Digital Computer) Algorithm &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;
算法之前，我一直以为计算器是利用泰勒公式去求解，最近才了解到原来在计算机中，CORDIC
算法&lt;strong&gt;远比&lt;/strong&gt;泰勒公式高效。&lt;/p&gt;
&lt;p&gt;下面我们就来了解下泰勒公式的不足之处和 CORDIC 算法是怎么做的。&lt;/p&gt;
&lt;h1 id=&quot;泰勒公式的缺点&quot;&gt;泰勒公式的缺点&lt;/h1&gt;
&lt;p&gt;上一节我们使用泰勒公式去计算三角函数值时，需要做很多次乘法运算，而计算器中乘法运算是很&lt;strong&gt;昂贵&lt;/strong&gt;的，其缺点如下所示：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;展开过小则会导致展开精度不够，展开过大则会导致计算量过大；&lt;/li&gt;
&lt;li&gt;幂运算需要使用乘法器，存在很多重复计算；&lt;/li&gt;
&lt;li&gt;需要很多变量来存储中间值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在之前的文章 &lt;a href=&quot;http://www.longluo.me/blog/2019/06/21/strassens-matrix-multiplication-algorithm/&quot;&gt;矩阵乘法的
Strassen 算法&lt;/a&gt;
，就是通过&lt;strong&gt;减少乘法，多做加法&lt;/strong&gt;，从而大大降低了运算量，那么我们可以用相同的思想来优化运算吗？&lt;/p&gt;
&lt;p&gt;当然可以，让我们请出今天的主角：&lt;strong&gt;CORDIC 算法&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://www.longluo.me/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.longluo.me/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://www.longluo.me/tags/Algorithm/"/>
    
    <category term="CORDIC" scheme="https://www.longluo.me/tags/CORDIC/"/>
    
    <category term="Trigonometry" scheme="https://www.longluo.me/tags/Trigonometry/"/>
    
  </entry>
  
</feed>
